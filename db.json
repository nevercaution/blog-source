{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"source/img/icon_wechat.png","path":"img/icon_wechat.png","modified":0,"renderable":0},{"_id":"source/img/404-bg.jpg","path":"img/404-bg.jpg","modified":0,"renderable":0},{"_id":"themes/beantech/source/css/archive.styl","path":"css/archive.styl","modified":0,"renderable":1},{"_id":"themes/beantech/source/css/beantech.css","path":"css/beantech.css","modified":0,"renderable":1},{"_id":"themes/beantech/source/css/beantech.min.css","path":"css/beantech.min.css","modified":0,"renderable":1},{"_id":"themes/beantech/source/css/highlight.styl","path":"css/highlight.styl","modified":0,"renderable":1},{"_id":"themes/beantech/source/css/hux-blog.min.css","path":"css/hux-blog.min.css","modified":0,"renderable":1},{"_id":"themes/beantech/source/css/rocket.styl","path":"css/rocket.styl","modified":0,"renderable":1},{"_id":"themes/beantech/source/css/signature.styl","path":"css/signature.styl","modified":0,"renderable":1},{"_id":"themes/beantech/source/css/toc.styl","path":"css/toc.styl","modified":0,"renderable":1},{"_id":"themes/beantech/source/css/widget.styl","path":"css/widget.styl","modified":0,"renderable":1},{"_id":"themes/beantech/source/fonts/glyphicons-halflings-regular.eot","path":"fonts/glyphicons-halflings-regular.eot","modified":0,"renderable":1},{"_id":"themes/beantech/source/fonts/glyphicons-halflings-regular.woff2","path":"fonts/glyphicons-halflings-regular.woff2","modified":0,"renderable":1},{"_id":"themes/beantech/source/fonts/glyphicons-halflings-regular.ttf","path":"fonts/glyphicons-halflings-regular.ttf","modified":0,"renderable":1},{"_id":"themes/beantech/source/fonts/glyphicons-halflings-regular.woff","path":"fonts/glyphicons-halflings-regular.woff","modified":0,"renderable":1},{"_id":"themes/beantech/source/js/bootstrap.min.js","path":"js/bootstrap.min.js","modified":0,"renderable":1},{"_id":"themes/beantech/source/js/hux-blog.js","path":"js/hux-blog.js","modified":0,"renderable":1},{"_id":"themes/beantech/source/js/hux-blog.min.js","path":"js/hux-blog.min.js","modified":0,"renderable":1},{"_id":"themes/beantech/source/js/jquery.tagcloud.js","path":"js/jquery.tagcloud.js","modified":0,"renderable":1},{"_id":"themes/beantech/source/js/jquery.nav.js","path":"js/jquery.nav.js","modified":0,"renderable":1},{"_id":"themes/beantech/source/js/toc.js","path":"js/toc.js","modified":0,"renderable":1},{"_id":"themes/beantech/source/js/totop.js","path":"js/totop.js","modified":0,"renderable":1},{"_id":"source/img/header_img/Iron-Man-3.jpg","path":"img/header_img/Iron-Man-3.jpg","modified":0,"renderable":0},{"_id":"source/img/ironman-draw.png","path":"img/ironman-draw.png","modified":0,"renderable":0},{"_id":"themes/beantech/source/css/bootstrap.min.css","path":"css/bootstrap.min.css","modified":0,"renderable":1},{"_id":"themes/beantech/source/fonts/glyphicons-halflings-regular.svg","path":"fonts/glyphicons-halflings-regular.svg","modified":0,"renderable":1},{"_id":"themes/beantech/source/js/bootstrap.js","path":"js/bootstrap.js","modified":0,"renderable":1},{"_id":"themes/beantech/source/js/jquery.min.js","path":"js/jquery.min.js","modified":0,"renderable":1},{"_id":"source/img/contact-bg.jpg","path":"img/contact-bg.jpg","modified":0,"renderable":0},{"_id":"source/img/signature/BeanTechSign-white.png","path":"img/signature/BeanTechSign-white.png","modified":0,"renderable":0},{"_id":"themes/beantech/source/css/images/ironman.png","path":"css/images/ironman.png","modified":0,"renderable":1},{"_id":"themes/beantech/source/css/images/rocket.png","path":"css/images/rocket.png","modified":0,"renderable":1},{"_id":"themes/beantech/source/css/bootstrap.css","path":"css/bootstrap.css","modified":0,"renderable":1},{"_id":"source/img/header_img/tf-logo-dark.png","path":"img/header_img/tf-logo-dark.png","modified":0,"renderable":0},{"_id":"source/img/signature/BeanTechSign-black.png","path":"img/signature/BeanTechSign-black.png","modified":0,"renderable":0},{"_id":"themes/beantech/source/js/jquery.js","path":"js/jquery.js","modified":0,"renderable":1},{"_id":"source/img/beantech-desktop.png","path":"img/beantech-desktop.png","modified":0,"renderable":0},{"_id":"source/img/header_img/tag-bg.png","path":"img/header_img/tag-bg.png","modified":0,"renderable":0},{"_id":"source/img/header_img/home-bg-o.png","path":"img/header_img/home-bg-o.png","modified":0,"renderable":0},{"_id":"source/img/header_img/home-bg-2-dark.png","path":"img/header_img/home-bg-2-dark.png","modified":0,"renderable":0},{"_id":"source/img/header_img/archive-bg.png","path":"img/header_img/archive-bg.png","modified":0,"renderable":0},{"_id":"source/img/header_img/bg.png","path":"img/header_img/bg.png","modified":0,"renderable":0}],"Cache":[{"_id":"source/.DS_Store","hash":"16f0295f39c85cac4cbded5821f8e1a04742b8ee","modified":1498048637000},{"_id":"source/404.md","hash":"54e71839030317799339a8901af56eead6ace4a5","modified":1521872326259},{"_id":"themes/beantech/LICENSE","hash":"2b209f06bebeb2a8c2b7e187e436f3e1e1fbc8a7","modified":1496992979000},{"_id":"themes/beantech/_config.yml","hash":"927cbb17035d04647c9d7b8c377db3c936c4835e","modified":1496994382000},{"_id":"source/_posts/.DS_Store","hash":"d2cf00878feba59cce38168f10bcee04554dec6b","modified":1497079590000},{"_id":"source/_posts/api-gateway-with-zuul.md","hash":"cfd62ed92c2aa212b4bf37e1951990e033aaab09","modified":1545627049958},{"_id":"source/_posts/django-orm-standalone.md","hash":"9c360558aed0d17c1685dfd0695357eb9721491d","modified":1523779721993},{"_id":"source/_posts/django-ajax.md","hash":"14b800f58c7949a59efe9b592210c77a5b8d0d79","modified":1523779615798},{"_id":"source/_posts/django-sso.md","hash":"fffe303d8038a8054a7c78255324fad3a31e9c22","modified":1523779731239},{"_id":"source/_posts/elasticsearch-java-high-level-client.md","hash":"74ebd8e19fb080cd5d9ab11c6d45c5fe00f37647","modified":1530189522678},{"_id":"source/_posts/elasticsearch-rest-client.md","hash":"965c58784a213bcd1e0936a81df281a41a8f535f","modified":1523779740127},{"_id":"source/_posts/retrofit-with-spring-boot.md","hash":"aa65d3aa73b45b4a387f1c603f87749db35dfc6f","modified":1546075178509},{"_id":"source/_posts/elasticsearch-with-kakaopage.md","hash":"7f50115b4592b79c2b7dff210dd832d96fbf505c","modified":1526807759470},{"_id":"source/_posts/spring-boot-actuator.md","hash":"80bf77fa9f9cd240a553b3b76822148be2dd059f","modified":1523771634530},{"_id":"source/_posts/spring-boot-custom-annotation.md","hash":"bca03de77d1939dfa95947aac49f319262223a12","modified":1523779603632},{"_id":"source/_posts/spring-boot-jsp.md","hash":"00449404bde9ce3935d5f2bceab8c7abf2ee6ab2","modified":1523779751335},{"_id":"source/_posts/spring-boot-redis-pub-sub.md","hash":"d6fe0ab419b9265aa3299e880c9a2ed98349a0a0","modified":1545627049960},{"_id":"source/_posts/store-inapp-in-python.md","hash":"312771a658a5b7cb2cefc182a3be889d7cd244bd","modified":1523779757935},{"_id":"source/about/index.md","hash":"1513766e20ac6b758188380068dceaed25a17ba8","modified":1521872326267},{"_id":"source/archive/index.md","hash":"fc8a4d63aa6bd0781f31c81b2bae9dc51ad4c051","modified":1521872326268},{"_id":"source/_posts/spring-boot-use-gradle-value.md","hash":"58b69340223edda35af4758f359b26115ab01ea5","modified":1528357647858},{"_id":"source/img/icon_wechat.png","hash":"4188058026609de06c6cac88b349a2da831a1783","modified":1496992979000},{"_id":"source/tags/index.md","hash":"5b23beab19a8bd5501a6082201711cbc6133a1dd","modified":1521872326279},{"_id":"themes/beantech/languages_to_be_added/de.yml","hash":"424a9c1e6ab69334d7873f6574da02ca960aa572","modified":1496992979000},{"_id":"themes/beantech/languages_to_be_added/default.yml","hash":"97326c9e6518d9f379778178b3b8f9a58434725d","modified":1496992979000},{"_id":"themes/beantech/languages_to_be_added/en.yml","hash":"97326c9e6518d9f379778178b3b8f9a58434725d","modified":1496992979000},{"_id":"themes/beantech/languages_to_be_added/no.yml","hash":"8ca475a3b4f8efe6603030f0013aae39668230e1","modified":1496992979000},{"_id":"themes/beantech/languages_to_be_added/es.yml","hash":"cb4eeca0ed3768a77e0cd216300f2b2549628b1b","modified":1496992979000},{"_id":"themes/beantech/languages_to_be_added/pl.yml","hash":"de7eb5850ae65ba7638e907c805fea90617a988c","modified":1496992979000},{"_id":"themes/beantech/languages_to_be_added/zh-CN.yml","hash":"7bfcb0b8e97d7e5edcfca8ab26d55d9da2573c1c","modified":1496992979000},{"_id":"themes/beantech/languages_to_be_added/ru.yml","hash":"42df7afeb7a35dc46d272b7f4fb880a9d9ebcaa5","modified":1496992979000},{"_id":"themes/beantech/languages_to_be_added/zh-TW.yml","hash":"9acac6cc4f8002c3fa53ff69fb8cf66c915bd016","modified":1496992979000},{"_id":"themes/beantech/layout/404.ejs","hash":"a4d73541a53e56b7dd46249c6d27cb59f4d97422","modified":1496992979000},{"_id":"themes/beantech/layout/about.ejs","hash":"edcf8fa3bf7093c974d418ffef42ac89c19af128","modified":1496992979000},{"_id":"themes/beantech/layout/archive.ejs","hash":"72a150c8dff0031a9107d12eaa7c2e6c6ce950d2","modified":1496992979000},{"_id":"themes/beantech/layout/layout.ejs","hash":"a5af5b99ac3456ab5da1a319455904b979b91601","modified":1496992979000},{"_id":"themes/beantech/layout/index.ejs","hash":"dc8a6eaa00d1e7c33a40979afe0953ed5d7b512e","modified":1496992979000},{"_id":"source/img/.DS_Store","hash":"ffd08ba3a921e83ef0780d5100093badab4538c8","modified":1496995114000},{"_id":"themes/beantech/layout/keynote.ejs","hash":"f5689862281e34dbe8402b0e72f632902e53e88b","modified":1496992979000},{"_id":"themes/beantech/layout/page.ejs","hash":"c90797e4394c5cb63c2515109480e766d04e486e","modified":1496992979000},{"_id":"themes/beantech/layout/tags.ejs","hash":"2c72eb2e89130658aa068d80d27b561b509c5dcd","modified":1496992979000},{"_id":"themes/beantech/layout/post.ejs","hash":"2d55684fc539dc281f9e2ec0409f09ea6ca43949","modified":1496992979000},{"_id":"source/img/404-bg.jpg","hash":"68f7d525269a94287e0ad18713ae232fb59dcf71","modified":1496992978000},{"_id":"source/img/header_img/.DS_Store","hash":"df2fbeb1400acda0909a32c1cf6bf492f1121e07","modified":1498048725000},{"_id":"themes/beantech/layout/_partial/footer.ejs","hash":"571ac3c45fc3264fa06c6c8f2a48a6e683ee744a","modified":1521872326279},{"_id":"themes/beantech/layout/_partial/head.ejs","hash":"aab017d25fef1fdb680460f9fb007b9a240470ee","modified":1521872326279},{"_id":"themes/beantech/layout/_partial/header.ejs","hash":"aafb744601042f0270d2e6595129ac8a73ad2608","modified":1496992979000},{"_id":"themes/beantech/layout/_partial/nav.ejs","hash":"4c905166c960852e9b9a3c9d5c680091e37b481f","modified":1496992979000},{"_id":"themes/beantech/layout/_partial/pagination.ejs","hash":"557d6bb069a1d48af49ae912994653f44b32a570","modified":1496992979000},{"_id":"themes/beantech/layout/_partial/sidebar.ejs","hash":"2e4e528a555917b2a267da4db2440bcc4a7a65ab","modified":1496992979000},{"_id":"themes/beantech/layout/_widget/archive.ejs","hash":"7594929d472806ca4c64d9906d9903a96de111a0","modified":1496992979000},{"_id":"themes/beantech/layout/_partial/toc.ejs","hash":"837f01e8a20e5023b4b292d1b3141a399567da65","modified":1496992979000},{"_id":"themes/beantech/layout/_widget/featured-tags.ejs","hash":"0c9ce1942f1943dc8891a9302a922ef1ffe300c5","modified":1496992979000},{"_id":"themes/beantech/layout/_widget/category.ejs","hash":"1cf485def07dc06e870dc9613767c6c614bcf428","modified":1496992979000},{"_id":"themes/beantech/layout/_widget/friends-blog.ejs","hash":"734d3775017aedac185028924baf890a71a74548","modified":1496992979000},{"_id":"themes/beantech/layout/_widget/recent-posts.ejs","hash":"e08ab8ba60e31638006acf27f066b989a0a3c433","modified":1496992979000},{"_id":"themes/beantech/layout/_widget/short-about.ejs","hash":"3b10bd768f6ef30a42b1703fbc9a88627f9bfdf1","modified":1496992979000},{"_id":"themes/beantech/source/css/archive.styl","hash":"715bcbd085eb95ec26c9805c11c374919cde971c","modified":1496992979000},{"_id":"themes/beantech/source/css/beantech.css","hash":"4c361354fd8e9851923fb21a620bc079380ebcd8","modified":1496992979000},{"_id":"themes/beantech/source/css/beantech.min.css","hash":"05a06230b1a9eca0b30cece54a397008cb77dc50","modified":1496992979000},{"_id":"themes/beantech/source/css/highlight.styl","hash":"e842080e6d580f0f70a7df71fbde3c4e49463c19","modified":1496992979000},{"_id":"themes/beantech/source/css/hux-blog.min.css","hash":"1baef04de262aeb7023d835429b49a805ac4ab40","modified":1496992979000},{"_id":"themes/beantech/source/css/rocket.styl","hash":"e15c51c8566ecd943112e57592888dd318b6fa6a","modified":1496992979000},{"_id":"themes/beantech/source/css/signature.styl","hash":"88159b31c59d59c01a0b534af57242662a2a3969","modified":1496992979000},{"_id":"themes/beantech/source/css/toc.styl","hash":"9e959cebf9aef87ecac0ea20db7ee96ea1c26b38","modified":1496992979000},{"_id":"themes/beantech/source/css/widget.styl","hash":"7a9f735f5ef323dc2950fbd9d76daa16c9a0f1a9","modified":1496992979000},{"_id":"themes/beantech/source/fonts/glyphicons-halflings-regular.eot","hash":"86b6f62b7853e67d3e635f6512a5a5efc58ea3c3","modified":1496992979000},{"_id":"themes/beantech/source/fonts/glyphicons-halflings-regular.woff2","hash":"ca35b697d99cae4d1b60f2d60fcd37771987eb07","modified":1496992979000},{"_id":"themes/beantech/source/fonts/glyphicons-halflings-regular.ttf","hash":"44bc1850f570972267b169ae18f1cb06b611ffa2","modified":1496992979000},{"_id":"themes/beantech/source/fonts/glyphicons-halflings-regular.woff","hash":"278e49a86e634da6f2a02f3b47dd9d2a8f26210f","modified":1496992979000},{"_id":"themes/beantech/source/js/bootstrap.min.js","hash":"b3f2ef9f985e7906c9360756b73cd64bf7733647","modified":1496992979000},{"_id":"themes/beantech/source/js/hux-blog.js","hash":"4b4d3c557405d04c3087d36c13e2834fe05c0f73","modified":1496992979000},{"_id":"themes/beantech/source/js/hux-blog.min.js","hash":"1563e7f70550ac6b30803d6f449719b853200e35","modified":1496992979000},{"_id":"themes/beantech/source/js/jquery.tagcloud.js","hash":"4e5fd0b07f3bd935f2e603710447e039e3677211","modified":1496992979000},{"_id":"themes/beantech/source/js/jquery.nav.js","hash":"ef2160a456176a4d09cc0b95d52b27dfbbadf2d8","modified":1496992979000},{"_id":"themes/beantech/source/js/toc.js","hash":"41e52551731854224c249d53010c1bae5aa92ffa","modified":1496992979000},{"_id":"themes/beantech/source/js/totop.js","hash":"c05360f6fc699ac12e794b1764b4a952713a3017","modified":1496992979000},{"_id":"source/img/header_img/Iron-Man-3.jpg","hash":"62a9a76854503c327990cc8d10de293ab6e9588f","modified":1496992978000},{"_id":"source/img/ironman-draw.png","hash":"7d6a06b4b544ab146c3b3e8474edc33f14ac6e4d","modified":1496992979000},{"_id":"themes/beantech/source/css/bootstrap.min.css","hash":"fec7b176a4b9a67c0eb5d184f57b84297efc23aa","modified":1496992979000},{"_id":"themes/beantech/source/fonts/glyphicons-halflings-regular.svg","hash":"de51a8494180a6db074af2dee2383f0a363c5b08","modified":1496992979000},{"_id":"themes/beantech/source/js/bootstrap.js","hash":"f8752e9ae24daec0a0baffd7819122f8c6fd9103","modified":1496992979000},{"_id":"themes/beantech/source/js/jquery.min.js","hash":"41b4bfbaa96be6d1440db6e78004ade1c134e276","modified":1496992979000},{"_id":"source/img/contact-bg.jpg","hash":"6af63305c923899017e727b5ca968a2703bc08cf","modified":1496992978000},{"_id":"source/img/signature/BeanTechSign-white.png","hash":"34289ed41cf9ddac2d56be46fbb1515b7d5913cd","modified":1496992979000},{"_id":"themes/beantech/source/css/images/ironman.png","hash":"2f0db0ab15d466c4065d9f6102fdf829726d9e3f","modified":1496992979000},{"_id":"themes/beantech/source/css/images/rocket.png","hash":"6dee0406955aa9b7a261161d30f2538a671e806b","modified":1496992979000},{"_id":"themes/beantech/source/css/bootstrap.css","hash":"41c54bf695145ae0b4d9020a1da308ceb05dcaf3","modified":1496992979000},{"_id":"source/img/header_img/tf-logo-dark.png","hash":"5c7bf8ade9de134f8c77a3c59e575abe9fc6cdd4","modified":1496992979000},{"_id":"source/img/signature/BeanTechSign-black.png","hash":"94b7102e819fd6ee082d3fb0166f4de7458c22ff","modified":1496992979000},{"_id":"themes/beantech/source/js/jquery.js","hash":"1852661bd11a09ca9b9cb63d1aa6ff390fffaf4e","modified":1496992979000},{"_id":"source/img/beantech-desktop.png","hash":"4a8f8b209c9db8fd5209f15b8e4590525e258b0f","modified":1496992978000},{"_id":"source/img/header_img/tag-bg.png","hash":"e83cd7b04ff85bcbc9bd3ebf5e57a55166e82568","modified":1496992979000},{"_id":"source/img/header_img/home-bg-o.png","hash":"134ece4cb4c49c7ca1403a5afe7f46d0e2f9ecbb","modified":1496992978000},{"_id":"source/img/header_img/home-bg-2-dark.png","hash":"da6a3d5ca787bdc25e69655abd879b4f821aeb30","modified":1496992978000},{"_id":"source/img/header_img/archive-bg.png","hash":"6bf9c224543ec54e250309db89cbdf46e0c4b5ba","modified":1496992978000},{"_id":"source/img/header_img/bg.png","hash":"48dcafc0a7a46376729167efb78e372834e3178e","modified":1521872326273},{"_id":"public/post-sitemap.xml","hash":"d7e33189fb050ed2e31a274ad58f2cf15998bfe0","modified":1546075411761},{"_id":"public/page-sitemap.xml","hash":"7a3be9b2bdc9e3606c9520325ae1808a7654e2a7","modified":1546075411763},{"_id":"public/tag-sitemap.xml","hash":"3cd6f21f19efd310c4958e87843fd91794e13804","modified":1546075412548},{"_id":"public/sitemap.xsl","hash":"4321fa69dc1b8811d32b7a1478e5603e038cea1a","modified":1546075412548},{"_id":"public/sitemap.xml","hash":"c1dd143daa5e321b1201876053232f4c0653ed68","modified":1546075412968},{"_id":"public/search.xml","hash":"b851540eb45877238ee9b8d7b5366b8333b21b74","modified":1546075412968},{"_id":"public/404.html","hash":"9771b3ab9d24e08312174111a174f168d2b05561","modified":1546075413034},{"_id":"public/about/index.html","hash":"2ceb31c6f518900b17a7787723a6194e995b8947","modified":1546075413034},{"_id":"public/tags/index.html","hash":"4775d9144998ef24d288e611cf2fa7286aea2ef4","modified":1546075413112},{"_id":"public/2018/10/23/api-gateway-with-zuul/index.html","hash":"39bd1d318d3cc4def449c8102165081d3104478c","modified":1546075413112},{"_id":"public/2018/07/16/spring-boot-redis-pub-sub/index.html","hash":"70f120dc1eb88a7f876e953cd45ce978548424c8","modified":1546075413154},{"_id":"public/2018/06/17/elasticsearch-java-high-level-client/index.html","hash":"a6055712179bdd3ad83171780873ba79cbe40ce8","modified":1546075413154},{"_id":"public/2018/05/20/spring-boot-use-gradle-value/index.html","hash":"2291442275ceaed259086728301e50137b6adf37","modified":1546075413157},{"_id":"public/2018/04/29/elasticsearch-with-kakaopage/index.html","hash":"86eebef79920977803a4c8628063c289cb3e653e","modified":1546075413157},{"_id":"public/2018/04/15/spring-boot-custom-annotation/index.html","hash":"baec5255fd2f439a52ca71e9c4af26b85018bf7d","modified":1546075413157},{"_id":"public/2018/03/24/spring-boot-actuator/index.html","hash":"1639df62820c1b4fb66f45e83ba1ff68419aa21b","modified":1546075413157},{"_id":"public/2018/03/15/elasticsearch-rest-client/index.html","hash":"c2e7cb63fa79648dbfafad59c312e13822a8e138","modified":1546075413157},{"_id":"public/2018/02/22/spring-boot-jsp/index.html","hash":"9a150e2638497af477bd7fa4e90a15b3a8119468","modified":1546075413157},{"_id":"public/2017/06/23/django-orm-standalone/index.html","hash":"187a568887e2258d2640cda93b3daf4e384b3682","modified":1546075413157},{"_id":"public/2016/05/06/django-sso/index.html","hash":"2940e7af60006e58cf0a162eb780c66fcf9df0f0","modified":1546075413157},{"_id":"public/2016/03/27/django-ajax/index.html","hash":"2d48258adcd6713e5e1425a11ae0e8fab36eeac5","modified":1546075413157},{"_id":"public/2016/03/11/store-inapp-in-python/index.html","hash":"4cfd5bdd4989f2c50f016a5d145f3992b71ffa15","modified":1546075413158},{"_id":"public/archive/index.html","hash":"ae893670e9ab810e0c7593b8572bb834c8dd6bbc","modified":1546075413158},{"_id":"public/archives/index.html","hash":"cc910752d0dca150d78a4d0e5b710f4c280e8dd4","modified":1546075413159},{"_id":"public/archives/archives/2/index.html","hash":"3451b767cd1268b081c13ed526b823cba4de117f","modified":1546075413159},{"_id":"public/archives/2016/index.html","hash":"adc0240fa5a7267186b97cbc0df0144bbcc826a4","modified":1546075413159},{"_id":"public/archives/2016/03/index.html","hash":"99f3e0765c0d8992c2a4068fc7a39620b55590b5","modified":1546075413159},{"_id":"public/archives/2016/05/index.html","hash":"3a2030a962caffd4301a63473459e54e172457b3","modified":1546075413159},{"_id":"public/archives/2017/index.html","hash":"fc6e156a92c8dc918316055805ab18d9d4080b6c","modified":1546075413159},{"_id":"public/archives/2017/06/index.html","hash":"186b4441403a9c786b0d74e02e02ba92c4211946","modified":1546075413159},{"_id":"public/archives/2018/index.html","hash":"bf6b906035bb469773efe14ef60d1bf483920d80","modified":1546075413159},{"_id":"public/archives/2018/02/index.html","hash":"e46b68ed12ec4317a17e18fe9cc0fe784ed720f2","modified":1546075413159},{"_id":"public/archives/2018/03/index.html","hash":"4f8ed69f6608bdfee664e93b68e66a08e4912d02","modified":1546075413159},{"_id":"public/archives/2018/04/index.html","hash":"754480b29c400ca85a4cbd66fcc53e56bacdaf52","modified":1546075413159},{"_id":"public/archives/2018/05/index.html","hash":"f4c242e69343fbd745058aaef5002356ff6ef765","modified":1546075413159},{"_id":"public/archives/2018/06/index.html","hash":"4c98072918540344ea6520c2d63105ae31cdd114","modified":1546075413159},{"_id":"public/archives/2018/07/index.html","hash":"e18d67cf90530a813b139ec60df75f4c89aa80f6","modified":1546075413159},{"_id":"public/archives/2018/10/index.html","hash":"31a8e58f82175d8bcb4da62ae91833181be5aa22","modified":1546075413160},{"_id":"public/index.html","hash":"ff384ab94f68e189a8a3b3b0ee8cc0f8beea1a3c","modified":1546075413160},{"_id":"public/archives/2/index.html","hash":"1129b010c1bfc45f025afdb612c7596af090ee9e","modified":1546075413160},{"_id":"public/tags/netflix-zuul/index.html","hash":"71520098939ea5e2de4e5abafdf7de7a7166e3f6","modified":1546075413160},{"_id":"public/tags/springboot/index.html","hash":"25e2084a89426165bc32804bb987682c346ceae7","modified":1546075413160},{"_id":"public/tags/spring-cloud/index.html","hash":"5781b5e9c4483b08421bb71d9b7d0ad4d6c25f5b","modified":1546075413160},{"_id":"public/tags/api-gateway/index.html","hash":"9385cb3565d2937e0188621d1ad40398aa1975b7","modified":1546075413160},{"_id":"public/tags/python/index.html","hash":"d06fded7095c04f3f33287f7e9e07fc74387a642","modified":1546075413160},{"_id":"public/tags/django/index.html","hash":"ad5e8e068e943e7c227b7575d36025c267923b22","modified":1546075413160},{"_id":"public/tags/orm/index.html","hash":"474aad57d8667586ef2be9d00c8ae0dacb4c2094","modified":1546075413160},{"_id":"public/tags/docker/index.html","hash":"5ada836e0957e0b3d2caa093f003952f86f289db","modified":1546075413160},{"_id":"public/tags/ajax/index.html","hash":"76fea6a36f02765f9995cab0ff3f79425542ce7f","modified":1546075413160},{"_id":"public/tags/sso/index.html","hash":"d7770432a231564debad665dbf7c26defb8dc6ae","modified":1546075413160},{"_id":"public/tags/elasticsearch/index.html","hash":"38659745303582b86da84a19a90000049dc2b7ea","modified":1546075413160},{"_id":"public/tags/restclient/index.html","hash":"d6a891e3fb9317b8fe3c31f0b2d03e9c62b9cd57","modified":1546075413161},{"_id":"public/tags/javaclient/index.html","hash":"eb80585a01f423b23af71ded1d6e63eac3bb6170","modified":1546075413161},{"_id":"public/tags/transportlyer/index.html","hash":"ee18f19717603e2dcbecf1bc44b0307beabfdb96","modified":1546075413161},{"_id":"public/tags/resthighlevelclient/index.html","hash":"545a76b5ac4e1a3a8a2a53283a9f955794d65767","modified":1546075413161},{"_id":"public/tags/sptingboot/index.html","hash":"ad0904d0addf55b05c983b8b82d7aa36da31a125","modified":1546075413161},{"_id":"public/tags/webflux/index.html","hash":"15a1dca1bef90dd70a786ea69879136424e68507","modified":1546075413161},{"_id":"public/tags/gradle/index.html","hash":"9574a8d4e51588974baa22feacd30bd38af5178f","modified":1546075413161},{"_id":"public/tags/kakaopage/index.html","hash":"4dc1ff2393c7747ece0a4c21db8f07ea547f8e81","modified":1546075413161},{"_id":"public/tags/은전한닢/index.html","hash":"3474e025e5ef165c403668960a1a38b6a4938cc9","modified":1546075413161},{"_id":"public/tags/spring-boot-actuator/index.html","hash":"bf0cb8f7010666f098050d1e1da73405fd26f789","modified":1546075413161},{"_id":"public/tags/annotation/index.html","hash":"06e9af718ac5d7aa371de27da00cc9fa0851c614","modified":1546075413161},{"_id":"public/tags/argumentresolver/index.html","hash":"673dac5bef4ba4083c9efbfa6dcd1b28230114f4","modified":1546075413161},{"_id":"public/tags/jsp/index.html","hash":"056d349be06bbaf189b7b0ea02c4cd49018411f6","modified":1546075413161},{"_id":"public/tags/freemarker/index.html","hash":"f0ceac402e488a8d99fd7b9f8af2fa5b50403da1","modified":1546075413161},{"_id":"public/tags/redis/index.html","hash":"ccb4257038d6d05fa37914983cd2b97bc288f379","modified":1546075413161},{"_id":"public/tags/pubsub/index.html","hash":"4f9d997c4b8cbe55dba07434cf659d35093b409c","modified":1546075413161},{"_id":"public/tags/dynamicConfiguration/index.html","hash":"96ca3809f7eab497bcedff3f1c13093f955b15ce","modified":1546075413161},{"_id":"public/tags/lettuce/index.html","hash":"67641488e3b5862aafd36ee85c883ac3c3b0e937","modified":1546075413161},{"_id":"public/tags/ios/index.html","hash":"7f7c7ab43ae1117e0f7836503fc8441577636f0e","modified":1546075413162},{"_id":"public/tags/android/index.html","hash":"93af8652fc1174c29d5bd646934228de4456a71b","modified":1546075413162},{"_id":"public/tags/inapp/index.html","hash":"a46fd00bcce0f723c12ff65c57c5f5b5279d1231","modified":1546075413162},{"_id":"public/tags/logging/index.html","hash":"dfa5f3f65b7f6a1a12777c759c720ff276f6e9cf","modified":1546075413162},{"_id":"public/2018/12/29/retrofit-with-spring-boot/index.html","hash":"d4bee31a5be916ca0b9c621713fc1bc0acbf98a6","modified":1546075413166},{"_id":"public/archives/2018/12/index.html","hash":"cb7d6982221bf0e3db36ac9dc7065f3ff95f6bfc","modified":1546075413166},{"_id":"public/tags/retrofit2/index.html","hash":"38d89c450fd09f5065c0d106338043db1d61c45e","modified":1546075413166},{"_id":"public/tags/okhttp3/index.html","hash":"2a1d231ebc977fb1d7dc8557c61f05301ebc72ff","modified":1546075413167},{"_id":"public/tags/async/index.html","hash":"d947c192db2853221067d461e60112aa60106b8e","modified":1546075413167}],"Category":[],"Data":[],"Page":[{"layout":"404","description":":(","header-img":"img/header_img/bg.png","_content":"","source":"404.md","raw":"---\nlayout: 404\ndescription: \":(\"\nheader-img: \"img/header_img/bg.png\"\n---\n","date":"2018-03-24T06:18:46.259Z","updated":"2018-03-24T06:18:46.259Z","path":"404.html","title":"","comments":1,"_id":"cjq98sonh00008ghh36rrpy73","content":"","site":{"data":{}},"excerpt":"","more":""},{"layout":"about","title":"About","date":"2016-04-20T19:48:33.000Z","description":"hello teddy","header-img":"img/header_img/bg.png","comments":0,"_content":"\n> why be normal?\n\n","source":"about/index.md","raw":"---\nlayout: \"about\"\ntitle: \"About\"\ndate: 2016-04-21 04:48:33\ndescription: \"hello teddy\"\nheader-img: \"img/header_img/bg.png\"\ncomments: false\n---\n\n> why be normal?\n\n","updated":"2018-03-24T06:18:46.267Z","path":"about/index.html","_id":"cjq98sop300028ghh7lo8qlg7","content":"<blockquote>\n<p>why be normal?</p>\n</blockquote>\n","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p>why be normal?</p>\n</blockquote>\n"},{"layout":"archive","title":"Archives","header-img":"img/header_img/bg.png","comments":0,"date":"2017-03-20T11:49:56.000Z","description":"","_content":"","source":"archive/index.md","raw":"---\nlayout: \"archive\"\ntitle: \"Archives\"\nheader-img: \"img/header_img/bg.png\"\ncomments: false\ndate: 2017-03-20 20:49:56\ndescription: \"\"\n---\n","updated":"2018-03-24T06:18:46.268Z","path":"archive/index.html","_id":"cjq98sopa00048ghhgselzb9k","content":"","site":{"data":{}},"excerpt":"","more":""},{"layout":"tags","title":"Tags","description":"","header-img":"img/header_img/bg.png","_content":"","source":"tags/index.md","raw":"---\nlayout: \"tags\"\ntitle: \"Tags\"\ndescription: \"\"\nheader-img: \"img/header_img/bg.png\"\n---\n","date":"2018-03-24T06:18:46.279Z","updated":"2018-03-24T06:18:46.279Z","path":"tags/index.html","comments":1,"_id":"cjq98sorn00348ghhd2ip3mix","content":"","site":{"data":{}},"excerpt":"","more":""}],"Post":[{"title":"API Gateway 구축하기 - Spring Cloud Zuul","catalog":true,"date":"2018-10-23T08:32:01.000Z","subtitle":null,"header-img":"/img/header_img/bg.png","_content":"api gatway 를 도입했다. 레거시 프로젝트를 정리하면서 msa 구조로 가게 되었고 필요에 따라 서비스들이 나뉘고 있어서 이를 한곳에서 관리해줄 필요가 있었다. 구조를 설계하면서 어느 레벨까지를 gateway 에서 처리할지에 대해 여러 고민이 있었고 너무나 크지 않은 선에서 일차적으로 도입을 하게 되었다.    \ngateway 를 구성하기 위해 아래의 3개의 프로젝트를 설정한다.  \n1. 라우팅을 해줄 gateway (zuul gateway)  \n2. gateway 와 zuul 설정을 연결해줄 중간자 (spring cloud config)  \n3. zuul 설정을 저장할 저장소 (git)   \n\n### 1. gateway 구성\nspringboot, gradle 로 구성을 했고 버전은 2를 사용한다. spring cloud zuul 도 있지만 버전2에서는 아직 추가되지 않아 netflix zuul 을 사용하기로 한다.  \n#### 빌드 설정\n\n`build.gradle`\n\n```gradle\nbuildscript {\n    ext {\n        springBootVersion = '2.0.6.RELEASE'\n    }\n    repositories {\n        mavenCentral()\n    }\n    dependencies {\n        classpath(\"org.springframework.boot:spring-boot-gradle-plugin:${springBootVersion}\")\n    }\n}\n \napply plugin: 'java'\napply plugin: 'eclipse'\napply plugin: 'groovy'\napply plugin: 'org.springframework.boot'\napply plugin: 'io.spring.dependency-management'\n \ngroup = 'com.nevercaution'\nversion = '0.0.1-SNAPSHOT'\nsourceCompatibility = 1.8\n \ndependencies {\n    compile('org.springframework.cloud:spring-cloud-starter-netflix-zuul') \n    compile('org.springframework.cloud:spring-cloud-starter-config')\n    compile('org.codehaus.groovy:groovy-all')\n    compile('com.googlecode.json-simple:json-simple')\n \n    testCompile('org.springframework.boot:spring-boot-starter-test')\n \n}\n \ndependencyManagement {\n    imports {\n        mavenBom \"org.springframework.cloud:spring-cloud-dependencies:Finchley.SR1\"\n    }\n}\n```\n\n#### 프로젝트 설정\n  \n```\nspring-cloud 를 사용할 때엔 application.yml 보다 bootstrap.yml 을 먼저 읽어 들인다.  \n먼저 읽은 값을 기반으로 application.yml 에 설정된 값들을 함께 사용하기 위함이다.\n```\n\napplication.name 과 spring.profiles.active 두 값으로 cloud config 에 정보를 요청한다. 이 값을 적지 않을 경우엔 값을 가져오지 못한다. 또한 profiles.active 를 명시해주지 않으면 기본적으로 default profile 로 로드를 시도한다.\n\n`bootstrap.yml`  \n\n```yml\nspring:\n  profiles:\n    active: local\n  # 이 이름으로 spring cloud config server 에서 정보를 가져온다.\n  application:\n    name: gateway\n \n---\n########################################\n###              local               ###\n########################################\nspring:\n  profiles: local\n  cloud:\n    config:\n      uri: http://localhost:8889\n---\n```\n\nspring-cloud 에서 zuul route 설정들을 받아온다. 만약 spring-cloud 가 죽었을 경우를 대비해야 한다면 route 설정값들을 application.yml 에 해주면 된다.\n참고로 spring-cloud-config 기본 주소는 localhost:8888 이다. 즉 8888포트로 사용할 거라면 따로 설정하지 않아도 기본으로 이 주소로 접근을 시도한다. 원하는 경로로 사용할 경우에는 반드시 명시해주어야 한다.  \n\n필요에 따라 zuul 설정을 여기에서 해줘도 된다. 만약 cloud config 에서 값을 읽어들이지 못할 경우엔 여기에 있는 값을 사용하게 된다.\n\n`application.yml`  \n\n```yml\nspring:\n  # groovy template 는 사용하지 않는다.\n  groovy:\n    template:\n      cache: false\n \n \n# 필요한 actuator end point 만 열어둔다.\nmanagement:\n  endpoints:\n    web:\n      exposure:\n        # 원하는 endpoint 를 추가할 수 있다.\n        include: info, routes, filters, refresh\n \n \n---\n########################################\n###              local               ###\n########################################\nspring:\n  profiles: local\n \nserver:\n  port: 8087\n \n# 여기서 설정도 가능하다. 우선순위는 cloud config 가 더 높다.\n#zuul:\n#  routes:\n#    apiService:\n#      stripPrefix: false\n#      path: /api/**\n#      url: https://new-api-service.com\n---\n```\n\napplication 에 @EnableZuulProxy 만 달아주면 gateway는 설정이 모두 끝난다. \n\n`GatewayApplication.java`  \n\n```java\nimport org.springframework.boot.SpringApplication;\nimport org.springframework.boot.autoconfigure.SpringBootApplication;\nimport org.springframework.cloud.netflix.zuul.EnableZuulProxy;\n \n@EnableZuulProxy  // 이 annotation 만 추가하면 된다.\n@SpringBootApplication\npublic class GatewayApplication {\n \n    public static void main(String[] args) {\n        SpringApplication.run(GatewayApplication.class, args);\n    }\n}\n```\n\n### 2. spring-cloud-config-server 설정\nconfig-server 는 cloud-config 에 저장되어있는 설정들을 gateway 들이 가져갈 수 있도록 중간에서 설정값을 가져오는 역할을 한다.\n\n#### 빌드설정\n\n`build.gradle`  \n\n```gradle\nbuildscript {\n    ext {\n        springBootVersion = '2.0.6.RELEASE'\n    }\n    repositories {\n        mavenCentral()\n    }\n    dependencies {\n        classpath(\"org.springframework.boot:spring-boot-gradle-plugin:${springBootVersion}\")\n    }\n}\n \napply plugin: 'java'\napply plugin: 'eclipse'\napply plugin: 'org.springframework.boot'\napply plugin: 'io.spring.dependency-management'\n \ngroup = 'com.nevercaution'\nversion = '0.0.1-SNAPSHOT'\nsourceCompatibility = 1.8\n \next {\n    springCloudVersion = 'Finchley.SR1'\n}\n \ndependencies {\n    compile('org.springframework.cloud:spring-cloud-config-server')\n    testCompile('org.springframework.boot:spring-boot-starter-test')\n}\n \ndependencyManagement {\n    imports {\n        mavenBom \"org.springframework.cloud:spring-cloud-dependencies:${springCloudVersion}\"\n    }\n}\n```\n\n#### 프로젝트 설정\n\n`application.yml`  \n\n```yml\nserver:\n  port: 8889\n \nspring:\n  cloud:\n    config:\n      server:\n        git:\n          uri: https://github.com/user/cloud-config/config.git\n          username: username\n          password: password\n```\nconfig-server 역시 application 에 @EnableConfigServer 달아주면 끝.  \ngateway 에서 필요한 값들은 config.git 에서 받아온다.  \n\n`Application.java`   \n\n```java\n \nimport org.springframework.boot.SpringApplication;\nimport org.springframework.boot.autoconfigure.SpringBootApplication;\nimport org.springframework.cloud.config.server.EnableConfigServer;\n \n@EnableConfigServer  // 이 annotation 만 적어주면 끝.\n@SpringBootApplication\npublic class MimirApplication {\n \n    public static void main(String[] args) {\n        SpringApplication.run(MimirApplication.class, args);\n    }\n}\n```\n\n### 3. config 설정\ncloud-config 는 gateway 에서 사용할 zuul 에 관련된 설정들을 모아놓는 곳이다. \n\n`gateway.yml`\n\n```yml\n---\n########################################\n###              local               ###\n########################################\nspring:\n  profiles: local\n \n# zuul route 설정들. \nzuul:\n  routes:\n    apiService:\n      stripPrefix: false\n      path: /api/**\n      url: https://new-api-service.com\n \n# groovy filter 가 있는 경로를 적어준다.\ngateway:\n  zuul:\n    filters:\n      base-path: /path/to/filter/\n---\n```\n\n### 정리하자면\ngateway 에서는 zuul route 설정들을 이용해서 요청들을 받아서 처리해준다.\ngateway 에서 route 설정들을 받아오기 위해서 spring-cloud-server 에 spring-cloud-config 정보를 요청한다.\nspring-cloud-server 에서는 spring-cloud-config 에 있는 정보를 조회해서 gateway 에 내려준다.\n\n### zuul filter 사용\n특정 상황에 대처하기 위해 필터를 걸 수 있다. java 로 추가할 수도 있지만 내용이 변경시 서비스가 재기동되어야 하기 때문에 groovy 로 필터를 사용한다.\ngateway 에서는 지정된 경로에 groovy filter 들을 로드 시킨다.\ngateway 에서 gateway.zuul.filters.base-path 이 값은 spring-cloud-config 에서 받아와서 로드한다.\nFileManager.init 에서 첫번째 파라미터는 이 경로에 몇초마다 파일들을 갱신할지 여부이다. 짧게 가져갈수록 부하가 있지만 대신 코드가 빠르게 적용된다.\n\n`ZuulFilterCommandLineRunner.java` \n\n```java\nimport com.netflix.zuul.FilterFileManager;\nimport com.netflix.zuul.FilterLoader;\nimport com.netflix.zuul.groovy.GroovyCompiler;\nimport com.netflix.zuul.groovy.GroovyFileFilter;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport org.springframework.beans.factory.annotation.Value;\nimport org.springframework.boot.CommandLineRunner;\nimport org.springframework.stereotype.Component;\n \n@Component\npublic class ZuulFilterCommandLineRunner implements CommandLineRunner {\n    private static Logger log = LoggerFactory.getLogger(ZuulFilterCommandLineRunner.class);\n     \n    // cloud config 에 정의된 경로에서 로드한다.\n    @Value(\"${gateway.zuul.filters.base-path}\")\n    private String filterBasePath;\n \n    @Override\n    public void run(String... args) {\n        FilterLoader.getInstance().setCompiler(new GroovyCompiler());\n        try {\n            log.debug(\"load try file : \" + filterBasePath);\n            FilterFileManager.setFilenameFilter(new GroovyFileFilter());\n            FilterFileManager.init(1, this.filterBasePath + \"pre\", this.filterBasePath + \"route\", this.filterBasePath + \"post\");\n        } catch (Exception e) {\n            log.error(\"load fail \" + filterBasePath, e);\n            throw new RuntimeException(e);\n        }\n    }\n}\n```\n\n뒤에 파일 경로는 성격에 따라 pre, route, post 폴더들로 구분이 된다. 자세한 정보는 [zuul filter](https://cloud.spring.io/spring-cloud-netflix/multi/multi__router_and_filter_zuul.html#_custom_zuul_filter_examples) 문서 에서 확인할 수 있다.\n\ngroovy filter 는 ZuulFilter 를 상속받아서 구현한다.\n\n`Route.groovy`\n\n```groovy\nimport com.netflix.zuul.ZuulFilter\nimport com.netflix.zuul.context.RequestContext\nimport com.netflix.zuul.exception.ZuulException\nimport org.slf4j.Logger\nimport org.slf4j.LoggerFactory\n \nimport static org.springframework.cloud.netflix.zuul.filters.support.FilterConstants.PROXY_KEY\nimport static org.springframework.cloud.netflix.zuul.filters.support.FilterConstants.SIMPLE_HOST_ROUTING_FILTER_ORDER\n \npublic class SimpleRoute extends ZuulFilter {\n \n    private static final Logger logger = LoggerFactory.getLogger(SimpleRoute.class);\n \n    @Override\n    String filterType() {\n        return \"route\"\n    }\n \n    @Override\n    int filterOrder() {\n        return SIMPLE_HOST_ROUTING_FILTER_ORDER - 1\n    }\n \n    @Override\n    boolean shouldFilter() {\n        return true\n    }\n \n    @Override\n    Object run() throws ZuulException {\n        def ctx = RequestContext.getCurrentContext()\n        def req = ctx.getRequest()\n \n        def host = ctx.getRouteHost()\n         \n        try {\n \n            RequestContext.currentContext.setRouteHost(new URL(\"https://another-new-api-service.com\"))\n             \n            logger.info(\"REQUEST:: \" + req.getScheme() + \" \" + req.getRemoteAddr() + \":\" + req.getRemotePort())\n \n            logger.info(\"REQUEST:: > \" + req.getMethod() + \" \" + req.getRequestURI() + \" \" + req.getProtocol())\n        } catch(Exception e) {\n            logger.error(\"errer handling\")\n            ctx.setRouteHost(host)\n        }\n \n \n        return null\n    }\n}\n```\n\n### zuul route 동적으로 변경하기\nzuul route 정보들은 동적으로 추가하거나 변경할 수 있다. spring-cloud-config 에서 설정값을 추가하거나 변경을 하고 gateway 에서 actuator 를 이용해서 갱신을 시켜주면 route 설정들이 동적으로 갱신된다.\n\nroute 설정을 편집하거나 추가하는 상황이다.\n\n#### 1. route 설정 편집과 추가 하기\n\n`gateway.yml` \n\n```yml\n########################################\n###              local               ###\n########################################\nspring:\n  profiles: local\n\nzuul:\n  routes:\n    apiService:\n      stripPrefix: false\n      path: /api/**\n      # 1. 기존 경로를 변경\n      url: https://some-api-service.com\n    # 2. 새로추가되는 서비스\n    searchService:\n      stripPrefix: false\n      path: /search/**\n      url: https://search-api-service.com\n \n# groovy filter 가 있는 경로를 적어줍니다.\ngateway:\n  zuul:\n    filters:\n      base-path: /path/to/filter/   \n```\n\n1 번 주석 부분은 기존에 api 라는 경로로 들어왔을 때 new-api-service.com 에서 some-api-service.com 으로 변경을 해주었다.\n2 번 주석 부분은 새로 추가되는 경로이다.\n이렇게 추가와 수정을 해주고 commit/push 를 해준다. push 를 한다고 해서 바로 변경점이 반영되지 않는다.\n\n#### 2. gateway 에서 refresh\nzuul 은 내부적으로 spring-boot-actuator 가 의존성으로 걸려있다. actuator 를 이용해서 spring-cloud-server 를 통해 spring-cloud-config 값들을 동적으로 가져올 수 있다.\n\n```bash\n$ curl -XPOST localhost:8080/actuator/refresh\n[\"config.client.version\",\"zuul.routes.apiService.url\",\"zuul.routes.searchService.path\",\"zuul.routes.searchService.stripPrefix\",\"zuul.routes.searchService.url\"]\n```\ngateway 에서 /refresh 를 호출하게 되면 처음에 받아왔던 정보에서 변경점들만 가져와서 다시 로딩한다.\n\n## 결론\n### route 동적 편집 가능\nzuul 을 이용해서 경로에 따라 원하는 도메인으로 routing 을 해줄 수 있다. 이 설정값들은 spring-cloud-config 에 저장되어 있는데 이 값들을 동적으로 편집할 수 있다. 이 동작은 spring-actuator 을 이용한다.\n\npost 요청으로 `/actuator/refresh` 를 gateway 에 호출하면 반영이 된다. \n\n### filter 동적 편집 가능\nfilter 역시 동적으로 편집하거나 추가할 수 있는데, 이는 zuul file manager 를 통해 특정 경로에 있는 groovy filter file 들을 로드해서 읽어서 사용한다. file manager 가 주기적으로 파일의 동기화를 하고 있으므로 파일을 수정하면 지정된 시간마다 동기화를 한다.\n\ngateway 를 도입하고나서 추가적으로 할 수 있는 것들이 생겼다. 화이트리스트를 만들어 특정 서버군으로 보낼 수도 있고 사용자별로 A/B 테스트를 해볼 수도 있을 것이다. 블랙리스트들도 걸러줄 수 있게 된다. (nginx 에서도 처리가 가능하지만 좀 더 동적으로 가능하고 형상관리도 가능하겠다.) 추가적으로 로그를 모으거나 springboot admin 등을 통해서 gateway 상태도 살펴볼 수있을듯 하다. 예제코드는 [여기](https://github.com/nevercaution/spring-cloud-zuul-example) 에서 확인할 수 있다.\n","source":"_posts/api-gateway-with-zuul.md","raw":"---\ntitle: API Gateway 구축하기 - Spring Cloud Zuul\ncatalog: true\ndate: 2018-10-23 17:32:01\nsubtitle:\nheader-img: \"/img/header_img/bg.png\"  \ntags:\n- netflix-zuul\n- springboot\n- spring-cloud\n- api-gateway\n---\napi gatway 를 도입했다. 레거시 프로젝트를 정리하면서 msa 구조로 가게 되었고 필요에 따라 서비스들이 나뉘고 있어서 이를 한곳에서 관리해줄 필요가 있었다. 구조를 설계하면서 어느 레벨까지를 gateway 에서 처리할지에 대해 여러 고민이 있었고 너무나 크지 않은 선에서 일차적으로 도입을 하게 되었다.    \ngateway 를 구성하기 위해 아래의 3개의 프로젝트를 설정한다.  \n1. 라우팅을 해줄 gateway (zuul gateway)  \n2. gateway 와 zuul 설정을 연결해줄 중간자 (spring cloud config)  \n3. zuul 설정을 저장할 저장소 (git)   \n\n### 1. gateway 구성\nspringboot, gradle 로 구성을 했고 버전은 2를 사용한다. spring cloud zuul 도 있지만 버전2에서는 아직 추가되지 않아 netflix zuul 을 사용하기로 한다.  \n#### 빌드 설정\n\n`build.gradle`\n\n```gradle\nbuildscript {\n    ext {\n        springBootVersion = '2.0.6.RELEASE'\n    }\n    repositories {\n        mavenCentral()\n    }\n    dependencies {\n        classpath(\"org.springframework.boot:spring-boot-gradle-plugin:${springBootVersion}\")\n    }\n}\n \napply plugin: 'java'\napply plugin: 'eclipse'\napply plugin: 'groovy'\napply plugin: 'org.springframework.boot'\napply plugin: 'io.spring.dependency-management'\n \ngroup = 'com.nevercaution'\nversion = '0.0.1-SNAPSHOT'\nsourceCompatibility = 1.8\n \ndependencies {\n    compile('org.springframework.cloud:spring-cloud-starter-netflix-zuul') \n    compile('org.springframework.cloud:spring-cloud-starter-config')\n    compile('org.codehaus.groovy:groovy-all')\n    compile('com.googlecode.json-simple:json-simple')\n \n    testCompile('org.springframework.boot:spring-boot-starter-test')\n \n}\n \ndependencyManagement {\n    imports {\n        mavenBom \"org.springframework.cloud:spring-cloud-dependencies:Finchley.SR1\"\n    }\n}\n```\n\n#### 프로젝트 설정\n  \n```\nspring-cloud 를 사용할 때엔 application.yml 보다 bootstrap.yml 을 먼저 읽어 들인다.  \n먼저 읽은 값을 기반으로 application.yml 에 설정된 값들을 함께 사용하기 위함이다.\n```\n\napplication.name 과 spring.profiles.active 두 값으로 cloud config 에 정보를 요청한다. 이 값을 적지 않을 경우엔 값을 가져오지 못한다. 또한 profiles.active 를 명시해주지 않으면 기본적으로 default profile 로 로드를 시도한다.\n\n`bootstrap.yml`  \n\n```yml\nspring:\n  profiles:\n    active: local\n  # 이 이름으로 spring cloud config server 에서 정보를 가져온다.\n  application:\n    name: gateway\n \n---\n########################################\n###              local               ###\n########################################\nspring:\n  profiles: local\n  cloud:\n    config:\n      uri: http://localhost:8889\n---\n```\n\nspring-cloud 에서 zuul route 설정들을 받아온다. 만약 spring-cloud 가 죽었을 경우를 대비해야 한다면 route 설정값들을 application.yml 에 해주면 된다.\n참고로 spring-cloud-config 기본 주소는 localhost:8888 이다. 즉 8888포트로 사용할 거라면 따로 설정하지 않아도 기본으로 이 주소로 접근을 시도한다. 원하는 경로로 사용할 경우에는 반드시 명시해주어야 한다.  \n\n필요에 따라 zuul 설정을 여기에서 해줘도 된다. 만약 cloud config 에서 값을 읽어들이지 못할 경우엔 여기에 있는 값을 사용하게 된다.\n\n`application.yml`  \n\n```yml\nspring:\n  # groovy template 는 사용하지 않는다.\n  groovy:\n    template:\n      cache: false\n \n \n# 필요한 actuator end point 만 열어둔다.\nmanagement:\n  endpoints:\n    web:\n      exposure:\n        # 원하는 endpoint 를 추가할 수 있다.\n        include: info, routes, filters, refresh\n \n \n---\n########################################\n###              local               ###\n########################################\nspring:\n  profiles: local\n \nserver:\n  port: 8087\n \n# 여기서 설정도 가능하다. 우선순위는 cloud config 가 더 높다.\n#zuul:\n#  routes:\n#    apiService:\n#      stripPrefix: false\n#      path: /api/**\n#      url: https://new-api-service.com\n---\n```\n\napplication 에 @EnableZuulProxy 만 달아주면 gateway는 설정이 모두 끝난다. \n\n`GatewayApplication.java`  \n\n```java\nimport org.springframework.boot.SpringApplication;\nimport org.springframework.boot.autoconfigure.SpringBootApplication;\nimport org.springframework.cloud.netflix.zuul.EnableZuulProxy;\n \n@EnableZuulProxy  // 이 annotation 만 추가하면 된다.\n@SpringBootApplication\npublic class GatewayApplication {\n \n    public static void main(String[] args) {\n        SpringApplication.run(GatewayApplication.class, args);\n    }\n}\n```\n\n### 2. spring-cloud-config-server 설정\nconfig-server 는 cloud-config 에 저장되어있는 설정들을 gateway 들이 가져갈 수 있도록 중간에서 설정값을 가져오는 역할을 한다.\n\n#### 빌드설정\n\n`build.gradle`  \n\n```gradle\nbuildscript {\n    ext {\n        springBootVersion = '2.0.6.RELEASE'\n    }\n    repositories {\n        mavenCentral()\n    }\n    dependencies {\n        classpath(\"org.springframework.boot:spring-boot-gradle-plugin:${springBootVersion}\")\n    }\n}\n \napply plugin: 'java'\napply plugin: 'eclipse'\napply plugin: 'org.springframework.boot'\napply plugin: 'io.spring.dependency-management'\n \ngroup = 'com.nevercaution'\nversion = '0.0.1-SNAPSHOT'\nsourceCompatibility = 1.8\n \next {\n    springCloudVersion = 'Finchley.SR1'\n}\n \ndependencies {\n    compile('org.springframework.cloud:spring-cloud-config-server')\n    testCompile('org.springframework.boot:spring-boot-starter-test')\n}\n \ndependencyManagement {\n    imports {\n        mavenBom \"org.springframework.cloud:spring-cloud-dependencies:${springCloudVersion}\"\n    }\n}\n```\n\n#### 프로젝트 설정\n\n`application.yml`  \n\n```yml\nserver:\n  port: 8889\n \nspring:\n  cloud:\n    config:\n      server:\n        git:\n          uri: https://github.com/user/cloud-config/config.git\n          username: username\n          password: password\n```\nconfig-server 역시 application 에 @EnableConfigServer 달아주면 끝.  \ngateway 에서 필요한 값들은 config.git 에서 받아온다.  \n\n`Application.java`   \n\n```java\n \nimport org.springframework.boot.SpringApplication;\nimport org.springframework.boot.autoconfigure.SpringBootApplication;\nimport org.springframework.cloud.config.server.EnableConfigServer;\n \n@EnableConfigServer  // 이 annotation 만 적어주면 끝.\n@SpringBootApplication\npublic class MimirApplication {\n \n    public static void main(String[] args) {\n        SpringApplication.run(MimirApplication.class, args);\n    }\n}\n```\n\n### 3. config 설정\ncloud-config 는 gateway 에서 사용할 zuul 에 관련된 설정들을 모아놓는 곳이다. \n\n`gateway.yml`\n\n```yml\n---\n########################################\n###              local               ###\n########################################\nspring:\n  profiles: local\n \n# zuul route 설정들. \nzuul:\n  routes:\n    apiService:\n      stripPrefix: false\n      path: /api/**\n      url: https://new-api-service.com\n \n# groovy filter 가 있는 경로를 적어준다.\ngateway:\n  zuul:\n    filters:\n      base-path: /path/to/filter/\n---\n```\n\n### 정리하자면\ngateway 에서는 zuul route 설정들을 이용해서 요청들을 받아서 처리해준다.\ngateway 에서 route 설정들을 받아오기 위해서 spring-cloud-server 에 spring-cloud-config 정보를 요청한다.\nspring-cloud-server 에서는 spring-cloud-config 에 있는 정보를 조회해서 gateway 에 내려준다.\n\n### zuul filter 사용\n특정 상황에 대처하기 위해 필터를 걸 수 있다. java 로 추가할 수도 있지만 내용이 변경시 서비스가 재기동되어야 하기 때문에 groovy 로 필터를 사용한다.\ngateway 에서는 지정된 경로에 groovy filter 들을 로드 시킨다.\ngateway 에서 gateway.zuul.filters.base-path 이 값은 spring-cloud-config 에서 받아와서 로드한다.\nFileManager.init 에서 첫번째 파라미터는 이 경로에 몇초마다 파일들을 갱신할지 여부이다. 짧게 가져갈수록 부하가 있지만 대신 코드가 빠르게 적용된다.\n\n`ZuulFilterCommandLineRunner.java` \n\n```java\nimport com.netflix.zuul.FilterFileManager;\nimport com.netflix.zuul.FilterLoader;\nimport com.netflix.zuul.groovy.GroovyCompiler;\nimport com.netflix.zuul.groovy.GroovyFileFilter;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport org.springframework.beans.factory.annotation.Value;\nimport org.springframework.boot.CommandLineRunner;\nimport org.springframework.stereotype.Component;\n \n@Component\npublic class ZuulFilterCommandLineRunner implements CommandLineRunner {\n    private static Logger log = LoggerFactory.getLogger(ZuulFilterCommandLineRunner.class);\n     \n    // cloud config 에 정의된 경로에서 로드한다.\n    @Value(\"${gateway.zuul.filters.base-path}\")\n    private String filterBasePath;\n \n    @Override\n    public void run(String... args) {\n        FilterLoader.getInstance().setCompiler(new GroovyCompiler());\n        try {\n            log.debug(\"load try file : \" + filterBasePath);\n            FilterFileManager.setFilenameFilter(new GroovyFileFilter());\n            FilterFileManager.init(1, this.filterBasePath + \"pre\", this.filterBasePath + \"route\", this.filterBasePath + \"post\");\n        } catch (Exception e) {\n            log.error(\"load fail \" + filterBasePath, e);\n            throw new RuntimeException(e);\n        }\n    }\n}\n```\n\n뒤에 파일 경로는 성격에 따라 pre, route, post 폴더들로 구분이 된다. 자세한 정보는 [zuul filter](https://cloud.spring.io/spring-cloud-netflix/multi/multi__router_and_filter_zuul.html#_custom_zuul_filter_examples) 문서 에서 확인할 수 있다.\n\ngroovy filter 는 ZuulFilter 를 상속받아서 구현한다.\n\n`Route.groovy`\n\n```groovy\nimport com.netflix.zuul.ZuulFilter\nimport com.netflix.zuul.context.RequestContext\nimport com.netflix.zuul.exception.ZuulException\nimport org.slf4j.Logger\nimport org.slf4j.LoggerFactory\n \nimport static org.springframework.cloud.netflix.zuul.filters.support.FilterConstants.PROXY_KEY\nimport static org.springframework.cloud.netflix.zuul.filters.support.FilterConstants.SIMPLE_HOST_ROUTING_FILTER_ORDER\n \npublic class SimpleRoute extends ZuulFilter {\n \n    private static final Logger logger = LoggerFactory.getLogger(SimpleRoute.class);\n \n    @Override\n    String filterType() {\n        return \"route\"\n    }\n \n    @Override\n    int filterOrder() {\n        return SIMPLE_HOST_ROUTING_FILTER_ORDER - 1\n    }\n \n    @Override\n    boolean shouldFilter() {\n        return true\n    }\n \n    @Override\n    Object run() throws ZuulException {\n        def ctx = RequestContext.getCurrentContext()\n        def req = ctx.getRequest()\n \n        def host = ctx.getRouteHost()\n         \n        try {\n \n            RequestContext.currentContext.setRouteHost(new URL(\"https://another-new-api-service.com\"))\n             \n            logger.info(\"REQUEST:: \" + req.getScheme() + \" \" + req.getRemoteAddr() + \":\" + req.getRemotePort())\n \n            logger.info(\"REQUEST:: > \" + req.getMethod() + \" \" + req.getRequestURI() + \" \" + req.getProtocol())\n        } catch(Exception e) {\n            logger.error(\"errer handling\")\n            ctx.setRouteHost(host)\n        }\n \n \n        return null\n    }\n}\n```\n\n### zuul route 동적으로 변경하기\nzuul route 정보들은 동적으로 추가하거나 변경할 수 있다. spring-cloud-config 에서 설정값을 추가하거나 변경을 하고 gateway 에서 actuator 를 이용해서 갱신을 시켜주면 route 설정들이 동적으로 갱신된다.\n\nroute 설정을 편집하거나 추가하는 상황이다.\n\n#### 1. route 설정 편집과 추가 하기\n\n`gateway.yml` \n\n```yml\n########################################\n###              local               ###\n########################################\nspring:\n  profiles: local\n\nzuul:\n  routes:\n    apiService:\n      stripPrefix: false\n      path: /api/**\n      # 1. 기존 경로를 변경\n      url: https://some-api-service.com\n    # 2. 새로추가되는 서비스\n    searchService:\n      stripPrefix: false\n      path: /search/**\n      url: https://search-api-service.com\n \n# groovy filter 가 있는 경로를 적어줍니다.\ngateway:\n  zuul:\n    filters:\n      base-path: /path/to/filter/   \n```\n\n1 번 주석 부분은 기존에 api 라는 경로로 들어왔을 때 new-api-service.com 에서 some-api-service.com 으로 변경을 해주었다.\n2 번 주석 부분은 새로 추가되는 경로이다.\n이렇게 추가와 수정을 해주고 commit/push 를 해준다. push 를 한다고 해서 바로 변경점이 반영되지 않는다.\n\n#### 2. gateway 에서 refresh\nzuul 은 내부적으로 spring-boot-actuator 가 의존성으로 걸려있다. actuator 를 이용해서 spring-cloud-server 를 통해 spring-cloud-config 값들을 동적으로 가져올 수 있다.\n\n```bash\n$ curl -XPOST localhost:8080/actuator/refresh\n[\"config.client.version\",\"zuul.routes.apiService.url\",\"zuul.routes.searchService.path\",\"zuul.routes.searchService.stripPrefix\",\"zuul.routes.searchService.url\"]\n```\ngateway 에서 /refresh 를 호출하게 되면 처음에 받아왔던 정보에서 변경점들만 가져와서 다시 로딩한다.\n\n## 결론\n### route 동적 편집 가능\nzuul 을 이용해서 경로에 따라 원하는 도메인으로 routing 을 해줄 수 있다. 이 설정값들은 spring-cloud-config 에 저장되어 있는데 이 값들을 동적으로 편집할 수 있다. 이 동작은 spring-actuator 을 이용한다.\n\npost 요청으로 `/actuator/refresh` 를 gateway 에 호출하면 반영이 된다. \n\n### filter 동적 편집 가능\nfilter 역시 동적으로 편집하거나 추가할 수 있는데, 이는 zuul file manager 를 통해 특정 경로에 있는 groovy filter file 들을 로드해서 읽어서 사용한다. file manager 가 주기적으로 파일의 동기화를 하고 있으므로 파일을 수정하면 지정된 시간마다 동기화를 한다.\n\ngateway 를 도입하고나서 추가적으로 할 수 있는 것들이 생겼다. 화이트리스트를 만들어 특정 서버군으로 보낼 수도 있고 사용자별로 A/B 테스트를 해볼 수도 있을 것이다. 블랙리스트들도 걸러줄 수 있게 된다. (nginx 에서도 처리가 가능하지만 좀 더 동적으로 가능하고 형상관리도 가능하겠다.) 추가적으로 로그를 모으거나 springboot admin 등을 통해서 gateway 상태도 살펴볼 수있을듯 하다. 예제코드는 [여기](https://github.com/nevercaution/spring-cloud-zuul-example) 에서 확인할 수 있다.\n","slug":"api-gateway-with-zuul","published":1,"updated":"2018-12-24T04:50:49.958Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjq98sooy00018ghhbaqhoqz1","content":"<p>api gatway 를 도입했다. 레거시 프로젝트를 정리하면서 msa 구조로 가게 되었고 필요에 따라 서비스들이 나뉘고 있어서 이를 한곳에서 관리해줄 필요가 있었다. 구조를 설계하면서 어느 레벨까지를 gateway 에서 처리할지에 대해 여러 고민이 있었고 너무나 크지 않은 선에서 일차적으로 도입을 하게 되었다.<br>\ngateway 를 구성하기 위해 아래의 3개의 프로젝트를 설정한다.</p>\n<ol>\n<li>라우팅을 해줄 gateway (zuul gateway)</li>\n<li>gateway 와 zuul 설정을 연결해줄 중간자 (spring cloud config)</li>\n<li>zuul 설정을 저장할 저장소 (git)</li>\n</ol>\n<h3><span id=\"1-gateway-구성\">1. gateway 구성</span></h3>\n<p>springboot, gradle 로 구성을 했고 버전은 2를 사용한다. spring cloud zuul 도 있지만 버전2에서는 아직 추가되지 않아 netflix zuul 을 사용하기로 한다.</p>\n<h4><span id=\"빌드-설정\">빌드 설정</span></h4>\n<p><code>build.gradle</code></p>\n<figure class=\"highlight gradle\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">buildscript</span> &#123;</span><br><span class=\"line\">    ext &#123;</span><br><span class=\"line\">        springBootVersion = <span class=\"string\">'2.0.6.RELEASE'</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">repositories</span> &#123;</span><br><span class=\"line\">        mavenCentral()</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">dependencies</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">classpath</span>(<span class=\"string\">\"org.springframework.boot:spring-boot-gradle-plugin:$&#123;springBootVersion&#125;\"</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">apply plugin: <span class=\"string\">'java'</span></span><br><span class=\"line\">apply plugin: <span class=\"string\">'eclipse'</span></span><br><span class=\"line\">apply plugin: <span class=\"string\">'groovy'</span></span><br><span class=\"line\">apply plugin: <span class=\"string\">'org.springframework.boot'</span></span><br><span class=\"line\">apply plugin: <span class=\"string\">'io.spring.dependency-management'</span></span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"keyword\">group</span> = <span class=\"string\">'com.nevercaution'</span></span><br><span class=\"line\">version = <span class=\"string\">'0.0.1-SNAPSHOT'</span></span><br><span class=\"line\"><span class=\"keyword\">sourceCompatibility</span> = <span class=\"number\">1.8</span></span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"keyword\">dependencies</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">compile</span>(<span class=\"string\">'org.springframework.cloud:spring-cloud-starter-netflix-zuul'</span>) </span><br><span class=\"line\">    <span class=\"keyword\">compile</span>(<span class=\"string\">'org.springframework.cloud:spring-cloud-starter-config'</span>)</span><br><span class=\"line\">    <span class=\"keyword\">compile</span>(<span class=\"string\">'org.codehaus.groovy:groovy-all'</span>)</span><br><span class=\"line\">    <span class=\"keyword\">compile</span>(<span class=\"string\">'com.googlecode.json-simple:json-simple'</span>)</span><br><span class=\"line\"> </span><br><span class=\"line\">    testCompile(<span class=\"string\">'org.springframework.boot:spring-boot-starter-test'</span>)</span><br><span class=\"line\"> </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">dependencyManagement &#123;</span><br><span class=\"line\">    imports &#123;</span><br><span class=\"line\">        mavenBom <span class=\"string\">\"org.springframework.cloud:spring-cloud-dependencies:Finchley.SR1\"</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4><span id=\"프로젝트-설정\">프로젝트 설정</span></h4>\n<figure class=\"highlight stylus\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">spring-cloud 를 사용할 때엔 application<span class=\"selector-class\">.yml</span> 보다 bootstrap<span class=\"selector-class\">.yml</span> 을 먼저 읽어 들인다.  </span><br><span class=\"line\">먼저 읽은 값을 기반으로 application<span class=\"selector-class\">.yml</span> 에 설정된 값들을 함께 사용하기 위함이다.</span><br></pre></td></tr></table></figure>\n<p><a href=\"http://application.name\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">application.name</a> 과 spring.profiles.active 두 값으로 cloud config 에 정보를 요청한다. 이 값을 적지 않을 경우엔 값을 가져오지 못한다. 또한 profiles.active 를 명시해주지 않으면 기본적으로 default profile 로 로드를 시도한다.</p>\n<p><code>bootstrap.yml</code></p>\n<figure class=\"highlight yml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">spring:</span></span><br><span class=\"line\"><span class=\"attr\">  profiles:</span></span><br><span class=\"line\"><span class=\"attr\">    active:</span> <span class=\"string\">local</span></span><br><span class=\"line\">  <span class=\"comment\"># 이 이름으로 spring cloud config server 에서 정보를 가져온다.</span></span><br><span class=\"line\"><span class=\"attr\">  application:</span></span><br><span class=\"line\"><span class=\"attr\">    name:</span> <span class=\"string\">gateway</span></span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"meta\">---</span></span><br><span class=\"line\"><span class=\"comment\">########################################</span></span><br><span class=\"line\"><span class=\"comment\">###              local               ###</span></span><br><span class=\"line\"><span class=\"comment\">########################################</span></span><br><span class=\"line\"><span class=\"attr\">spring:</span></span><br><span class=\"line\"><span class=\"attr\">  profiles:</span> <span class=\"string\">local</span></span><br><span class=\"line\"><span class=\"attr\">  cloud:</span></span><br><span class=\"line\"><span class=\"attr\">    config:</span></span><br><span class=\"line\"><span class=\"attr\">      uri:</span> <span class=\"attr\">http://localhost:8889</span></span><br><span class=\"line\"><span class=\"meta\">---</span></span><br></pre></td></tr></table></figure>\n<p>spring-cloud 에서 zuul route 설정들을 받아온다. 만약 spring-cloud 가 죽었을 경우를 대비해야 한다면 route 설정값들을 application.yml 에 해주면 된다.<br>\n참고로 spring-cloud-config 기본 주소는 localhost:8888 이다. 즉 8888포트로 사용할 거라면 따로 설정하지 않아도 기본으로 이 주소로 접근을 시도한다. 원하는 경로로 사용할 경우에는 반드시 명시해주어야 한다.</p>\n<p>필요에 따라 zuul 설정을 여기에서 해줘도 된다. 만약 cloud config 에서 값을 읽어들이지 못할 경우엔 여기에 있는 값을 사용하게 된다.</p>\n<p><code>application.yml</code></p>\n<figure class=\"highlight yml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">spring:</span></span><br><span class=\"line\">  <span class=\"comment\"># groovy template 는 사용하지 않는다.</span></span><br><span class=\"line\"><span class=\"attr\">  groovy:</span></span><br><span class=\"line\"><span class=\"attr\">    template:</span></span><br><span class=\"line\"><span class=\"attr\">      cache:</span> <span class=\"literal\">false</span></span><br><span class=\"line\"> </span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"comment\"># 필요한 actuator end point 만 열어둔다.</span></span><br><span class=\"line\"><span class=\"attr\">management:</span></span><br><span class=\"line\"><span class=\"attr\">  endpoints:</span></span><br><span class=\"line\"><span class=\"attr\">    web:</span></span><br><span class=\"line\"><span class=\"attr\">      exposure:</span></span><br><span class=\"line\">        <span class=\"comment\"># 원하는 endpoint 를 추가할 수 있다.</span></span><br><span class=\"line\"><span class=\"attr\">        include:</span> <span class=\"string\">info,</span> <span class=\"string\">routes,</span> <span class=\"string\">filters,</span> <span class=\"string\">refresh</span></span><br><span class=\"line\"> </span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"meta\">---</span></span><br><span class=\"line\"><span class=\"comment\">########################################</span></span><br><span class=\"line\"><span class=\"comment\">###              local               ###</span></span><br><span class=\"line\"><span class=\"comment\">########################################</span></span><br><span class=\"line\"><span class=\"attr\">spring:</span></span><br><span class=\"line\"><span class=\"attr\">  profiles:</span> <span class=\"string\">local</span></span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"attr\">server:</span></span><br><span class=\"line\"><span class=\"attr\">  port:</span> <span class=\"number\">8087</span></span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"comment\"># 여기서 설정도 가능하다. 우선순위는 cloud config 가 더 높다.</span></span><br><span class=\"line\"><span class=\"comment\">#zuul:</span></span><br><span class=\"line\"><span class=\"comment\">#  routes:</span></span><br><span class=\"line\"><span class=\"comment\">#    apiService:</span></span><br><span class=\"line\"><span class=\"comment\">#      stripPrefix: false</span></span><br><span class=\"line\"><span class=\"comment\">#      path: /api/**</span></span><br><span class=\"line\"><span class=\"comment\">#      url: https://new-api-service.com</span></span><br><span class=\"line\"><span class=\"meta\">---</span></span><br></pre></td></tr></table></figure>\n<p>application 에 @EnableZuulProxy 만 달아주면 gateway는 설정이 모두 끝난다.</p>\n<p><code>GatewayApplication.java</code></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.boot.SpringApplication;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.cloud.netflix.zuul.EnableZuulProxy;</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"meta\">@EnableZuulProxy</span>  <span class=\"comment\">// 이 annotation 만 추가하면 된다.</span></span><br><span class=\"line\"><span class=\"meta\">@SpringBootApplication</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">GatewayApplication</span> </span>&#123;</span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        SpringApplication.run(GatewayApplication.class, args);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3><span id=\"2-spring-cloud-config-server-설정\">2. spring-cloud-config-server 설정</span></h3>\n<p>config-server 는 cloud-config 에 저장되어있는 설정들을 gateway 들이 가져갈 수 있도록 중간에서 설정값을 가져오는 역할을 한다.</p>\n<h4><span id=\"빌드설정\">빌드설정</span></h4>\n<p><code>build.gradle</code></p>\n<figure class=\"highlight gradle\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">buildscript</span> &#123;</span><br><span class=\"line\">    ext &#123;</span><br><span class=\"line\">        springBootVersion = <span class=\"string\">'2.0.6.RELEASE'</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">repositories</span> &#123;</span><br><span class=\"line\">        mavenCentral()</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">dependencies</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">classpath</span>(<span class=\"string\">\"org.springframework.boot:spring-boot-gradle-plugin:$&#123;springBootVersion&#125;\"</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">apply plugin: <span class=\"string\">'java'</span></span><br><span class=\"line\">apply plugin: <span class=\"string\">'eclipse'</span></span><br><span class=\"line\">apply plugin: <span class=\"string\">'org.springframework.boot'</span></span><br><span class=\"line\">apply plugin: <span class=\"string\">'io.spring.dependency-management'</span></span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"keyword\">group</span> = <span class=\"string\">'com.nevercaution'</span></span><br><span class=\"line\">version = <span class=\"string\">'0.0.1-SNAPSHOT'</span></span><br><span class=\"line\"><span class=\"keyword\">sourceCompatibility</span> = <span class=\"number\">1.8</span></span><br><span class=\"line\"> </span><br><span class=\"line\">ext &#123;</span><br><span class=\"line\">    springCloudVersion = <span class=\"string\">'Finchley.SR1'</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"keyword\">dependencies</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">compile</span>(<span class=\"string\">'org.springframework.cloud:spring-cloud-config-server'</span>)</span><br><span class=\"line\">    testCompile(<span class=\"string\">'org.springframework.boot:spring-boot-starter-test'</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">dependencyManagement &#123;</span><br><span class=\"line\">    imports &#123;</span><br><span class=\"line\">        mavenBom <span class=\"string\">\"org.springframework.cloud:spring-cloud-dependencies:$&#123;springCloudVersion&#125;\"</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4><span id=\"프로젝트-설정\">프로젝트 설정</span></h4>\n<p><code>application.yml</code></p>\n<figure class=\"highlight yml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">server:</span></span><br><span class=\"line\"><span class=\"attr\">  port:</span> <span class=\"number\">8889</span></span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"attr\">spring:</span></span><br><span class=\"line\"><span class=\"attr\">  cloud:</span></span><br><span class=\"line\"><span class=\"attr\">    config:</span></span><br><span class=\"line\"><span class=\"attr\">      server:</span></span><br><span class=\"line\"><span class=\"attr\">        git:</span></span><br><span class=\"line\"><span class=\"attr\">          uri:</span> <span class=\"attr\">https://github.com/user/cloud-config/config.git</span></span><br><span class=\"line\"><span class=\"attr\">          username:</span> <span class=\"string\">username</span></span><br><span class=\"line\"><span class=\"attr\">          password:</span> <span class=\"string\">password</span></span><br></pre></td></tr></table></figure>\n<p>config-server 역시 application 에 @EnableConfigServer 달아주면 끝.<br>\ngateway 에서 필요한 값들은 config.git 에서 받아온다.</p>\n<p><code>Application.java</code></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> </span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.boot.SpringApplication;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.cloud.config.server.EnableConfigServer;</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"meta\">@EnableConfigServer</span>  <span class=\"comment\">// 이 annotation 만 적어주면 끝.</span></span><br><span class=\"line\"><span class=\"meta\">@SpringBootApplication</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MimirApplication</span> </span>&#123;</span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        SpringApplication.run(MimirApplication.class, args);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3><span id=\"3-config-설정\">3. config 설정</span></h3>\n<p>cloud-config 는 gateway 에서 사용할 zuul 에 관련된 설정들을 모아놓는 곳이다.</p>\n<p><code>gateway.yml</code></p>\n<figure class=\"highlight yml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">---</span></span><br><span class=\"line\"><span class=\"comment\">########################################</span></span><br><span class=\"line\"><span class=\"comment\">###              local               ###</span></span><br><span class=\"line\"><span class=\"comment\">########################################</span></span><br><span class=\"line\"><span class=\"attr\">spring:</span></span><br><span class=\"line\"><span class=\"attr\">  profiles:</span> <span class=\"string\">local</span></span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"comment\"># zuul route 설정들. </span></span><br><span class=\"line\"><span class=\"attr\">zuul:</span></span><br><span class=\"line\"><span class=\"attr\">  routes:</span></span><br><span class=\"line\"><span class=\"attr\">    apiService:</span></span><br><span class=\"line\"><span class=\"attr\">      stripPrefix:</span> <span class=\"literal\">false</span></span><br><span class=\"line\"><span class=\"attr\">      path:</span> <span class=\"string\">/api/**</span></span><br><span class=\"line\"><span class=\"attr\">      url:</span> <span class=\"attr\">https://new-api-service.com</span></span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"comment\"># groovy filter 가 있는 경로를 적어준다.</span></span><br><span class=\"line\"><span class=\"attr\">gateway:</span></span><br><span class=\"line\"><span class=\"attr\">  zuul:</span></span><br><span class=\"line\"><span class=\"attr\">    filters:</span></span><br><span class=\"line\"><span class=\"attr\">      base-path:</span> <span class=\"string\">/path/to/filter/</span></span><br><span class=\"line\"><span class=\"meta\">---</span></span><br></pre></td></tr></table></figure>\n<h3><span id=\"정리하자면\">정리하자면</span></h3>\n<p>gateway 에서는 zuul route 설정들을 이용해서 요청들을 받아서 처리해준다.<br>\ngateway 에서 route 설정들을 받아오기 위해서 spring-cloud-server 에 spring-cloud-config 정보를 요청한다.<br>\nspring-cloud-server 에서는 spring-cloud-config 에 있는 정보를 조회해서 gateway 에 내려준다.</p>\n<h3><span id=\"zuul-filter-사용\">zuul filter 사용</span></h3>\n<p>특정 상황에 대처하기 위해 필터를 걸 수 있다. java 로 추가할 수도 있지만 내용이 변경시 서비스가 재기동되어야 하기 때문에 groovy 로 필터를 사용한다.<br>\ngateway 에서는 지정된 경로에 groovy filter 들을 로드 시킨다.<br>\ngateway 에서 gateway.zuul.filters.base-path 이 값은 spring-cloud-config 에서 받아와서 로드한다.<br>\nFileManager.init 에서 첫번째 파라미터는 이 경로에 몇초마다 파일들을 갱신할지 여부이다. 짧게 가져갈수록 부하가 있지만 대신 코드가 빠르게 적용된다.</p>\n<p><code>ZuulFilterCommandLineRunner.java</code></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> com.netflix.zuul.FilterFileManager;</span><br><span class=\"line\"><span class=\"keyword\">import</span> com.netflix.zuul.FilterLoader;</span><br><span class=\"line\"><span class=\"keyword\">import</span> com.netflix.zuul.groovy.GroovyCompiler;</span><br><span class=\"line\"><span class=\"keyword\">import</span> com.netflix.zuul.groovy.GroovyFileFilter;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.slf4j.Logger;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.slf4j.LoggerFactory;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.beans.factory.annotation.Value;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.boot.CommandLineRunner;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.stereotype.Component;</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"meta\">@Component</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ZuulFilterCommandLineRunner</span> <span class=\"keyword\">implements</span> <span class=\"title\">CommandLineRunner</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> Logger log = LoggerFactory.getLogger(ZuulFilterCommandLineRunner.class);</span><br><span class=\"line\">     </span><br><span class=\"line\">    <span class=\"comment\">// cloud config 에 정의된 경로에서 로드한다.</span></span><br><span class=\"line\">    <span class=\"meta\">@Value</span>(<span class=\"string\">\"$&#123;gateway.zuul.filters.base-path&#125;\"</span>)</span><br><span class=\"line\">    <span class=\"keyword\">private</span> String filterBasePath;</span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">(String... args)</span> </span>&#123;</span><br><span class=\"line\">        FilterLoader.getInstance().setCompiler(<span class=\"keyword\">new</span> GroovyCompiler());</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            log.debug(<span class=\"string\">\"load try file : \"</span> + filterBasePath);</span><br><span class=\"line\">            FilterFileManager.setFilenameFilter(<span class=\"keyword\">new</span> GroovyFileFilter());</span><br><span class=\"line\">            FilterFileManager.init(<span class=\"number\">1</span>, <span class=\"keyword\">this</span>.filterBasePath + <span class=\"string\">\"pre\"</span>, <span class=\"keyword\">this</span>.filterBasePath + <span class=\"string\">\"route\"</span>, <span class=\"keyword\">this</span>.filterBasePath + <span class=\"string\">\"post\"</span>);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">            log.error(<span class=\"string\">\"load fail \"</span> + filterBasePath, e);</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> RuntimeException(e);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>뒤에 파일 경로는 성격에 따라 pre, route, post 폴더들로 구분이 된다. 자세한 정보는 <a href=\"https://cloud.spring.io/spring-cloud-netflix/multi/multi__router_and_filter_zuul.html#_custom_zuul_filter_examples\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">zuul filter</a> 문서 에서 확인할 수 있다.</p>\n<p>groovy filter 는 ZuulFilter 를 상속받아서 구현한다.</p>\n<p><code>Route.groovy</code></p>\n<figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> com.netflix.zuul.ZuulFilter</span><br><span class=\"line\"><span class=\"keyword\">import</span> com.netflix.zuul.context.RequestContext</span><br><span class=\"line\"><span class=\"keyword\">import</span> com.netflix.zuul.exception.ZuulException</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.slf4j.Logger</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.slf4j.LoggerFactory</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"keyword\">static</span> org.springframework.cloud.netflix.zuul.filters.support.FilterConstants.PROXY_KEY</span><br><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"keyword\">static</span> org.springframework.cloud.netflix.zuul.filters.support.FilterConstants.SIMPLE_HOST_ROUTING_FILTER_ORDER</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SimpleRoute</span> <span class=\"keyword\">extends</span> <span class=\"title\">ZuulFilter</span> &#123;</span></span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> Logger logger = LoggerFactory.getLogger(SimpleRoute.<span class=\"keyword\">class</span>);</span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    String filterType() &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">\"route\"</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> filterOrder() &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> SIMPLE_HOST_ROUTING_FILTER_ORDER - <span class=\"number\">1</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">boolean</span> shouldFilter() &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">true</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    Object run() <span class=\"keyword\">throws</span> ZuulException &#123;</span><br><span class=\"line\">        <span class=\"keyword\">def</span> ctx = RequestContext.getCurrentContext()</span><br><span class=\"line\">        <span class=\"keyword\">def</span> req = ctx.getRequest()</span><br><span class=\"line\"> </span><br><span class=\"line\">        <span class=\"keyword\">def</span> host = ctx.getRouteHost()</span><br><span class=\"line\">         </span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\"> </span><br><span class=\"line\">            RequestContext.currentContext.setRouteHost(<span class=\"keyword\">new</span> URL(<span class=\"string\">\"https://another-new-api-service.com\"</span>))</span><br><span class=\"line\">             </span><br><span class=\"line\">            logger.info(<span class=\"string\">\"REQUEST:: \"</span> + req.getScheme() + <span class=\"string\">\" \"</span> + req.getRemoteAddr() + <span class=\"string\">\":\"</span> + req.getRemotePort())</span><br><span class=\"line\"> </span><br><span class=\"line\">            logger.info(<span class=\"string\">\"REQUEST:: &gt; \"</span> + req.getMethod() + <span class=\"string\">\" \"</span> + req.getRequestURI() + <span class=\"string\">\" \"</span> + req.getProtocol())</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span>(Exception e) &#123;</span><br><span class=\"line\">            logger.error(<span class=\"string\">\"errer handling\"</span>)</span><br><span class=\"line\">            ctx.setRouteHost(host)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"> </span><br><span class=\"line\"> </span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">null</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3><span id=\"zuul-route-동적으로-변경하기\">zuul route 동적으로 변경하기</span></h3>\n<p>zuul route 정보들은 동적으로 추가하거나 변경할 수 있다. spring-cloud-config 에서 설정값을 추가하거나 변경을 하고 gateway 에서 actuator 를 이용해서 갱신을 시켜주면 route 설정들이 동적으로 갱신된다.</p>\n<p>route 설정을 편집하거나 추가하는 상황이다.</p>\n<h4><span id=\"1-route-설정-편집과-추가-하기\">1. route 설정 편집과 추가 하기</span></h4>\n<p><code>gateway.yml</code></p>\n<figure class=\"highlight yml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">########################################</span></span><br><span class=\"line\"><span class=\"comment\">###              local               ###</span></span><br><span class=\"line\"><span class=\"comment\">########################################</span></span><br><span class=\"line\"><span class=\"attr\">spring:</span></span><br><span class=\"line\"><span class=\"attr\">  profiles:</span> <span class=\"string\">local</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"attr\">zuul:</span></span><br><span class=\"line\"><span class=\"attr\">  routes:</span></span><br><span class=\"line\"><span class=\"attr\">    apiService:</span></span><br><span class=\"line\"><span class=\"attr\">      stripPrefix:</span> <span class=\"literal\">false</span></span><br><span class=\"line\"><span class=\"attr\">      path:</span> <span class=\"string\">/api/**</span></span><br><span class=\"line\">      <span class=\"comment\"># 1. 기존 경로를 변경</span></span><br><span class=\"line\"><span class=\"attr\">      url:</span> <span class=\"attr\">https://some-api-service.com</span></span><br><span class=\"line\">    <span class=\"comment\"># 2. 새로추가되는 서비스</span></span><br><span class=\"line\"><span class=\"attr\">    searchService:</span></span><br><span class=\"line\"><span class=\"attr\">      stripPrefix:</span> <span class=\"literal\">false</span></span><br><span class=\"line\"><span class=\"attr\">      path:</span> <span class=\"string\">/search/**</span></span><br><span class=\"line\"><span class=\"attr\">      url:</span> <span class=\"attr\">https://search-api-service.com</span></span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"comment\"># groovy filter 가 있는 경로를 적어줍니다.</span></span><br><span class=\"line\"><span class=\"attr\">gateway:</span></span><br><span class=\"line\"><span class=\"attr\">  zuul:</span></span><br><span class=\"line\"><span class=\"attr\">    filters:</span></span><br><span class=\"line\"><span class=\"attr\">      base-path:</span> <span class=\"string\">/path/to/filter/</span></span><br></pre></td></tr></table></figure>\n<p>1 번 주석 부분은 기존에 api 라는 경로로 들어왔을 때 <a href=\"http://new-api-service.com\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">new-api-service.com</a> 에서 <a href=\"http://some-api-service.com\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">some-api-service.com</a> 으로 변경을 해주었다.<br>\n2 번 주석 부분은 새로 추가되는 경로이다.<br>\n이렇게 추가와 수정을 해주고 commit/push 를 해준다. push 를 한다고 해서 바로 변경점이 반영되지 않는다.</p>\n<h4><span id=\"2-gateway-에서-refresh\">2. gateway 에서 refresh</span></h4>\n<p>zuul 은 내부적으로 spring-boot-actuator 가 의존성으로 걸려있다. actuator 를 이용해서 spring-cloud-server 를 통해 spring-cloud-config 값들을 동적으로 가져올 수 있다.</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ curl -XPOST localhost:8080/actuator/refresh</span><br><span class=\"line\">[<span class=\"string\">\"config.client.version\"</span>,<span class=\"string\">\"zuul.routes.apiService.url\"</span>,<span class=\"string\">\"zuul.routes.searchService.path\"</span>,<span class=\"string\">\"zuul.routes.searchService.stripPrefix\"</span>,<span class=\"string\">\"zuul.routes.searchService.url\"</span>]</span><br></pre></td></tr></table></figure>\n<p>gateway 에서 /refresh 를 호출하게 되면 처음에 받아왔던 정보에서 변경점들만 가져와서 다시 로딩한다.</p>\n<h2><span id=\"결론\">결론</span></h2>\n<h3><span id=\"route-동적-편집-가능\">route 동적 편집 가능</span></h3>\n<p>zuul 을 이용해서 경로에 따라 원하는 도메인으로 routing 을 해줄 수 있다. 이 설정값들은 spring-cloud-config 에 저장되어 있는데 이 값들을 동적으로 편집할 수 있다. 이 동작은 spring-actuator 을 이용한다.</p>\n<p>post 요청으로 <code>/actuator/refresh</code> 를 gateway 에 호출하면 반영이 된다.</p>\n<h3><span id=\"filter-동적-편집-가능\">filter 동적 편집 가능</span></h3>\n<p>filter 역시 동적으로 편집하거나 추가할 수 있는데, 이는 zuul file manager 를 통해 특정 경로에 있는 groovy filter file 들을 로드해서 읽어서 사용한다. file manager 가 주기적으로 파일의 동기화를 하고 있으므로 파일을 수정하면 지정된 시간마다 동기화를 한다.</p>\n<p>gateway 를 도입하고나서 추가적으로 할 수 있는 것들이 생겼다. 화이트리스트를 만들어 특정 서버군으로 보낼 수도 있고 사용자별로 A/B 테스트를 해볼 수도 있을 것이다. 블랙리스트들도 걸러줄 수 있게 된다. (nginx 에서도 처리가 가능하지만 좀 더 동적으로 가능하고 형상관리도 가능하겠다.) 추가적으로 로그를 모으거나 springboot admin 등을 통해서 gateway 상태도 살펴볼 수있을듯 하다. 예제코드는 <a href=\"https://github.com/nevercaution/spring-cloud-zuul-example\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">여기</a> 에서 확인할 수 있다.</p>\n","site":{"data":{}},"excerpt":"","more":"<p>api gatway 를 도입했다. 레거시 프로젝트를 정리하면서 msa 구조로 가게 되었고 필요에 따라 서비스들이 나뉘고 있어서 이를 한곳에서 관리해줄 필요가 있었다. 구조를 설계하면서 어느 레벨까지를 gateway 에서 처리할지에 대해 여러 고민이 있었고 너무나 크지 않은 선에서 일차적으로 도입을 하게 되었다.<br>\ngateway 를 구성하기 위해 아래의 3개의 프로젝트를 설정한다.</p>\n<ol>\n<li>라우팅을 해줄 gateway (zuul gateway)</li>\n<li>gateway 와 zuul 설정을 연결해줄 중간자 (spring cloud config)</li>\n<li>zuul 설정을 저장할 저장소 (git)</li>\n</ol>\n<h3>1. gateway 구성</h3>\n<p>springboot, gradle 로 구성을 했고 버전은 2를 사용한다. spring cloud zuul 도 있지만 버전2에서는 아직 추가되지 않아 netflix zuul 을 사용하기로 한다.</p>\n<h4>빌드 설정</h4>\n<p><code>build.gradle</code></p>\n<figure class=\"highlight gradle\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">buildscript</span> &#123;</span><br><span class=\"line\">    ext &#123;</span><br><span class=\"line\">        springBootVersion = <span class=\"string\">'2.0.6.RELEASE'</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">repositories</span> &#123;</span><br><span class=\"line\">        mavenCentral()</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">dependencies</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">classpath</span>(<span class=\"string\">\"org.springframework.boot:spring-boot-gradle-plugin:$&#123;springBootVersion&#125;\"</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">apply plugin: <span class=\"string\">'java'</span></span><br><span class=\"line\">apply plugin: <span class=\"string\">'eclipse'</span></span><br><span class=\"line\">apply plugin: <span class=\"string\">'groovy'</span></span><br><span class=\"line\">apply plugin: <span class=\"string\">'org.springframework.boot'</span></span><br><span class=\"line\">apply plugin: <span class=\"string\">'io.spring.dependency-management'</span></span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"keyword\">group</span> = <span class=\"string\">'com.nevercaution'</span></span><br><span class=\"line\">version = <span class=\"string\">'0.0.1-SNAPSHOT'</span></span><br><span class=\"line\"><span class=\"keyword\">sourceCompatibility</span> = <span class=\"number\">1.8</span></span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"keyword\">dependencies</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">compile</span>(<span class=\"string\">'org.springframework.cloud:spring-cloud-starter-netflix-zuul'</span>) </span><br><span class=\"line\">    <span class=\"keyword\">compile</span>(<span class=\"string\">'org.springframework.cloud:spring-cloud-starter-config'</span>)</span><br><span class=\"line\">    <span class=\"keyword\">compile</span>(<span class=\"string\">'org.codehaus.groovy:groovy-all'</span>)</span><br><span class=\"line\">    <span class=\"keyword\">compile</span>(<span class=\"string\">'com.googlecode.json-simple:json-simple'</span>)</span><br><span class=\"line\"> </span><br><span class=\"line\">    testCompile(<span class=\"string\">'org.springframework.boot:spring-boot-starter-test'</span>)</span><br><span class=\"line\"> </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">dependencyManagement &#123;</span><br><span class=\"line\">    imports &#123;</span><br><span class=\"line\">        mavenBom <span class=\"string\">\"org.springframework.cloud:spring-cloud-dependencies:Finchley.SR1\"</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4>프로젝트 설정</h4>\n<figure class=\"highlight stylus\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">spring-cloud 를 사용할 때엔 application<span class=\"selector-class\">.yml</span> 보다 bootstrap<span class=\"selector-class\">.yml</span> 을 먼저 읽어 들인다.  </span><br><span class=\"line\">먼저 읽은 값을 기반으로 application<span class=\"selector-class\">.yml</span> 에 설정된 값들을 함께 사용하기 위함이다.</span><br></pre></td></tr></table></figure>\n<p><a href=\"http://application.name\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">application.name</a> 과 spring.profiles.active 두 값으로 cloud config 에 정보를 요청한다. 이 값을 적지 않을 경우엔 값을 가져오지 못한다. 또한 profiles.active 를 명시해주지 않으면 기본적으로 default profile 로 로드를 시도한다.</p>\n<p><code>bootstrap.yml</code></p>\n<figure class=\"highlight yml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">spring:</span></span><br><span class=\"line\"><span class=\"attr\">  profiles:</span></span><br><span class=\"line\"><span class=\"attr\">    active:</span> <span class=\"string\">local</span></span><br><span class=\"line\">  <span class=\"comment\"># 이 이름으로 spring cloud config server 에서 정보를 가져온다.</span></span><br><span class=\"line\"><span class=\"attr\">  application:</span></span><br><span class=\"line\"><span class=\"attr\">    name:</span> <span class=\"string\">gateway</span></span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"meta\">---</span></span><br><span class=\"line\"><span class=\"comment\">########################################</span></span><br><span class=\"line\"><span class=\"comment\">###              local               ###</span></span><br><span class=\"line\"><span class=\"comment\">########################################</span></span><br><span class=\"line\"><span class=\"attr\">spring:</span></span><br><span class=\"line\"><span class=\"attr\">  profiles:</span> <span class=\"string\">local</span></span><br><span class=\"line\"><span class=\"attr\">  cloud:</span></span><br><span class=\"line\"><span class=\"attr\">    config:</span></span><br><span class=\"line\"><span class=\"attr\">      uri:</span> <span class=\"attr\">http://localhost:8889</span></span><br><span class=\"line\"><span class=\"meta\">---</span></span><br></pre></td></tr></table></figure>\n<p>spring-cloud 에서 zuul route 설정들을 받아온다. 만약 spring-cloud 가 죽었을 경우를 대비해야 한다면 route 설정값들을 application.yml 에 해주면 된다.<br>\n참고로 spring-cloud-config 기본 주소는 localhost:8888 이다. 즉 8888포트로 사용할 거라면 따로 설정하지 않아도 기본으로 이 주소로 접근을 시도한다. 원하는 경로로 사용할 경우에는 반드시 명시해주어야 한다.</p>\n<p>필요에 따라 zuul 설정을 여기에서 해줘도 된다. 만약 cloud config 에서 값을 읽어들이지 못할 경우엔 여기에 있는 값을 사용하게 된다.</p>\n<p><code>application.yml</code></p>\n<figure class=\"highlight yml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">spring:</span></span><br><span class=\"line\">  <span class=\"comment\"># groovy template 는 사용하지 않는다.</span></span><br><span class=\"line\"><span class=\"attr\">  groovy:</span></span><br><span class=\"line\"><span class=\"attr\">    template:</span></span><br><span class=\"line\"><span class=\"attr\">      cache:</span> <span class=\"literal\">false</span></span><br><span class=\"line\"> </span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"comment\"># 필요한 actuator end point 만 열어둔다.</span></span><br><span class=\"line\"><span class=\"attr\">management:</span></span><br><span class=\"line\"><span class=\"attr\">  endpoints:</span></span><br><span class=\"line\"><span class=\"attr\">    web:</span></span><br><span class=\"line\"><span class=\"attr\">      exposure:</span></span><br><span class=\"line\">        <span class=\"comment\"># 원하는 endpoint 를 추가할 수 있다.</span></span><br><span class=\"line\"><span class=\"attr\">        include:</span> <span class=\"string\">info,</span> <span class=\"string\">routes,</span> <span class=\"string\">filters,</span> <span class=\"string\">refresh</span></span><br><span class=\"line\"> </span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"meta\">---</span></span><br><span class=\"line\"><span class=\"comment\">########################################</span></span><br><span class=\"line\"><span class=\"comment\">###              local               ###</span></span><br><span class=\"line\"><span class=\"comment\">########################################</span></span><br><span class=\"line\"><span class=\"attr\">spring:</span></span><br><span class=\"line\"><span class=\"attr\">  profiles:</span> <span class=\"string\">local</span></span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"attr\">server:</span></span><br><span class=\"line\"><span class=\"attr\">  port:</span> <span class=\"number\">8087</span></span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"comment\"># 여기서 설정도 가능하다. 우선순위는 cloud config 가 더 높다.</span></span><br><span class=\"line\"><span class=\"comment\">#zuul:</span></span><br><span class=\"line\"><span class=\"comment\">#  routes:</span></span><br><span class=\"line\"><span class=\"comment\">#    apiService:</span></span><br><span class=\"line\"><span class=\"comment\">#      stripPrefix: false</span></span><br><span class=\"line\"><span class=\"comment\">#      path: /api/**</span></span><br><span class=\"line\"><span class=\"comment\">#      url: https://new-api-service.com</span></span><br><span class=\"line\"><span class=\"meta\">---</span></span><br></pre></td></tr></table></figure>\n<p>application 에 @EnableZuulProxy 만 달아주면 gateway는 설정이 모두 끝난다.</p>\n<p><code>GatewayApplication.java</code></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.boot.SpringApplication;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.cloud.netflix.zuul.EnableZuulProxy;</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"meta\">@EnableZuulProxy</span>  <span class=\"comment\">// 이 annotation 만 추가하면 된다.</span></span><br><span class=\"line\"><span class=\"meta\">@SpringBootApplication</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">GatewayApplication</span> </span>&#123;</span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        SpringApplication.run(GatewayApplication.class, args);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3>2. spring-cloud-config-server 설정</h3>\n<p>config-server 는 cloud-config 에 저장되어있는 설정들을 gateway 들이 가져갈 수 있도록 중간에서 설정값을 가져오는 역할을 한다.</p>\n<h4>빌드설정</h4>\n<p><code>build.gradle</code></p>\n<figure class=\"highlight gradle\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">buildscript</span> &#123;</span><br><span class=\"line\">    ext &#123;</span><br><span class=\"line\">        springBootVersion = <span class=\"string\">'2.0.6.RELEASE'</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">repositories</span> &#123;</span><br><span class=\"line\">        mavenCentral()</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">dependencies</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">classpath</span>(<span class=\"string\">\"org.springframework.boot:spring-boot-gradle-plugin:$&#123;springBootVersion&#125;\"</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">apply plugin: <span class=\"string\">'java'</span></span><br><span class=\"line\">apply plugin: <span class=\"string\">'eclipse'</span></span><br><span class=\"line\">apply plugin: <span class=\"string\">'org.springframework.boot'</span></span><br><span class=\"line\">apply plugin: <span class=\"string\">'io.spring.dependency-management'</span></span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"keyword\">group</span> = <span class=\"string\">'com.nevercaution'</span></span><br><span class=\"line\">version = <span class=\"string\">'0.0.1-SNAPSHOT'</span></span><br><span class=\"line\"><span class=\"keyword\">sourceCompatibility</span> = <span class=\"number\">1.8</span></span><br><span class=\"line\"> </span><br><span class=\"line\">ext &#123;</span><br><span class=\"line\">    springCloudVersion = <span class=\"string\">'Finchley.SR1'</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"keyword\">dependencies</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">compile</span>(<span class=\"string\">'org.springframework.cloud:spring-cloud-config-server'</span>)</span><br><span class=\"line\">    testCompile(<span class=\"string\">'org.springframework.boot:spring-boot-starter-test'</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">dependencyManagement &#123;</span><br><span class=\"line\">    imports &#123;</span><br><span class=\"line\">        mavenBom <span class=\"string\">\"org.springframework.cloud:spring-cloud-dependencies:$&#123;springCloudVersion&#125;\"</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4>프로젝트 설정</h4>\n<p><code>application.yml</code></p>\n<figure class=\"highlight yml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">server:</span></span><br><span class=\"line\"><span class=\"attr\">  port:</span> <span class=\"number\">8889</span></span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"attr\">spring:</span></span><br><span class=\"line\"><span class=\"attr\">  cloud:</span></span><br><span class=\"line\"><span class=\"attr\">    config:</span></span><br><span class=\"line\"><span class=\"attr\">      server:</span></span><br><span class=\"line\"><span class=\"attr\">        git:</span></span><br><span class=\"line\"><span class=\"attr\">          uri:</span> <span class=\"attr\">https://github.com/user/cloud-config/config.git</span></span><br><span class=\"line\"><span class=\"attr\">          username:</span> <span class=\"string\">username</span></span><br><span class=\"line\"><span class=\"attr\">          password:</span> <span class=\"string\">password</span></span><br></pre></td></tr></table></figure>\n<p>config-server 역시 application 에 @EnableConfigServer 달아주면 끝.<br>\ngateway 에서 필요한 값들은 config.git 에서 받아온다.</p>\n<p><code>Application.java</code></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> </span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.boot.SpringApplication;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.cloud.config.server.EnableConfigServer;</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"meta\">@EnableConfigServer</span>  <span class=\"comment\">// 이 annotation 만 적어주면 끝.</span></span><br><span class=\"line\"><span class=\"meta\">@SpringBootApplication</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MimirApplication</span> </span>&#123;</span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        SpringApplication.run(MimirApplication.class, args);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3>3. config 설정</h3>\n<p>cloud-config 는 gateway 에서 사용할 zuul 에 관련된 설정들을 모아놓는 곳이다.</p>\n<p><code>gateway.yml</code></p>\n<figure class=\"highlight yml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">---</span></span><br><span class=\"line\"><span class=\"comment\">########################################</span></span><br><span class=\"line\"><span class=\"comment\">###              local               ###</span></span><br><span class=\"line\"><span class=\"comment\">########################################</span></span><br><span class=\"line\"><span class=\"attr\">spring:</span></span><br><span class=\"line\"><span class=\"attr\">  profiles:</span> <span class=\"string\">local</span></span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"comment\"># zuul route 설정들. </span></span><br><span class=\"line\"><span class=\"attr\">zuul:</span></span><br><span class=\"line\"><span class=\"attr\">  routes:</span></span><br><span class=\"line\"><span class=\"attr\">    apiService:</span></span><br><span class=\"line\"><span class=\"attr\">      stripPrefix:</span> <span class=\"literal\">false</span></span><br><span class=\"line\"><span class=\"attr\">      path:</span> <span class=\"string\">/api/**</span></span><br><span class=\"line\"><span class=\"attr\">      url:</span> <span class=\"attr\">https://new-api-service.com</span></span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"comment\"># groovy filter 가 있는 경로를 적어준다.</span></span><br><span class=\"line\"><span class=\"attr\">gateway:</span></span><br><span class=\"line\"><span class=\"attr\">  zuul:</span></span><br><span class=\"line\"><span class=\"attr\">    filters:</span></span><br><span class=\"line\"><span class=\"attr\">      base-path:</span> <span class=\"string\">/path/to/filter/</span></span><br><span class=\"line\"><span class=\"meta\">---</span></span><br></pre></td></tr></table></figure>\n<h3>정리하자면</h3>\n<p>gateway 에서는 zuul route 설정들을 이용해서 요청들을 받아서 처리해준다.<br>\ngateway 에서 route 설정들을 받아오기 위해서 spring-cloud-server 에 spring-cloud-config 정보를 요청한다.<br>\nspring-cloud-server 에서는 spring-cloud-config 에 있는 정보를 조회해서 gateway 에 내려준다.</p>\n<h3>zuul filter 사용</h3>\n<p>특정 상황에 대처하기 위해 필터를 걸 수 있다. java 로 추가할 수도 있지만 내용이 변경시 서비스가 재기동되어야 하기 때문에 groovy 로 필터를 사용한다.<br>\ngateway 에서는 지정된 경로에 groovy filter 들을 로드 시킨다.<br>\ngateway 에서 gateway.zuul.filters.base-path 이 값은 spring-cloud-config 에서 받아와서 로드한다.<br>\nFileManager.init 에서 첫번째 파라미터는 이 경로에 몇초마다 파일들을 갱신할지 여부이다. 짧게 가져갈수록 부하가 있지만 대신 코드가 빠르게 적용된다.</p>\n<p><code>ZuulFilterCommandLineRunner.java</code></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> com.netflix.zuul.FilterFileManager;</span><br><span class=\"line\"><span class=\"keyword\">import</span> com.netflix.zuul.FilterLoader;</span><br><span class=\"line\"><span class=\"keyword\">import</span> com.netflix.zuul.groovy.GroovyCompiler;</span><br><span class=\"line\"><span class=\"keyword\">import</span> com.netflix.zuul.groovy.GroovyFileFilter;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.slf4j.Logger;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.slf4j.LoggerFactory;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.beans.factory.annotation.Value;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.boot.CommandLineRunner;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.stereotype.Component;</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"meta\">@Component</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ZuulFilterCommandLineRunner</span> <span class=\"keyword\">implements</span> <span class=\"title\">CommandLineRunner</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> Logger log = LoggerFactory.getLogger(ZuulFilterCommandLineRunner.class);</span><br><span class=\"line\">     </span><br><span class=\"line\">    <span class=\"comment\">// cloud config 에 정의된 경로에서 로드한다.</span></span><br><span class=\"line\">    <span class=\"meta\">@Value</span>(<span class=\"string\">\"$&#123;gateway.zuul.filters.base-path&#125;\"</span>)</span><br><span class=\"line\">    <span class=\"keyword\">private</span> String filterBasePath;</span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">(String... args)</span> </span>&#123;</span><br><span class=\"line\">        FilterLoader.getInstance().setCompiler(<span class=\"keyword\">new</span> GroovyCompiler());</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            log.debug(<span class=\"string\">\"load try file : \"</span> + filterBasePath);</span><br><span class=\"line\">            FilterFileManager.setFilenameFilter(<span class=\"keyword\">new</span> GroovyFileFilter());</span><br><span class=\"line\">            FilterFileManager.init(<span class=\"number\">1</span>, <span class=\"keyword\">this</span>.filterBasePath + <span class=\"string\">\"pre\"</span>, <span class=\"keyword\">this</span>.filterBasePath + <span class=\"string\">\"route\"</span>, <span class=\"keyword\">this</span>.filterBasePath + <span class=\"string\">\"post\"</span>);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">            log.error(<span class=\"string\">\"load fail \"</span> + filterBasePath, e);</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> RuntimeException(e);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>뒤에 파일 경로는 성격에 따라 pre, route, post 폴더들로 구분이 된다. 자세한 정보는 <a href=\"https://cloud.spring.io/spring-cloud-netflix/multi/multi__router_and_filter_zuul.html#_custom_zuul_filter_examples\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">zuul filter</a> 문서 에서 확인할 수 있다.</p>\n<p>groovy filter 는 ZuulFilter 를 상속받아서 구현한다.</p>\n<p><code>Route.groovy</code></p>\n<figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> com.netflix.zuul.ZuulFilter</span><br><span class=\"line\"><span class=\"keyword\">import</span> com.netflix.zuul.context.RequestContext</span><br><span class=\"line\"><span class=\"keyword\">import</span> com.netflix.zuul.exception.ZuulException</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.slf4j.Logger</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.slf4j.LoggerFactory</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"keyword\">static</span> org.springframework.cloud.netflix.zuul.filters.support.FilterConstants.PROXY_KEY</span><br><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"keyword\">static</span> org.springframework.cloud.netflix.zuul.filters.support.FilterConstants.SIMPLE_HOST_ROUTING_FILTER_ORDER</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SimpleRoute</span> <span class=\"keyword\">extends</span> <span class=\"title\">ZuulFilter</span> &#123;</span></span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> Logger logger = LoggerFactory.getLogger(SimpleRoute.<span class=\"keyword\">class</span>);</span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    String filterType() &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">\"route\"</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> filterOrder() &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> SIMPLE_HOST_ROUTING_FILTER_ORDER - <span class=\"number\">1</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">boolean</span> shouldFilter() &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">true</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    Object run() <span class=\"keyword\">throws</span> ZuulException &#123;</span><br><span class=\"line\">        <span class=\"keyword\">def</span> ctx = RequestContext.getCurrentContext()</span><br><span class=\"line\">        <span class=\"keyword\">def</span> req = ctx.getRequest()</span><br><span class=\"line\"> </span><br><span class=\"line\">        <span class=\"keyword\">def</span> host = ctx.getRouteHost()</span><br><span class=\"line\">         </span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\"> </span><br><span class=\"line\">            RequestContext.currentContext.setRouteHost(<span class=\"keyword\">new</span> URL(<span class=\"string\">\"https://another-new-api-service.com\"</span>))</span><br><span class=\"line\">             </span><br><span class=\"line\">            logger.info(<span class=\"string\">\"REQUEST:: \"</span> + req.getScheme() + <span class=\"string\">\" \"</span> + req.getRemoteAddr() + <span class=\"string\">\":\"</span> + req.getRemotePort())</span><br><span class=\"line\"> </span><br><span class=\"line\">            logger.info(<span class=\"string\">\"REQUEST:: &gt; \"</span> + req.getMethod() + <span class=\"string\">\" \"</span> + req.getRequestURI() + <span class=\"string\">\" \"</span> + req.getProtocol())</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span>(Exception e) &#123;</span><br><span class=\"line\">            logger.error(<span class=\"string\">\"errer handling\"</span>)</span><br><span class=\"line\">            ctx.setRouteHost(host)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"> </span><br><span class=\"line\"> </span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">null</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3>zuul route 동적으로 변경하기</h3>\n<p>zuul route 정보들은 동적으로 추가하거나 변경할 수 있다. spring-cloud-config 에서 설정값을 추가하거나 변경을 하고 gateway 에서 actuator 를 이용해서 갱신을 시켜주면 route 설정들이 동적으로 갱신된다.</p>\n<p>route 설정을 편집하거나 추가하는 상황이다.</p>\n<h4>1. route 설정 편집과 추가 하기</h4>\n<p><code>gateway.yml</code></p>\n<figure class=\"highlight yml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">########################################</span></span><br><span class=\"line\"><span class=\"comment\">###              local               ###</span></span><br><span class=\"line\"><span class=\"comment\">########################################</span></span><br><span class=\"line\"><span class=\"attr\">spring:</span></span><br><span class=\"line\"><span class=\"attr\">  profiles:</span> <span class=\"string\">local</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"attr\">zuul:</span></span><br><span class=\"line\"><span class=\"attr\">  routes:</span></span><br><span class=\"line\"><span class=\"attr\">    apiService:</span></span><br><span class=\"line\"><span class=\"attr\">      stripPrefix:</span> <span class=\"literal\">false</span></span><br><span class=\"line\"><span class=\"attr\">      path:</span> <span class=\"string\">/api/**</span></span><br><span class=\"line\">      <span class=\"comment\"># 1. 기존 경로를 변경</span></span><br><span class=\"line\"><span class=\"attr\">      url:</span> <span class=\"attr\">https://some-api-service.com</span></span><br><span class=\"line\">    <span class=\"comment\"># 2. 새로추가되는 서비스</span></span><br><span class=\"line\"><span class=\"attr\">    searchService:</span></span><br><span class=\"line\"><span class=\"attr\">      stripPrefix:</span> <span class=\"literal\">false</span></span><br><span class=\"line\"><span class=\"attr\">      path:</span> <span class=\"string\">/search/**</span></span><br><span class=\"line\"><span class=\"attr\">      url:</span> <span class=\"attr\">https://search-api-service.com</span></span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"comment\"># groovy filter 가 있는 경로를 적어줍니다.</span></span><br><span class=\"line\"><span class=\"attr\">gateway:</span></span><br><span class=\"line\"><span class=\"attr\">  zuul:</span></span><br><span class=\"line\"><span class=\"attr\">    filters:</span></span><br><span class=\"line\"><span class=\"attr\">      base-path:</span> <span class=\"string\">/path/to/filter/</span></span><br></pre></td></tr></table></figure>\n<p>1 번 주석 부분은 기존에 api 라는 경로로 들어왔을 때 <a href=\"http://new-api-service.com\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">new-api-service.com</a> 에서 <a href=\"http://some-api-service.com\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">some-api-service.com</a> 으로 변경을 해주었다.<br>\n2 번 주석 부분은 새로 추가되는 경로이다.<br>\n이렇게 추가와 수정을 해주고 commit/push 를 해준다. push 를 한다고 해서 바로 변경점이 반영되지 않는다.</p>\n<h4>2. gateway 에서 refresh</h4>\n<p>zuul 은 내부적으로 spring-boot-actuator 가 의존성으로 걸려있다. actuator 를 이용해서 spring-cloud-server 를 통해 spring-cloud-config 값들을 동적으로 가져올 수 있다.</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ curl -XPOST localhost:8080/actuator/refresh</span><br><span class=\"line\">[<span class=\"string\">\"config.client.version\"</span>,<span class=\"string\">\"zuul.routes.apiService.url\"</span>,<span class=\"string\">\"zuul.routes.searchService.path\"</span>,<span class=\"string\">\"zuul.routes.searchService.stripPrefix\"</span>,<span class=\"string\">\"zuul.routes.searchService.url\"</span>]</span><br></pre></td></tr></table></figure>\n<p>gateway 에서 /refresh 를 호출하게 되면 처음에 받아왔던 정보에서 변경점들만 가져와서 다시 로딩한다.</p>\n<h2>결론</h2>\n<h3>route 동적 편집 가능</h3>\n<p>zuul 을 이용해서 경로에 따라 원하는 도메인으로 routing 을 해줄 수 있다. 이 설정값들은 spring-cloud-config 에 저장되어 있는데 이 값들을 동적으로 편집할 수 있다. 이 동작은 spring-actuator 을 이용한다.</p>\n<p>post 요청으로 <code>/actuator/refresh</code> 를 gateway 에 호출하면 반영이 된다.</p>\n<h3>filter 동적 편집 가능</h3>\n<p>filter 역시 동적으로 편집하거나 추가할 수 있는데, 이는 zuul file manager 를 통해 특정 경로에 있는 groovy filter file 들을 로드해서 읽어서 사용한다. file manager 가 주기적으로 파일의 동기화를 하고 있으므로 파일을 수정하면 지정된 시간마다 동기화를 한다.</p>\n<p>gateway 를 도입하고나서 추가적으로 할 수 있는 것들이 생겼다. 화이트리스트를 만들어 특정 서버군으로 보낼 수도 있고 사용자별로 A/B 테스트를 해볼 수도 있을 것이다. 블랙리스트들도 걸러줄 수 있게 된다. (nginx 에서도 처리가 가능하지만 좀 더 동적으로 가능하고 형상관리도 가능하겠다.) 추가적으로 로그를 모으거나 springboot admin 등을 통해서 gateway 상태도 살펴볼 수있을듯 하다. 예제코드는 <a href=\"https://github.com/nevercaution/spring-cloud-zuul-example\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">여기</a> 에서 확인할 수 있다.</p>\n"},{"title":"Django orm standalone feat(docker)","catalog":true,"date":"2017-06-23T12:26:55.000Z","subtitle":null,"header-img":"/img/header_img/bg.png","_content":"필요에 의해서 배치 작업을 만들어야 했다.  \n간단하게 python으로 만들까 했는데, 단순 cursor로 사용하지 않고 django orm 으로 만들어 보고 싶은 생각이 들었다.  \n이미 작업하고 있는 django project 가 있었고, 그 안에서 사용하는 모델들을 사용해서 스크립트들을 만들면 좋겠다 생각이 들었다.  \n이미 django 구조에 익숙한 사람이라면 편하게 사용할 수 있을거라 생각했고, 관리가 용이하다는 장점이 있다.  \n  \n  \n### 해야할 일은..\n- mysql, mongo에서 데이터를 주기적으로 가져온다.  \n- 데이터를 가공해서 다시 mysql이나 mongo로 데이터를 주기적으로 쌓아준다.  \n- 여러 서버의 상황에 맞게 대응을 해야한다.(real, sandbox, test등등)\n\n이미 사내에서 사용하고 있는 훌륭한 배치 스크립트 뭉치가 있다. 이 스크립트는 cursor를 통해서 mysql 데이터를 가져오고 넣는다.  \n물론 cursor로 쿼리를 작성해도 되지만 django-orm을 이용해서 이 작업을 조금 더 수월하게 할 수는 없을까? 하는 생각에 django template 를 사용하지 않고 orm 만 사용할 수 있는 프로젝트를 만들어보기로 했다.  \n\n### django-orm standalone으로 가자\n\n일단 간단한 django 프로젝트를 하나만든다.  \n\n```\n$ django-admin startproject django-orm\n```\n\n설정과 최소한의 파일들을 제외하고 모두 제거해버리자. 구조는 아래와 같다.  \n\n~~~\n.\n├── Dockerfile\n├── build.sh\n├── db\n│   ├── __init__.py\n│   └── models.py\n├── manage.py\n├── requirements.txt\n├── run.sh\n├── scripts\n│   ├── __init__.py\n│   └── test.py\n└── settings.py\n~~~\n\n1. requirements.txt : 스크립트를 수행할 떄 필요한 모듈등을 기술해준다.  \n2. manage.py : django-extension의 runscript 나 shell 기능을 사용할 수 있도록 한다.  \n3. settings.py : 여러 저장소의 접속 환경이나 환경변수들을 선언해준다.  \n\n위의 구조를 뼈대로 필요한 부분을 채워서 사용하기로 한다. requirements.txt를 살펴보자.  \n\n- requirements.txt  \n\n~~~\nDjango==1.11.2    \ndjango-extensions==1.7.9  \nmysqlclient==1.3.10  \npytz==2017.2  \nsix==1.10.0  \n~~~\n\n[django-extension](https://github.com/django-extensions/django-extensions) 을 사용해서 스크립트들을 돌리고, mysql 의 데이터를 사용하기 위해 둘다 설치해주었다. 각자 필요한 부분이 있다면 추가해주면 된다.  \n이번에는 설정파일을 보도록 하자.\n\n- settings.py\n\n~~~\nimport os\n\n# Build paths inside the project like this: os.path.join(BASE_DIR, ...)\nBASE_DIR = os.path.dirname(os.path.abspath(__file__))\n\nDATABASES = {\n    'default': {\n        'ENGINE': 'django.db.backends.mysql',\n        'NAME': 'test',\n        'USER': 'root',\n        'PASSWORD': '',\n        'HOST': '127.0.0.1',\n        'PORT': '3306'\n    },\n}\n\nINSTALLED_APPS = (\n    'db',\n    'django_extensions',\n)\n\n# SECURITY WARNING: Modify this secret key if using in production!\nSECRET_KEY = '{your_secret_key}'\n\nLANGUAGE_CODE = 'en-us'\n\nTIME_ZONE = 'Asia/Seoul'\n\nUSE_I18N = True\n\nUSE_L10N = True\n\nUSE_TZ = True\n~~~\n\n기본 설정파일에서 DATABASES 부분만 수정해 준 상태이고 model들이 KST로 시간을 붙어여 했기 때문에 타임존 설정을 서울로 바꾸어 주었다.  \n여기에서 로그에 대한 설정이나 다른 저장소에 대한 정보를 적어주면 된다.  \n\n구조를 잡았으니 추가해야할 패키지들을 설치해주도록 한다. 여기서부터는 익히 알고 있는 패턴이므로 간단하게 살펴보자.   \n\n```\n$ pip install -r requiremwnts.txt\n```\n\n모델은 현재 자신의 db에 있는 테이블을 정의해주고 orm으로 붙기만 하면 된다. 모델을 한번 보자.  \n\n- model.py  \n\n~~~\nfrom django.db import models\n\n# Create your models here.\n\n\nclass User(models.Model):\n    id = models.IntegerField(primary_key=True)\n    name = models.CharField(max_length=11)\n\n    class Meta:\n        managed = False\n        db_table = 'user'\n\n~~~\n\ndb 설정을 해주었고 필요한 패키지를 설치했고, 모델들을 정의해주었다면 한번 붙어보자.  \n\n### hello orm\n\npython shell 로 들어가서 모델을 통해 데이터를 가져오면 된다.  \n\n~~~\n$ python manage.py shell\n~~~\n\n~~~\n>>> from db.models import User\n>>> User.objects.all()\n<QuerySet [<User: User object>, <User: User object>, <User: User object>, <User: User object>, <User: User object>]>\n~~~\n\n모델을 통해 데이터를 가져올 수 있고, 작업해야할 부분은 스크립트를 만들어서 사용하도록 한다. 기본적인 스크립트를 하나 만들어보자.  \n\n- test.py\n\n~~~\nfrom db.models import User\n\n\ndef run(*script_args):\n\n\tuser_list = User.objects.all()\n\n\tfor user in user_list:\n\t\tprint('name : ', user.name)\n~~~\n\n간단하다. 스크립트를 만들었으니 수행해보자. runscript 는 위에서도 언급했지만 django-extension의 기능중 하나이다.  \n\n~~~\n$ python manage.py runscript test\nname :  teddy\nname :  canel\nname :  twght\n~~~\n\n이제 필요한 스크립트를 만들어서 crontab에 걸어두면 django orm 을 이용해서 스크립트를 사용할 수 있다.    \n여기까지 했으면 간단하게 끝날텐데, 이 배치 스크립트를 여러 환경에 배포하고 돌려야 하는 일이 남아있었다.  \n물론 서버가 많지 않아 git으로 땡기거나 손으로 직접 옮겨도 되지만, 칼을 뽑은 김에 docker image 로 만들어서 써보자. 어렵지 않다.  \n\nDocker iamge 로 만드는 작업은 완전 단순하다. 사용법도 전혀 어렵지 않다. 일단 Dockerfile을 보자.\n\n- Dockerfile\n\n~~~\nFROM python:3.5-onbuild\n~~~\n\n사족으로 [pythpn:3.5-onbuild](https://github.com/docker-library/python/blob/9a9021f2134d953165b31d98cacb95aa34076f90/3.5/onbuild/Dockerfile) 에서 하는 일은 아래와 같다. \n\n~~~\n#\n# NOTE: THIS DOCKERFILE IS GENERATED VIA \"update.sh\"\n#\n# PLEASE DO NOT EDIT IT DIRECTLY.\n#\n\nFROM python:3.5\n\nRUN mkdir -p /usr/src/app\nWORKDIR /usr/src/app\n\nONBUILD COPY requirements.txt /usr/src/app/\nONBUILD RUN pip install --no-cache-dir -r requirements.txt\n\nONBUILD COPY . /usr/src/app\n~~~\n\n이렇게만 써주고 build 하면 끝이다. \n\n~~~\n$ docker build --tag django-orm:0.1 .\n~~~\n\n이미지를 만들었다면 다음과 같이 생성이 된다.  \n\n~~~\n$ docker images\nREPOSITORY            TAG                 IMAGE ID            CREATED             SIZE\ndjango-orm            0.1                 c8a6c10c8233        About an hour ago   715 MB\n~~~\n\n이 이미지를 사용하기 위해서는 run 명령으로 사용하도록 하자.  \n\n~~~\ndocker run --name django-orm django-orm python manage.py runscript test\n~~~\n\n### docker로 사용할 때 신경써야할 부분이 있다면 \ncontainer 내부에서는 host에 바로 접근할 수가 없기 때문에 mysql localhost 를 바라봐야 한다면 localhost 로 명시해주면 안된다.  \n물론 회피 방법은 조금만 구글링해도 나오지만 원칙적으로는 접근을 할 수 없으므로 이 부분을 신경써서 작업해주어야 한다.  \n~~나는 mysql이 다른 서버에 동작하고 있었기 떄문에 별 문제는 없었다.~~\n\n\n### 결론\n이미 django project 를 구동해본 경험이 있다면 큰 어려움 없이 사용할 수 있을 것이다.   \n물론 해당 프로젝트에서 배치 스크립트를 작성할 수도 있지만, 성격이 맞지 않을 수 있기 때문에 굳이 억지로 넣을 필요는 없다.  \ncursor로 작업하는게 간단하고 편할 수도 있지만, 여러 패키지를 함께 써야하고 여러 db 설정을 바라봐야 한다면 django 의 골격을 그대로 사용하는 방법이 손쉬울 수 있겠다.   \n해당 예제는 [django-orm standalone](https://github.com/nevercaution/django-orm) 에서 확인할 수 있다.  ","source":"_posts/django-orm-standalone.md","raw":"---\ntitle: \"Django orm standalone feat(docker)\"\ncatalog: true\ndate: 2017-06-23 21:26:55\nsubtitle:\nheader-img: \"/img/header_img/bg.png\"\ntags:\n- python\n- django\n- orm\n- docker\n\n---\n필요에 의해서 배치 작업을 만들어야 했다.  \n간단하게 python으로 만들까 했는데, 단순 cursor로 사용하지 않고 django orm 으로 만들어 보고 싶은 생각이 들었다.  \n이미 작업하고 있는 django project 가 있었고, 그 안에서 사용하는 모델들을 사용해서 스크립트들을 만들면 좋겠다 생각이 들었다.  \n이미 django 구조에 익숙한 사람이라면 편하게 사용할 수 있을거라 생각했고, 관리가 용이하다는 장점이 있다.  \n  \n  \n### 해야할 일은..\n- mysql, mongo에서 데이터를 주기적으로 가져온다.  \n- 데이터를 가공해서 다시 mysql이나 mongo로 데이터를 주기적으로 쌓아준다.  \n- 여러 서버의 상황에 맞게 대응을 해야한다.(real, sandbox, test등등)\n\n이미 사내에서 사용하고 있는 훌륭한 배치 스크립트 뭉치가 있다. 이 스크립트는 cursor를 통해서 mysql 데이터를 가져오고 넣는다.  \n물론 cursor로 쿼리를 작성해도 되지만 django-orm을 이용해서 이 작업을 조금 더 수월하게 할 수는 없을까? 하는 생각에 django template 를 사용하지 않고 orm 만 사용할 수 있는 프로젝트를 만들어보기로 했다.  \n\n### django-orm standalone으로 가자\n\n일단 간단한 django 프로젝트를 하나만든다.  \n\n```\n$ django-admin startproject django-orm\n```\n\n설정과 최소한의 파일들을 제외하고 모두 제거해버리자. 구조는 아래와 같다.  \n\n~~~\n.\n├── Dockerfile\n├── build.sh\n├── db\n│   ├── __init__.py\n│   └── models.py\n├── manage.py\n├── requirements.txt\n├── run.sh\n├── scripts\n│   ├── __init__.py\n│   └── test.py\n└── settings.py\n~~~\n\n1. requirements.txt : 스크립트를 수행할 떄 필요한 모듈등을 기술해준다.  \n2. manage.py : django-extension의 runscript 나 shell 기능을 사용할 수 있도록 한다.  \n3. settings.py : 여러 저장소의 접속 환경이나 환경변수들을 선언해준다.  \n\n위의 구조를 뼈대로 필요한 부분을 채워서 사용하기로 한다. requirements.txt를 살펴보자.  \n\n- requirements.txt  \n\n~~~\nDjango==1.11.2    \ndjango-extensions==1.7.9  \nmysqlclient==1.3.10  \npytz==2017.2  \nsix==1.10.0  \n~~~\n\n[django-extension](https://github.com/django-extensions/django-extensions) 을 사용해서 스크립트들을 돌리고, mysql 의 데이터를 사용하기 위해 둘다 설치해주었다. 각자 필요한 부분이 있다면 추가해주면 된다.  \n이번에는 설정파일을 보도록 하자.\n\n- settings.py\n\n~~~\nimport os\n\n# Build paths inside the project like this: os.path.join(BASE_DIR, ...)\nBASE_DIR = os.path.dirname(os.path.abspath(__file__))\n\nDATABASES = {\n    'default': {\n        'ENGINE': 'django.db.backends.mysql',\n        'NAME': 'test',\n        'USER': 'root',\n        'PASSWORD': '',\n        'HOST': '127.0.0.1',\n        'PORT': '3306'\n    },\n}\n\nINSTALLED_APPS = (\n    'db',\n    'django_extensions',\n)\n\n# SECURITY WARNING: Modify this secret key if using in production!\nSECRET_KEY = '{your_secret_key}'\n\nLANGUAGE_CODE = 'en-us'\n\nTIME_ZONE = 'Asia/Seoul'\n\nUSE_I18N = True\n\nUSE_L10N = True\n\nUSE_TZ = True\n~~~\n\n기본 설정파일에서 DATABASES 부분만 수정해 준 상태이고 model들이 KST로 시간을 붙어여 했기 때문에 타임존 설정을 서울로 바꾸어 주었다.  \n여기에서 로그에 대한 설정이나 다른 저장소에 대한 정보를 적어주면 된다.  \n\n구조를 잡았으니 추가해야할 패키지들을 설치해주도록 한다. 여기서부터는 익히 알고 있는 패턴이므로 간단하게 살펴보자.   \n\n```\n$ pip install -r requiremwnts.txt\n```\n\n모델은 현재 자신의 db에 있는 테이블을 정의해주고 orm으로 붙기만 하면 된다. 모델을 한번 보자.  \n\n- model.py  \n\n~~~\nfrom django.db import models\n\n# Create your models here.\n\n\nclass User(models.Model):\n    id = models.IntegerField(primary_key=True)\n    name = models.CharField(max_length=11)\n\n    class Meta:\n        managed = False\n        db_table = 'user'\n\n~~~\n\ndb 설정을 해주었고 필요한 패키지를 설치했고, 모델들을 정의해주었다면 한번 붙어보자.  \n\n### hello orm\n\npython shell 로 들어가서 모델을 통해 데이터를 가져오면 된다.  \n\n~~~\n$ python manage.py shell\n~~~\n\n~~~\n>>> from db.models import User\n>>> User.objects.all()\n<QuerySet [<User: User object>, <User: User object>, <User: User object>, <User: User object>, <User: User object>]>\n~~~\n\n모델을 통해 데이터를 가져올 수 있고, 작업해야할 부분은 스크립트를 만들어서 사용하도록 한다. 기본적인 스크립트를 하나 만들어보자.  \n\n- test.py\n\n~~~\nfrom db.models import User\n\n\ndef run(*script_args):\n\n\tuser_list = User.objects.all()\n\n\tfor user in user_list:\n\t\tprint('name : ', user.name)\n~~~\n\n간단하다. 스크립트를 만들었으니 수행해보자. runscript 는 위에서도 언급했지만 django-extension의 기능중 하나이다.  \n\n~~~\n$ python manage.py runscript test\nname :  teddy\nname :  canel\nname :  twght\n~~~\n\n이제 필요한 스크립트를 만들어서 crontab에 걸어두면 django orm 을 이용해서 스크립트를 사용할 수 있다.    \n여기까지 했으면 간단하게 끝날텐데, 이 배치 스크립트를 여러 환경에 배포하고 돌려야 하는 일이 남아있었다.  \n물론 서버가 많지 않아 git으로 땡기거나 손으로 직접 옮겨도 되지만, 칼을 뽑은 김에 docker image 로 만들어서 써보자. 어렵지 않다.  \n\nDocker iamge 로 만드는 작업은 완전 단순하다. 사용법도 전혀 어렵지 않다. 일단 Dockerfile을 보자.\n\n- Dockerfile\n\n~~~\nFROM python:3.5-onbuild\n~~~\n\n사족으로 [pythpn:3.5-onbuild](https://github.com/docker-library/python/blob/9a9021f2134d953165b31d98cacb95aa34076f90/3.5/onbuild/Dockerfile) 에서 하는 일은 아래와 같다. \n\n~~~\n#\n# NOTE: THIS DOCKERFILE IS GENERATED VIA \"update.sh\"\n#\n# PLEASE DO NOT EDIT IT DIRECTLY.\n#\n\nFROM python:3.5\n\nRUN mkdir -p /usr/src/app\nWORKDIR /usr/src/app\n\nONBUILD COPY requirements.txt /usr/src/app/\nONBUILD RUN pip install --no-cache-dir -r requirements.txt\n\nONBUILD COPY . /usr/src/app\n~~~\n\n이렇게만 써주고 build 하면 끝이다. \n\n~~~\n$ docker build --tag django-orm:0.1 .\n~~~\n\n이미지를 만들었다면 다음과 같이 생성이 된다.  \n\n~~~\n$ docker images\nREPOSITORY            TAG                 IMAGE ID            CREATED             SIZE\ndjango-orm            0.1                 c8a6c10c8233        About an hour ago   715 MB\n~~~\n\n이 이미지를 사용하기 위해서는 run 명령으로 사용하도록 하자.  \n\n~~~\ndocker run --name django-orm django-orm python manage.py runscript test\n~~~\n\n### docker로 사용할 때 신경써야할 부분이 있다면 \ncontainer 내부에서는 host에 바로 접근할 수가 없기 때문에 mysql localhost 를 바라봐야 한다면 localhost 로 명시해주면 안된다.  \n물론 회피 방법은 조금만 구글링해도 나오지만 원칙적으로는 접근을 할 수 없으므로 이 부분을 신경써서 작업해주어야 한다.  \n~~나는 mysql이 다른 서버에 동작하고 있었기 떄문에 별 문제는 없었다.~~\n\n\n### 결론\n이미 django project 를 구동해본 경험이 있다면 큰 어려움 없이 사용할 수 있을 것이다.   \n물론 해당 프로젝트에서 배치 스크립트를 작성할 수도 있지만, 성격이 맞지 않을 수 있기 때문에 굳이 억지로 넣을 필요는 없다.  \ncursor로 작업하는게 간단하고 편할 수도 있지만, 여러 패키지를 함께 써야하고 여러 db 설정을 바라봐야 한다면 django 의 골격을 그대로 사용하는 방법이 손쉬울 수 있겠다.   \n해당 예제는 [django-orm standalone](https://github.com/nevercaution/django-orm) 에서 확인할 수 있다.  ","slug":"django-orm-standalone","published":1,"updated":"2018-04-15T08:08:41.993Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjq98sop700038ghhbv67eoui","content":"<p>필요에 의해서 배치 작업을 만들어야 했다.<br>\n간단하게 python으로 만들까 했는데, 단순 cursor로 사용하지 않고 django orm 으로 만들어 보고 싶은 생각이 들었다.<br>\n이미 작업하고 있는 django project 가 있었고, 그 안에서 사용하는 모델들을 사용해서 스크립트들을 만들면 좋겠다 생각이 들었다.<br>\n이미 django 구조에 익숙한 사람이라면 편하게 사용할 수 있을거라 생각했고, 관리가 용이하다는 장점이 있다.</p>\n<h3><span id=\"해야할-일은\">해야할 일은…</span></h3>\n<ul>\n<li>mysql, mongo에서 데이터를 주기적으로 가져온다.</li>\n<li>데이터를 가공해서 다시 mysql이나 mongo로 데이터를 주기적으로 쌓아준다.</li>\n<li>여러 서버의 상황에 맞게 대응을 해야한다.(real, sandbox, test등등)</li>\n</ul>\n<p>이미 사내에서 사용하고 있는 훌륭한 배치 스크립트 뭉치가 있다. 이 스크립트는 cursor를 통해서 mysql 데이터를 가져오고 넣는다.<br>\n물론 cursor로 쿼리를 작성해도 되지만 django-orm을 이용해서 이 작업을 조금 더 수월하게 할 수는 없을까? 하는 생각에 django template 를 사용하지 않고 orm 만 사용할 수 있는 프로젝트를 만들어보기로 했다.</p>\n<h3><span id=\"django-orm-standalone으로-가자\">django-orm standalone으로 가자</span></h3>\n<p>일단 간단한 django 프로젝트를 하나만든다.</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> django-admin startproject django-orm</span></span><br></pre></td></tr></table></figure>\n<p>설정과 최소한의 파일들을 제외하고 모두 제거해버리자. 구조는 아래와 같다.</p>\n<figure class=\"highlight stylus\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">.</span><br><span class=\"line\">├── Dockerfile</span><br><span class=\"line\">├── build.sh</span><br><span class=\"line\">├── db</span><br><span class=\"line\">│   ├── __init__.py</span><br><span class=\"line\">│   └── models.py</span><br><span class=\"line\">├── manage.py</span><br><span class=\"line\">├── requirements.txt</span><br><span class=\"line\">├── run.sh</span><br><span class=\"line\">├── scripts</span><br><span class=\"line\">│   ├── __init__.py</span><br><span class=\"line\">│   └── test.py</span><br><span class=\"line\">└── settings.py</span><br></pre></td></tr></table></figure>\n<ol>\n<li>requirements.txt : 스크립트를 수행할 떄 필요한 모듈등을 기술해준다.</li>\n<li><a href=\"http://manage.py\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">manage.py</a> : django-extension의 runscript 나 shell 기능을 사용할 수 있도록 한다.</li>\n<li><a href=\"http://settings.py\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">settings.py</a> : 여러 저장소의 접속 환경이나 환경변수들을 선언해준다.</li>\n</ol>\n<p>위의 구조를 뼈대로 필요한 부분을 채워서 사용하기로 한다. requirements.txt를 살펴보자.</p>\n<ul>\n<li>requirements.txt</li>\n</ul>\n<figure class=\"highlight ini\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">Django</span>==<span class=\"number\">1.11</span>.<span class=\"number\">2</span>    </span><br><span class=\"line\"><span class=\"attr\">django-extensions</span>==<span class=\"number\">1.7</span>.<span class=\"number\">9</span>  </span><br><span class=\"line\"><span class=\"attr\">mysqlclient</span>==<span class=\"number\">1.3</span>.<span class=\"number\">10</span>  </span><br><span class=\"line\"><span class=\"attr\">pytz</span>==<span class=\"number\">2017.2</span>  </span><br><span class=\"line\"><span class=\"attr\">six</span>==<span class=\"number\">1.10</span>.<span class=\"number\">0</span></span><br></pre></td></tr></table></figure>\n<p><a href=\"https://github.com/django-extensions/django-extensions\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">django-extension</a> 을 사용해서 스크립트들을 돌리고, mysql 의 데이터를 사용하기 위해 둘다 설치해주었다. 각자 필요한 부분이 있다면 추가해주면 된다.<br>\n이번에는 설정파일을 보도록 하자.</p>\n<ul>\n<li><a href=\"http://settings.py\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">settings.py</a></li>\n</ul>\n<figure class=\"highlight gradle\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> os</span><br><span class=\"line\"></span><br><span class=\"line\"># Build paths inside the <span class=\"keyword\">project</span> like <span class=\"keyword\">this</span>: os.path.<span class=\"keyword\">join</span>(BASE_DIR, ...)</span><br><span class=\"line\">BASE_DIR = os.path.dirname(os.path.abspath(__file__))</span><br><span class=\"line\"></span><br><span class=\"line\">DATABASES = &#123;</span><br><span class=\"line\">    <span class=\"string\">'default'</span>: &#123;</span><br><span class=\"line\">        <span class=\"string\">'ENGINE'</span>: <span class=\"string\">'django.db.backends.mysql'</span>,</span><br><span class=\"line\">        <span class=\"string\">'NAME'</span>: <span class=\"string\">'test'</span>,</span><br><span class=\"line\">        <span class=\"string\">'USER'</span>: <span class=\"string\">'root'</span>,</span><br><span class=\"line\">        <span class=\"string\">'PASSWORD'</span>: <span class=\"string\">''</span>,</span><br><span class=\"line\">        <span class=\"string\">'HOST'</span>: <span class=\"string\">'127.0.0.1'</span>,</span><br><span class=\"line\">        <span class=\"string\">'PORT'</span>: <span class=\"string\">'3306'</span></span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">INSTALLED_APPS = (</span><br><span class=\"line\">    <span class=\"string\">'db'</span>,</span><br><span class=\"line\">    <span class=\"string\">'django_extensions'</span>,</span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\"># SECURITY WARNING: Modify <span class=\"keyword\">this</span> secret key <span class=\"keyword\">if</span> using in production!</span><br><span class=\"line\">SECRET_KEY = <span class=\"string\">'&#123;your_secret_key&#125;'</span></span><br><span class=\"line\"></span><br><span class=\"line\">LANGUAGE_CODE = <span class=\"string\">'en-us'</span></span><br><span class=\"line\"></span><br><span class=\"line\">TIME_ZONE = <span class=\"string\">'Asia/Seoul'</span></span><br><span class=\"line\"></span><br><span class=\"line\">USE_I18N = <span class=\"keyword\">True</span></span><br><span class=\"line\"></span><br><span class=\"line\">USE_L10N = <span class=\"keyword\">True</span></span><br><span class=\"line\"></span><br><span class=\"line\">USE_TZ = <span class=\"keyword\">True</span></span><br></pre></td></tr></table></figure>\n<p>기본 설정파일에서 DATABASES 부분만 수정해 준 상태이고 model들이 KST로 시간을 붙어여 했기 때문에 타임존 설정을 서울로 바꾸어 주었다.<br>\n여기에서 로그에 대한 설정이나 다른 저장소에 대한 정보를 적어주면 된다.</p>\n<p>구조를 잡았으니 추가해야할 패키지들을 설치해주도록 한다. 여기서부터는 익히 알고 있는 패턴이므로 간단하게 살펴보자.</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> pip install -r requiremwnts.txt</span></span><br></pre></td></tr></table></figure>\n<p>모델은 현재 자신의 db에 있는 테이블을 정의해주고 orm으로 붙기만 하면 된다. 모델을 한번 보자.</p>\n<ul>\n<li><a href=\"http://model.py\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">model.py</a></li>\n</ul>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> django.db <span class=\"keyword\">import</span> models</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># Create your models here.</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">User</span><span class=\"params\">(models.Model)</span>:</span></span><br><span class=\"line\">    id = models.IntegerField(primary_key=<span class=\"keyword\">True</span>)</span><br><span class=\"line\">    name = models.CharField(max_length=<span class=\"number\">11</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Meta</span>:</span></span><br><span class=\"line\">        managed = <span class=\"keyword\">False</span></span><br><span class=\"line\">        db_table = <span class=\"string\">'user'</span></span><br></pre></td></tr></table></figure>\n<p>db 설정을 해주었고 필요한 패키지를 설치했고, 모델들을 정의해주었다면 한번 붙어보자.</p>\n<h3><span id=\"hello-orm\">hello orm</span></h3>\n<p>python shell 로 들어가서 모델을 통해 데이터를 가져오면 된다.</p>\n<figure class=\"highlight vim\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ <span class=\"keyword\">python</span> manage.<span class=\"keyword\">py</span> <span class=\"keyword\">shell</span></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight routeros\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt;&gt;&gt; <span class=\"keyword\">from</span> db.models import User</span><br><span class=\"line\">&gt;&gt;&gt; User.objects.all()</span><br><span class=\"line\">&lt;QuerySet [&lt;User:<span class=\"built_in\"> User </span>object&gt;, &lt;User:<span class=\"built_in\"> User </span>object&gt;, &lt;User:<span class=\"built_in\"> User </span>object&gt;, &lt;User:<span class=\"built_in\"> User </span>object&gt;, &lt;User:<span class=\"built_in\"> User </span>object&gt;]&gt;</span><br></pre></td></tr></table></figure>\n<p>모델을 통해 데이터를 가져올 수 있고, 작업해야할 부분은 스크립트를 만들어서 사용하도록 한다. 기본적인 스크립트를 하나 만들어보자.</p>\n<ul>\n<li><a href=\"http://test.py\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">test.py</a></li>\n</ul>\n<figure class=\"highlight dockerfile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> db.models import <span class=\"keyword\">User</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">def <span class=\"keyword\">run</span><span class=\"bash\">(*script_args):</span></span><br><span class=\"line\"><span class=\"bash\"></span></span><br><span class=\"line\"><span class=\"bash\">\tuser_list = User.objects.all()</span></span><br><span class=\"line\"><span class=\"bash\"></span></span><br><span class=\"line\"><span class=\"bash\">\t<span class=\"keyword\">for</span> user <span class=\"keyword\">in</span> user_list:</span></span><br><span class=\"line\"><span class=\"bash\">\t\t<span class=\"built_in\">print</span>(<span class=\"string\">'name : '</span>, user.name)</span></span><br></pre></td></tr></table></figure>\n<p>간단하다. 스크립트를 만들었으니 수행해보자. runscript 는 위에서도 언급했지만 django-extension의 기능중 하나이다.</p>\n<figure class=\"highlight ada\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ python manage.py runscript test</span><br><span class=\"line\">name :  <span class=\"type\">teddy</span></span><br><span class=\"line\">name :  <span class=\"type\">canel</span></span><br><span class=\"line\">name :  <span class=\"type\">twght</span></span><br></pre></td></tr></table></figure>\n<p>이제 필요한 스크립트를 만들어서 crontab에 걸어두면 django orm 을 이용해서 스크립트를 사용할 수 있다.<br>\n여기까지 했으면 간단하게 끝날텐데, 이 배치 스크립트를 여러 환경에 배포하고 돌려야 하는 일이 남아있었다.<br>\n물론 서버가 많지 않아 git으로 땡기거나 손으로 직접 옮겨도 되지만, 칼을 뽑은 김에 docker image 로 만들어서 써보자. 어렵지 않다.</p>\n<p>Docker iamge 로 만드는 작업은 완전 단순하다. 사용법도 전혀 어렵지 않다. 일단 Dockerfile을 보자.</p>\n<ul>\n<li>Dockerfile</li>\n</ul>\n<figure class=\"highlight dockerfile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">FROM</span> python:<span class=\"number\">3.5</span>-<span class=\"keyword\">onbuild</span></span><br></pre></td></tr></table></figure>\n<p>사족으로 <a href=\"https://github.com/docker-library/python/blob/9a9021f2134d953165b31d98cacb95aa34076f90/3.5/onbuild/Dockerfile\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">pythpn:3.5-onbuild</a> 에서 하는 일은 아래와 같다.</p>\n<figure class=\"highlight dockerfile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">#</span></span><br><span class=\"line\"><span class=\"comment\"># <span class=\"doctag\">NOTE:</span> THIS DOCKERFILE IS GENERATED VIA \"update.sh\"</span></span><br><span class=\"line\"><span class=\"comment\">#</span></span><br><span class=\"line\"><span class=\"comment\"># PLEASE DO NOT EDIT IT DIRECTLY.</span></span><br><span class=\"line\"><span class=\"comment\">#</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">FROM</span> python:<span class=\"number\">3.5</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">RUN</span><span class=\"bash\"> mkdir -p /usr/src/app</span></span><br><span class=\"line\"><span class=\"bash\">WORKDIR /usr/src/app</span></span><br><span class=\"line\"><span class=\"bash\"></span></span><br><span class=\"line\"><span class=\"bash\">ONBUILD COPY requirements.txt /usr/src/app/</span></span><br><span class=\"line\"><span class=\"bash\">ONBUILD RUN pip install --no-cache-dir -r requirements.txt</span></span><br><span class=\"line\"><span class=\"bash\"></span></span><br><span class=\"line\"><span class=\"bash\">ONBUILD COPY . /usr/src/app</span></span><br></pre></td></tr></table></figure>\n<p>이렇게만 써주고 build 하면 끝이다.</p>\n<figure class=\"highlight crmsh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ docker build --<span class=\"keyword\">tag</span> <span class=\"title\">django-orm</span>:<span class=\"number\">0.1</span> .</span><br></pre></td></tr></table></figure>\n<p>이미지를 만들었다면 다음과 같이 생성이 된다.</p>\n<figure class=\"highlight crmsh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ docker images</span><br><span class=\"line\">REPOSITORY            <span class=\"keyword\">TAG</span>                 <span class=\"title\">IMAGE</span> ID            CREATED             SIZE</span><br><span class=\"line\">django-orm            <span class=\"number\">0.1</span>                 c8a6c10c8233        About an hour ago   <span class=\"number\">715</span> MB</span><br></pre></td></tr></table></figure>\n<p>이 이미지를 사용하기 위해서는 run 명령으로 사용하도록 하자.</p>\n<figure class=\"highlight dockerfile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker <span class=\"keyword\">run</span><span class=\"bash\"> --name django-orm django-orm python manage.py runscript <span class=\"built_in\">test</span></span></span><br></pre></td></tr></table></figure>\n<h3><span id=\"docker로-사용할-때-신경써야할-부분이-있다면\">docker로 사용할 때 신경써야할 부분이 있다면</span></h3>\n<p>container 내부에서는 host에 바로 접근할 수가 없기 때문에 mysql localhost 를 바라봐야 한다면 localhost 로 명시해주면 안된다.<br>\n물론 회피 방법은 조금만 구글링해도 나오지만 원칙적으로는 접근을 할 수 없으므로 이 부분을 신경써서 작업해주어야 한다.<br>\n<s>나는 mysql이 다른 서버에 동작하고 있었기 떄문에 별 문제는 없었다.</s></p>\n<h3><span id=\"결론\">결론</span></h3>\n<p>이미 django project 를 구동해본 경험이 있다면 큰 어려움 없이 사용할 수 있을 것이다.<br>\n물론 해당 프로젝트에서 배치 스크립트를 작성할 수도 있지만, 성격이 맞지 않을 수 있기 때문에 굳이 억지로 넣을 필요는 없다.<br>\ncursor로 작업하는게 간단하고 편할 수도 있지만, 여러 패키지를 함께 써야하고 여러 db 설정을 바라봐야 한다면 django 의 골격을 그대로 사용하는 방법이 손쉬울 수 있겠다.<br>\n해당 예제는 <a href=\"https://github.com/nevercaution/django-orm\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">django-orm standalone</a> 에서 확인할 수 있다.</p>\n","site":{"data":{}},"excerpt":"","more":"<p>필요에 의해서 배치 작업을 만들어야 했다.<br>\n간단하게 python으로 만들까 했는데, 단순 cursor로 사용하지 않고 django orm 으로 만들어 보고 싶은 생각이 들었다.<br>\n이미 작업하고 있는 django project 가 있었고, 그 안에서 사용하는 모델들을 사용해서 스크립트들을 만들면 좋겠다 생각이 들었다.<br>\n이미 django 구조에 익숙한 사람이라면 편하게 사용할 수 있을거라 생각했고, 관리가 용이하다는 장점이 있다.</p>\n<h3>해야할 일은…</h3>\n<ul>\n<li>mysql, mongo에서 데이터를 주기적으로 가져온다.</li>\n<li>데이터를 가공해서 다시 mysql이나 mongo로 데이터를 주기적으로 쌓아준다.</li>\n<li>여러 서버의 상황에 맞게 대응을 해야한다.(real, sandbox, test등등)</li>\n</ul>\n<p>이미 사내에서 사용하고 있는 훌륭한 배치 스크립트 뭉치가 있다. 이 스크립트는 cursor를 통해서 mysql 데이터를 가져오고 넣는다.<br>\n물론 cursor로 쿼리를 작성해도 되지만 django-orm을 이용해서 이 작업을 조금 더 수월하게 할 수는 없을까? 하는 생각에 django template 를 사용하지 않고 orm 만 사용할 수 있는 프로젝트를 만들어보기로 했다.</p>\n<h3>django-orm standalone으로 가자</h3>\n<p>일단 간단한 django 프로젝트를 하나만든다.</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> django-admin startproject django-orm</span></span><br></pre></td></tr></table></figure>\n<p>설정과 최소한의 파일들을 제외하고 모두 제거해버리자. 구조는 아래와 같다.</p>\n<figure class=\"highlight stylus\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">.</span><br><span class=\"line\">├── Dockerfile</span><br><span class=\"line\">├── build.sh</span><br><span class=\"line\">├── db</span><br><span class=\"line\">│   ├── __init__.py</span><br><span class=\"line\">│   └── models.py</span><br><span class=\"line\">├── manage.py</span><br><span class=\"line\">├── requirements.txt</span><br><span class=\"line\">├── run.sh</span><br><span class=\"line\">├── scripts</span><br><span class=\"line\">│   ├── __init__.py</span><br><span class=\"line\">│   └── test.py</span><br><span class=\"line\">└── settings.py</span><br></pre></td></tr></table></figure>\n<ol>\n<li>requirements.txt : 스크립트를 수행할 떄 필요한 모듈등을 기술해준다.</li>\n<li><a href=\"http://manage.py\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">manage.py</a> : django-extension의 runscript 나 shell 기능을 사용할 수 있도록 한다.</li>\n<li><a href=\"http://settings.py\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">settings.py</a> : 여러 저장소의 접속 환경이나 환경변수들을 선언해준다.</li>\n</ol>\n<p>위의 구조를 뼈대로 필요한 부분을 채워서 사용하기로 한다. requirements.txt를 살펴보자.</p>\n<ul>\n<li>requirements.txt</li>\n</ul>\n<figure class=\"highlight ini\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">Django</span>==<span class=\"number\">1.11</span>.<span class=\"number\">2</span>    </span><br><span class=\"line\"><span class=\"attr\">django-extensions</span>==<span class=\"number\">1.7</span>.<span class=\"number\">9</span>  </span><br><span class=\"line\"><span class=\"attr\">mysqlclient</span>==<span class=\"number\">1.3</span>.<span class=\"number\">10</span>  </span><br><span class=\"line\"><span class=\"attr\">pytz</span>==<span class=\"number\">2017.2</span>  </span><br><span class=\"line\"><span class=\"attr\">six</span>==<span class=\"number\">1.10</span>.<span class=\"number\">0</span></span><br></pre></td></tr></table></figure>\n<p><a href=\"https://github.com/django-extensions/django-extensions\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">django-extension</a> 을 사용해서 스크립트들을 돌리고, mysql 의 데이터를 사용하기 위해 둘다 설치해주었다. 각자 필요한 부분이 있다면 추가해주면 된다.<br>\n이번에는 설정파일을 보도록 하자.</p>\n<ul>\n<li><a href=\"http://settings.py\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">settings.py</a></li>\n</ul>\n<figure class=\"highlight gradle\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> os</span><br><span class=\"line\"></span><br><span class=\"line\"># Build paths inside the <span class=\"keyword\">project</span> like <span class=\"keyword\">this</span>: os.path.<span class=\"keyword\">join</span>(BASE_DIR, ...)</span><br><span class=\"line\">BASE_DIR = os.path.dirname(os.path.abspath(__file__))</span><br><span class=\"line\"></span><br><span class=\"line\">DATABASES = &#123;</span><br><span class=\"line\">    <span class=\"string\">'default'</span>: &#123;</span><br><span class=\"line\">        <span class=\"string\">'ENGINE'</span>: <span class=\"string\">'django.db.backends.mysql'</span>,</span><br><span class=\"line\">        <span class=\"string\">'NAME'</span>: <span class=\"string\">'test'</span>,</span><br><span class=\"line\">        <span class=\"string\">'USER'</span>: <span class=\"string\">'root'</span>,</span><br><span class=\"line\">        <span class=\"string\">'PASSWORD'</span>: <span class=\"string\">''</span>,</span><br><span class=\"line\">        <span class=\"string\">'HOST'</span>: <span class=\"string\">'127.0.0.1'</span>,</span><br><span class=\"line\">        <span class=\"string\">'PORT'</span>: <span class=\"string\">'3306'</span></span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">INSTALLED_APPS = (</span><br><span class=\"line\">    <span class=\"string\">'db'</span>,</span><br><span class=\"line\">    <span class=\"string\">'django_extensions'</span>,</span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\"># SECURITY WARNING: Modify <span class=\"keyword\">this</span> secret key <span class=\"keyword\">if</span> using in production!</span><br><span class=\"line\">SECRET_KEY = <span class=\"string\">'&#123;your_secret_key&#125;'</span></span><br><span class=\"line\"></span><br><span class=\"line\">LANGUAGE_CODE = <span class=\"string\">'en-us'</span></span><br><span class=\"line\"></span><br><span class=\"line\">TIME_ZONE = <span class=\"string\">'Asia/Seoul'</span></span><br><span class=\"line\"></span><br><span class=\"line\">USE_I18N = <span class=\"keyword\">True</span></span><br><span class=\"line\"></span><br><span class=\"line\">USE_L10N = <span class=\"keyword\">True</span></span><br><span class=\"line\"></span><br><span class=\"line\">USE_TZ = <span class=\"keyword\">True</span></span><br></pre></td></tr></table></figure>\n<p>기본 설정파일에서 DATABASES 부분만 수정해 준 상태이고 model들이 KST로 시간을 붙어여 했기 때문에 타임존 설정을 서울로 바꾸어 주었다.<br>\n여기에서 로그에 대한 설정이나 다른 저장소에 대한 정보를 적어주면 된다.</p>\n<p>구조를 잡았으니 추가해야할 패키지들을 설치해주도록 한다. 여기서부터는 익히 알고 있는 패턴이므로 간단하게 살펴보자.</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> pip install -r requiremwnts.txt</span></span><br></pre></td></tr></table></figure>\n<p>모델은 현재 자신의 db에 있는 테이블을 정의해주고 orm으로 붙기만 하면 된다. 모델을 한번 보자.</p>\n<ul>\n<li><a href=\"http://model.py\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">model.py</a></li>\n</ul>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> django.db <span class=\"keyword\">import</span> models</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># Create your models here.</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">User</span><span class=\"params\">(models.Model)</span>:</span></span><br><span class=\"line\">    id = models.IntegerField(primary_key=<span class=\"keyword\">True</span>)</span><br><span class=\"line\">    name = models.CharField(max_length=<span class=\"number\">11</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Meta</span>:</span></span><br><span class=\"line\">        managed = <span class=\"keyword\">False</span></span><br><span class=\"line\">        db_table = <span class=\"string\">'user'</span></span><br></pre></td></tr></table></figure>\n<p>db 설정을 해주었고 필요한 패키지를 설치했고, 모델들을 정의해주었다면 한번 붙어보자.</p>\n<h3>hello orm</h3>\n<p>python shell 로 들어가서 모델을 통해 데이터를 가져오면 된다.</p>\n<figure class=\"highlight vim\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ <span class=\"keyword\">python</span> manage.<span class=\"keyword\">py</span> <span class=\"keyword\">shell</span></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight routeros\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt;&gt;&gt; <span class=\"keyword\">from</span> db.models import User</span><br><span class=\"line\">&gt;&gt;&gt; User.objects.all()</span><br><span class=\"line\">&lt;QuerySet [&lt;User:<span class=\"built_in\"> User </span>object&gt;, &lt;User:<span class=\"built_in\"> User </span>object&gt;, &lt;User:<span class=\"built_in\"> User </span>object&gt;, &lt;User:<span class=\"built_in\"> User </span>object&gt;, &lt;User:<span class=\"built_in\"> User </span>object&gt;]&gt;</span><br></pre></td></tr></table></figure>\n<p>모델을 통해 데이터를 가져올 수 있고, 작업해야할 부분은 스크립트를 만들어서 사용하도록 한다. 기본적인 스크립트를 하나 만들어보자.</p>\n<ul>\n<li><a href=\"http://test.py\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">test.py</a></li>\n</ul>\n<figure class=\"highlight dockerfile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> db.models import <span class=\"keyword\">User</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">def <span class=\"keyword\">run</span><span class=\"bash\">(*script_args):</span></span><br><span class=\"line\"><span class=\"bash\"></span></span><br><span class=\"line\"><span class=\"bash\">\tuser_list = User.objects.all()</span></span><br><span class=\"line\"><span class=\"bash\"></span></span><br><span class=\"line\"><span class=\"bash\">\t<span class=\"keyword\">for</span> user <span class=\"keyword\">in</span> user_list:</span></span><br><span class=\"line\"><span class=\"bash\">\t\t<span class=\"built_in\">print</span>(<span class=\"string\">'name : '</span>, user.name)</span></span><br></pre></td></tr></table></figure>\n<p>간단하다. 스크립트를 만들었으니 수행해보자. runscript 는 위에서도 언급했지만 django-extension의 기능중 하나이다.</p>\n<figure class=\"highlight ada\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ python manage.py runscript test</span><br><span class=\"line\">name :  <span class=\"type\">teddy</span></span><br><span class=\"line\">name :  <span class=\"type\">canel</span></span><br><span class=\"line\">name :  <span class=\"type\">twght</span></span><br></pre></td></tr></table></figure>\n<p>이제 필요한 스크립트를 만들어서 crontab에 걸어두면 django orm 을 이용해서 스크립트를 사용할 수 있다.<br>\n여기까지 했으면 간단하게 끝날텐데, 이 배치 스크립트를 여러 환경에 배포하고 돌려야 하는 일이 남아있었다.<br>\n물론 서버가 많지 않아 git으로 땡기거나 손으로 직접 옮겨도 되지만, 칼을 뽑은 김에 docker image 로 만들어서 써보자. 어렵지 않다.</p>\n<p>Docker iamge 로 만드는 작업은 완전 단순하다. 사용법도 전혀 어렵지 않다. 일단 Dockerfile을 보자.</p>\n<ul>\n<li>Dockerfile</li>\n</ul>\n<figure class=\"highlight dockerfile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">FROM</span> python:<span class=\"number\">3.5</span>-<span class=\"keyword\">onbuild</span></span><br></pre></td></tr></table></figure>\n<p>사족으로 <a href=\"https://github.com/docker-library/python/blob/9a9021f2134d953165b31d98cacb95aa34076f90/3.5/onbuild/Dockerfile\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">pythpn:3.5-onbuild</a> 에서 하는 일은 아래와 같다.</p>\n<figure class=\"highlight dockerfile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">#</span></span><br><span class=\"line\"><span class=\"comment\"># <span class=\"doctag\">NOTE:</span> THIS DOCKERFILE IS GENERATED VIA \"update.sh\"</span></span><br><span class=\"line\"><span class=\"comment\">#</span></span><br><span class=\"line\"><span class=\"comment\"># PLEASE DO NOT EDIT IT DIRECTLY.</span></span><br><span class=\"line\"><span class=\"comment\">#</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">FROM</span> python:<span class=\"number\">3.5</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">RUN</span><span class=\"bash\"> mkdir -p /usr/src/app</span></span><br><span class=\"line\"><span class=\"bash\">WORKDIR /usr/src/app</span></span><br><span class=\"line\"><span class=\"bash\"></span></span><br><span class=\"line\"><span class=\"bash\">ONBUILD COPY requirements.txt /usr/src/app/</span></span><br><span class=\"line\"><span class=\"bash\">ONBUILD RUN pip install --no-cache-dir -r requirements.txt</span></span><br><span class=\"line\"><span class=\"bash\"></span></span><br><span class=\"line\"><span class=\"bash\">ONBUILD COPY . /usr/src/app</span></span><br></pre></td></tr></table></figure>\n<p>이렇게만 써주고 build 하면 끝이다.</p>\n<figure class=\"highlight crmsh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ docker build --<span class=\"keyword\">tag</span> <span class=\"title\">django-orm</span>:<span class=\"number\">0.1</span> .</span><br></pre></td></tr></table></figure>\n<p>이미지를 만들었다면 다음과 같이 생성이 된다.</p>\n<figure class=\"highlight crmsh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ docker images</span><br><span class=\"line\">REPOSITORY            <span class=\"keyword\">TAG</span>                 <span class=\"title\">IMAGE</span> ID            CREATED             SIZE</span><br><span class=\"line\">django-orm            <span class=\"number\">0.1</span>                 c8a6c10c8233        About an hour ago   <span class=\"number\">715</span> MB</span><br></pre></td></tr></table></figure>\n<p>이 이미지를 사용하기 위해서는 run 명령으로 사용하도록 하자.</p>\n<figure class=\"highlight dockerfile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker <span class=\"keyword\">run</span><span class=\"bash\"> --name django-orm django-orm python manage.py runscript <span class=\"built_in\">test</span></span></span><br></pre></td></tr></table></figure>\n<h3>docker로 사용할 때 신경써야할 부분이 있다면</h3>\n<p>container 내부에서는 host에 바로 접근할 수가 없기 때문에 mysql localhost 를 바라봐야 한다면 localhost 로 명시해주면 안된다.<br>\n물론 회피 방법은 조금만 구글링해도 나오지만 원칙적으로는 접근을 할 수 없으므로 이 부분을 신경써서 작업해주어야 한다.<br>\n<s>나는 mysql이 다른 서버에 동작하고 있었기 떄문에 별 문제는 없었다.</s></p>\n<h3>결론</h3>\n<p>이미 django project 를 구동해본 경험이 있다면 큰 어려움 없이 사용할 수 있을 것이다.<br>\n물론 해당 프로젝트에서 배치 스크립트를 작성할 수도 있지만, 성격이 맞지 않을 수 있기 때문에 굳이 억지로 넣을 필요는 없다.<br>\ncursor로 작업하는게 간단하고 편할 수도 있지만, 여러 패키지를 함께 써야하고 여러 db 설정을 바라봐야 한다면 django 의 골격을 그대로 사용하는 방법이 손쉬울 수 있겠다.<br>\n해당 예제는 <a href=\"https://github.com/nevercaution/django-orm\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">django-orm standalone</a> 에서 확인할 수 있다.</p>\n"},{"title":"Django에서 ajax요청하기","catalog":true,"date":"2016-03-27T07:08:12.000Z","subtitle":null,"header-img":"/img/header_img/bg.png","_content":"View에서 get, post요청을 할 때 template단에서 ajax요청을 날려야할 때가 있다.\nAPIVIew, View 두개의 경우를 살펴보자.\n1.APIView ↔ ajax (post, get)\n(post의 케이스로 설명을 하였지만 get도 동일한 방식이다.)\n가장 빈번하게 사용하는 케이스이다. template 에서 버튼을 눌러 요청을 ajax로 날려 결과값을 받아와서 전체 화면을 다시 그리지 않고 필요한 부분만 갱신해줄 수 있다.\n\n- template.html\n\n~~~\n$.ajax({\n    url: \"{% url 'request:url' %}\",\n    type: 'POST',\n    data: {\n        'user_id': user_id\n    },\n    success: function (response) {\n        // TODO: do something.\n    },\n    error: function (err) {\n        console.log(err);\n    }\n});\n~~~\n\n\n\n- url.py\n\n ```\nurl(r'^request/url$', views.TestView.as_view(), name='url'),\n  ```\n\n- view.py\n\n``` \nclass TestView(APIView):\n    def post(self, request):\n        user_id = request.POST.get('user_id')\n      # do something\n       return Response()\n```\n  \n  \nView class를 상속받고 post 메소드로 받는다면 ajax 요청시 csrf 토큰이 없다고 하면서 403에러가 발생한다.\n이를 해결해주기 위해 APIView를 상속받아서 처리하면 csrf 인증을 피해갈 수 있다.  (피해간다기보단 이미 인증이 되어있는 요청이라고 판단하는 것이지만)\n이는 APIView의 as_view() 메소드를 보면 알 수 있는데\n\n- api_view.py\n\n```\ndef as_view(cls, **initkwargs):\n    \"\"\"\n    Store the original class on the view function.\n \n    This allows us to discover information about the view when we do URL\n    reverse lookups.  Used for breadcrumb generation.\n    \"\"\"\n    if isinstance(getattr(cls, 'queryset', None), models.query.QuerySet):\n        def force_evaluation():\n            raise RuntimeError(\n                'Do not evaluate the `.queryset` attribute directly, '\n                'as the result will be cached and reused between requests. '\n                'Use `.all()` or call `.get_queryset()` instead.'\n            )\n        cls.queryset._fetch_all = force_evaluation\n        cls.queryset._result_iter = force_evaluation  # Django <= 1.5\n \n    view = super(APIView, cls).as_view(**initkwargs)\n    view.cls = cls\n \n    # Note: session based authentication is explicitly CSRF validated,\n    # all other authentication is CSRF exempt.\n    return csrf_exempt(view)\n```\n\n마지막 라인에 csrf_exempt로 view를 감싸준다. 이는 해당 API요청이 csrf 인증이 되어있다고 명시해주는 것이다.\n그리고, 내부로 파고 들어가면  APIView에서 authentication_classes = api_settings.DEFAULT_AUTHENTICATION_CLASSES 로 설정이 되어있는데, restframework의 setting을 살펴보면 아래와 같이 정의가 되어있음을 알 수 있다.\n  \n- api_settings.py\n\n```\n'DEFAULT_AUTHENTICATION_CLASSES': (\n    'rest_framework.authentication.SessionAuthentication',\n    'rest_framework.authentication.BasicAuthentication'\n),\n  \n# Authentication\n'UNAUTHENTICATED_USER': 'django.contrib.auth.models.AnonymousUser',\n'UNAUTHENTICATED_TOKEN': None,\n```\n\n인증 처리를 rest_framework의 SessionAuthentication으로 하겠다는 내용과 인증 유저를 AnonymousUser 로 설정을 해준다.\n기존의 인증절차에서 default인증 객체를 검사하게 되는데, 이 때 user객체의 active를 검사할 때 이 객체가 유효하지 않으면 unauthenticated_user로 AnonymousUser객체를 생성하게 된다. 접근 허용 체크를 할 때는 APIView에 정의된 permission class로 체크를 하는데 아래와 같다.\n  \n- api_settings.py\n\n``` \n'DEFAULT_PERMISSION_CLASSES': (\n    'rest_framework.permissions.AllowAny',\n),\n```\n\nAllowAny Class는 permission요청에 대해 무조건 True를 반환해주므로, APIView의 check_permissions 메소드에서 권한 체크를 할 때 권한이 있다고 판단을 한다.\n  \n- permissions.py\n\n``` \nclass AllowAny(BasePermission):\n    \"\"\"\n    Allow any access.\n    This isn't strictly required, since you could use an empty\n    permission_classes list, but it's useful because it makes the intention\n    more explicit.\n    \"\"\"\n    def has_permission(self, request, view):\n        return True\n```\n \n즉, APIView는 기존의 django 에서 체크하고 있는 csrf 공격방어에 대한 인증을 제외하고 따로 인증절차를 진행하게되는데, 인증 유저를 익명유저로 설정하여 유저에 대한 권한검사를 하지 않고 default로 설정이 된 권한체크 클래스로 검사를 한다.\nAllowAny는 접근 허용여부를 모두 True로 반환하여 접근에 대해 유효하다고 판단하여 csrf토큰 없이 요청 수행이 가능한 것이다.\n데이터를 모두 처리하고 나서의 응답값은 Response 객체를 반환함으로서 처리한다.\n\n2.View ↔ ajax (post, get)\najax를 통해 View class에 메소드를 호출하는 경우는 많지는 않았는데, 이유는 굳이 ajax로 호출하지 않아도 할 수 있는 방법들이 있었기 때문이었다.\n하지만 종종 사용해야할 경우가 있었는데, 이를테면 내부 검색창에서 검색결과를 내부 포멧에 맞게 내용을 채워줘야 하는데 그 template가 별도의 파일로 있는 경우였다.\n  \n  \n- template.html\n\n~~~\n$(\"#searchFrom\").submit(function () {\n    var user_id = $(\"input[name=user_id]\").val();\n \n    $.ajax({\n        url: \"{% url 'user:search' %}\",\n        type: \"POST\",\n        data: {\n            \"csrfmiddlewaretoken\": \"\\{\\{ csrf_token \\}\\}\",\n            'user_id': user_id,\n        },\n        success: function (response) {\n            $('#user_list tbody').html(response);\n        },\n        error: function (err) {\n            console.log(err);\n        }\n    });\n \n    return false;\n});\n~~~\n\n{% raw %}\n위의 tempalate에서 입력받은 데이터를 통해 ajax로 호출을 한다. 이 때 호출되는 class는 View를 상속받은 class 이다. form의 submit으로 호출을 한 경우인데 form에 {% csrf_token %}이 들어가있기 때문에 post요청을 날릴 경우엔 403이 떨어진다.(get요청은 안넣어도 상관없다.)\n이런 경우를 방지하기 위해 data필드에 csrf token 을 넣어준다.\n{% endraw %}\n\n~~~\n\"csrfmiddlewaretoken\": \"{{ csrf_token }}\",\n~~~\n\n요청을 받고 데이터를 만들고 나면 TemplateResponse를 사용하여 분리되어 생성된 페이지를 반환하게 된다. \n  \n- view.py\n\n```\nclass UserSearchView(View):\n    def post(self, request):\n        user_id = request.POST.get('user_id')\n        user_list = service.search_user(user_id)\n        context = {\n            'user_list': user_list\n        }\n        return TemplateResponse(request, 'user/user_list.html', context)\n```\n\n다시 template에서는 넘어온 html덩어리를 미리 정의해둔 위치에 그대로 붙여줌으로서 화면을 다시 그리지 않고, 필요한 부분만 넣어줄 수 있다. \n(APIView등을 통해 데이터만 받아와 다시 그리는 방법도 있지만 성격이 맞지 않는다고 생각하였고, 일반 호출을 하게 되면 페이지로딩을 다시 하므로 그 방법은 피했다)\n\n\n","source":"_posts/django-ajax.md","raw":"---\ntitle: \"Django에서 ajax요청하기\"\ncatalog: true\ndate: 2016-03-27 16:08:12\nsubtitle:\nheader-img: \"/img/header_img/bg.png\"\ntags:\n- django\n- ajax\n---\nView에서 get, post요청을 할 때 template단에서 ajax요청을 날려야할 때가 있다.\nAPIVIew, View 두개의 경우를 살펴보자.\n1.APIView ↔ ajax (post, get)\n(post의 케이스로 설명을 하였지만 get도 동일한 방식이다.)\n가장 빈번하게 사용하는 케이스이다. template 에서 버튼을 눌러 요청을 ajax로 날려 결과값을 받아와서 전체 화면을 다시 그리지 않고 필요한 부분만 갱신해줄 수 있다.\n\n- template.html\n\n~~~\n$.ajax({\n    url: \"{% url 'request:url' %}\",\n    type: 'POST',\n    data: {\n        'user_id': user_id\n    },\n    success: function (response) {\n        // TODO: do something.\n    },\n    error: function (err) {\n        console.log(err);\n    }\n});\n~~~\n\n\n\n- url.py\n\n ```\nurl(r'^request/url$', views.TestView.as_view(), name='url'),\n  ```\n\n- view.py\n\n``` \nclass TestView(APIView):\n    def post(self, request):\n        user_id = request.POST.get('user_id')\n      # do something\n       return Response()\n```\n  \n  \nView class를 상속받고 post 메소드로 받는다면 ajax 요청시 csrf 토큰이 없다고 하면서 403에러가 발생한다.\n이를 해결해주기 위해 APIView를 상속받아서 처리하면 csrf 인증을 피해갈 수 있다.  (피해간다기보단 이미 인증이 되어있는 요청이라고 판단하는 것이지만)\n이는 APIView의 as_view() 메소드를 보면 알 수 있는데\n\n- api_view.py\n\n```\ndef as_view(cls, **initkwargs):\n    \"\"\"\n    Store the original class on the view function.\n \n    This allows us to discover information about the view when we do URL\n    reverse lookups.  Used for breadcrumb generation.\n    \"\"\"\n    if isinstance(getattr(cls, 'queryset', None), models.query.QuerySet):\n        def force_evaluation():\n            raise RuntimeError(\n                'Do not evaluate the `.queryset` attribute directly, '\n                'as the result will be cached and reused between requests. '\n                'Use `.all()` or call `.get_queryset()` instead.'\n            )\n        cls.queryset._fetch_all = force_evaluation\n        cls.queryset._result_iter = force_evaluation  # Django <= 1.5\n \n    view = super(APIView, cls).as_view(**initkwargs)\n    view.cls = cls\n \n    # Note: session based authentication is explicitly CSRF validated,\n    # all other authentication is CSRF exempt.\n    return csrf_exempt(view)\n```\n\n마지막 라인에 csrf_exempt로 view를 감싸준다. 이는 해당 API요청이 csrf 인증이 되어있다고 명시해주는 것이다.\n그리고, 내부로 파고 들어가면  APIView에서 authentication_classes = api_settings.DEFAULT_AUTHENTICATION_CLASSES 로 설정이 되어있는데, restframework의 setting을 살펴보면 아래와 같이 정의가 되어있음을 알 수 있다.\n  \n- api_settings.py\n\n```\n'DEFAULT_AUTHENTICATION_CLASSES': (\n    'rest_framework.authentication.SessionAuthentication',\n    'rest_framework.authentication.BasicAuthentication'\n),\n  \n# Authentication\n'UNAUTHENTICATED_USER': 'django.contrib.auth.models.AnonymousUser',\n'UNAUTHENTICATED_TOKEN': None,\n```\n\n인증 처리를 rest_framework의 SessionAuthentication으로 하겠다는 내용과 인증 유저를 AnonymousUser 로 설정을 해준다.\n기존의 인증절차에서 default인증 객체를 검사하게 되는데, 이 때 user객체의 active를 검사할 때 이 객체가 유효하지 않으면 unauthenticated_user로 AnonymousUser객체를 생성하게 된다. 접근 허용 체크를 할 때는 APIView에 정의된 permission class로 체크를 하는데 아래와 같다.\n  \n- api_settings.py\n\n``` \n'DEFAULT_PERMISSION_CLASSES': (\n    'rest_framework.permissions.AllowAny',\n),\n```\n\nAllowAny Class는 permission요청에 대해 무조건 True를 반환해주므로, APIView의 check_permissions 메소드에서 권한 체크를 할 때 권한이 있다고 판단을 한다.\n  \n- permissions.py\n\n``` \nclass AllowAny(BasePermission):\n    \"\"\"\n    Allow any access.\n    This isn't strictly required, since you could use an empty\n    permission_classes list, but it's useful because it makes the intention\n    more explicit.\n    \"\"\"\n    def has_permission(self, request, view):\n        return True\n```\n \n즉, APIView는 기존의 django 에서 체크하고 있는 csrf 공격방어에 대한 인증을 제외하고 따로 인증절차를 진행하게되는데, 인증 유저를 익명유저로 설정하여 유저에 대한 권한검사를 하지 않고 default로 설정이 된 권한체크 클래스로 검사를 한다.\nAllowAny는 접근 허용여부를 모두 True로 반환하여 접근에 대해 유효하다고 판단하여 csrf토큰 없이 요청 수행이 가능한 것이다.\n데이터를 모두 처리하고 나서의 응답값은 Response 객체를 반환함으로서 처리한다.\n\n2.View ↔ ajax (post, get)\najax를 통해 View class에 메소드를 호출하는 경우는 많지는 않았는데, 이유는 굳이 ajax로 호출하지 않아도 할 수 있는 방법들이 있었기 때문이었다.\n하지만 종종 사용해야할 경우가 있었는데, 이를테면 내부 검색창에서 검색결과를 내부 포멧에 맞게 내용을 채워줘야 하는데 그 template가 별도의 파일로 있는 경우였다.\n  \n  \n- template.html\n\n~~~\n$(\"#searchFrom\").submit(function () {\n    var user_id = $(\"input[name=user_id]\").val();\n \n    $.ajax({\n        url: \"{% url 'user:search' %}\",\n        type: \"POST\",\n        data: {\n            \"csrfmiddlewaretoken\": \"\\{\\{ csrf_token \\}\\}\",\n            'user_id': user_id,\n        },\n        success: function (response) {\n            $('#user_list tbody').html(response);\n        },\n        error: function (err) {\n            console.log(err);\n        }\n    });\n \n    return false;\n});\n~~~\n\n{% raw %}\n위의 tempalate에서 입력받은 데이터를 통해 ajax로 호출을 한다. 이 때 호출되는 class는 View를 상속받은 class 이다. form의 submit으로 호출을 한 경우인데 form에 {% csrf_token %}이 들어가있기 때문에 post요청을 날릴 경우엔 403이 떨어진다.(get요청은 안넣어도 상관없다.)\n이런 경우를 방지하기 위해 data필드에 csrf token 을 넣어준다.\n{% endraw %}\n\n~~~\n\"csrfmiddlewaretoken\": \"{{ csrf_token }}\",\n~~~\n\n요청을 받고 데이터를 만들고 나면 TemplateResponse를 사용하여 분리되어 생성된 페이지를 반환하게 된다. \n  \n- view.py\n\n```\nclass UserSearchView(View):\n    def post(self, request):\n        user_id = request.POST.get('user_id')\n        user_list = service.search_user(user_id)\n        context = {\n            'user_list': user_list\n        }\n        return TemplateResponse(request, 'user/user_list.html', context)\n```\n\n다시 template에서는 넘어온 html덩어리를 미리 정의해둔 위치에 그대로 붙여줌으로서 화면을 다시 그리지 않고, 필요한 부분만 넣어줄 수 있다. \n(APIView등을 통해 데이터만 받아와 다시 그리는 방법도 있지만 성격이 맞지 않는다고 생각하였고, 일반 호출을 하게 되면 페이지로딩을 다시 하므로 그 방법은 피했다)\n\n\n","slug":"django-ajax","published":1,"updated":"2018-04-15T08:06:55.798Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjq98sopg00068ghh02qeqedo","content":"<p>View에서 get, post요청을 할 때 template단에서 ajax요청을 날려야할 때가 있다.<br>\nAPIVIew, View 두개의 경우를 살펴보자.<br>\n1.APIView ↔ ajax (post, get)<br>\n(post의 케이스로 설명을 하였지만 get도 동일한 방식이다.)<br>\n가장 빈번하게 사용하는 케이스이다. template 에서 버튼을 눌러 요청을 ajax로 날려 결과값을 받아와서 전체 화면을 다시 그리지 않고 필요한 부분만 갱신해줄 수 있다.</p>\n<ul>\n<li>template.html</li>\n</ul>\n<figure class=\"highlight lua\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$.ajax(&#123;</span><br><span class=\"line\">    url: <span class=\"string\">\"&#123;% url 'request:url' %&#125;\"</span>,</span><br><span class=\"line\">    <span class=\"built_in\">type</span>: <span class=\"string\">'POST'</span>,</span><br><span class=\"line\">    data: &#123;</span><br><span class=\"line\">        <span class=\"string\">'user_id'</span>: user_id</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    success: <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"params\">(response)</span></span> &#123;</span><br><span class=\"line\">        // TODO: <span class=\"keyword\">do</span> something.</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    <span class=\"built_in\">error</span>: <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"params\">(err)</span></span> &#123;</span><br><span class=\"line\">        console.<span class=\"built_in\">log</span>(err);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<ul>\n<li><a href=\"http://url.py\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">url.py</a></li>\n</ul>\n <figure class=\"highlight awk\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">url(<span class=\"string\">r'^request/url$'</span>, views.TestView.as_view(), name=<span class=\"string\">'url'</span>),</span><br></pre></td></tr></table></figure>\n<ul>\n<li><a href=\"http://view.py\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">view.py</a></li>\n</ul>\n<figure class=\"highlight ruby\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">TestView</span>(<span class=\"title\">APIView</span>):</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">post</span><span class=\"params\">(<span class=\"keyword\">self</span>, request)</span></span><span class=\"symbol\">:</span></span><br><span class=\"line\">        user_id = request.POST.get(<span class=\"string\">'user_id'</span>)</span><br><span class=\"line\">      <span class=\"comment\"># do something</span></span><br><span class=\"line\">       <span class=\"keyword\">return</span> Response()</span><br></pre></td></tr></table></figure>\n<p>View class를 상속받고 post 메소드로 받는다면 ajax 요청시 csrf 토큰이 없다고 하면서 403에러가 발생한다.<br>\n이를 해결해주기 위해 APIView를 상속받아서 처리하면 csrf 인증을 피해갈 수 있다.  (피해간다기보단 이미 인증이 되어있는 요청이라고 판단하는 것이지만)<br>\n이는 APIView의 as_view() 메소드를 보면 알 수 있는데</p>\n<ul>\n<li>api_view.py</li>\n</ul>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">as_view</span><span class=\"params\">(cls, **initkwargs)</span>:</span></span><br><span class=\"line\">    <span class=\"string\">\"\"\"</span></span><br><span class=\"line\"><span class=\"string\">    Store the original class on the view function.</span></span><br><span class=\"line\"><span class=\"string\"> </span></span><br><span class=\"line\"><span class=\"string\">    This allows us to discover information about the view when we do URL</span></span><br><span class=\"line\"><span class=\"string\">    reverse lookups.  Used for breadcrumb generation.</span></span><br><span class=\"line\"><span class=\"string\">    \"\"\"</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> isinstance(getattr(cls, <span class=\"string\">'queryset'</span>, <span class=\"keyword\">None</span>), models.query.QuerySet):</span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">force_evaluation</span><span class=\"params\">()</span>:</span></span><br><span class=\"line\">            <span class=\"keyword\">raise</span> RuntimeError(</span><br><span class=\"line\">                <span class=\"string\">'Do not evaluate the `.queryset` attribute directly, '</span></span><br><span class=\"line\">                <span class=\"string\">'as the result will be cached and reused between requests. '</span></span><br><span class=\"line\">                <span class=\"string\">'Use `.all()` or call `.get_queryset()` instead.'</span></span><br><span class=\"line\">            )</span><br><span class=\"line\">        cls.queryset._fetch_all = force_evaluation</span><br><span class=\"line\">        cls.queryset._result_iter = force_evaluation  <span class=\"comment\"># Django &lt;= 1.5</span></span><br><span class=\"line\"> </span><br><span class=\"line\">    view = super(APIView, cls).as_view(**initkwargs)</span><br><span class=\"line\">    view.cls = cls</span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"comment\"># <span class=\"doctag\">Note:</span> session based authentication is explicitly CSRF validated,</span></span><br><span class=\"line\">    <span class=\"comment\"># all other authentication is CSRF exempt.</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> csrf_exempt(view)</span><br></pre></td></tr></table></figure>\n<p>마지막 라인에 csrf_exempt로 view를 감싸준다. 이는 해당 API요청이 csrf 인증이 되어있다고 명시해주는 것이다.<br>\n그리고, 내부로 파고 들어가면  APIView에서 authentication_classes = api_settings.DEFAULT_AUTHENTICATION_CLASSES 로 설정이 되어있는데, restframework의 setting을 살펴보면 아래와 같이 정의가 되어있음을 알 수 있다.</p>\n<ul>\n<li>api_settings.py</li>\n</ul>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">'DEFAULT_AUTHENTICATION_CLASSES'</span>: (</span><br><span class=\"line\">    <span class=\"string\">'rest_framework.authentication.SessionAuthentication'</span>,</span><br><span class=\"line\">    <span class=\"string\">'rest_framework.authentication.BasicAuthentication'</span></span><br><span class=\"line\">),</span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"comment\"># Authentication</span></span><br><span class=\"line\"><span class=\"string\">'UNAUTHENTICATED_USER'</span>: <span class=\"string\">'django.contrib.auth.models.AnonymousUser'</span>,</span><br><span class=\"line\"><span class=\"string\">'UNAUTHENTICATED_TOKEN'</span>: <span class=\"keyword\">None</span>,</span><br></pre></td></tr></table></figure>\n<p>인증 처리를 rest_framework의 SessionAuthentication으로 하겠다는 내용과 인증 유저를 AnonymousUser 로 설정을 해준다.<br>\n기존의 인증절차에서 default인증 객체를 검사하게 되는데, 이 때 user객체의 active를 검사할 때 이 객체가 유효하지 않으면 unauthenticated_user로 AnonymousUser객체를 생성하게 된다. 접근 허용 체크를 할 때는 APIView에 정의된 permission class로 체크를 하는데 아래와 같다.</p>\n<ul>\n<li>api_settings.py</li>\n</ul>\n<figure class=\"highlight gradle\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">'DEFAULT_PERMISSION_CLASSES'</span>: (</span><br><span class=\"line\">    <span class=\"string\">'rest_framework.permissions.AllowAny'</span>,</span><br><span class=\"line\">),</span><br></pre></td></tr></table></figure>\n<p>AllowAny Class는 permission요청에 대해 무조건 True를 반환해주므로, APIView의 check_permissions 메소드에서 권한 체크를 할 때 권한이 있다고 판단을 한다.</p>\n<ul>\n<li><a href=\"http://permissions.py\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">permissions.py</a></li>\n</ul>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">AllowAny</span><span class=\"params\">(BasePermission)</span>:</span></span><br><span class=\"line\">    <span class=\"string\">\"\"\"</span></span><br><span class=\"line\"><span class=\"string\">    Allow any access.</span></span><br><span class=\"line\"><span class=\"string\">    This isn't strictly required, since you could use an empty</span></span><br><span class=\"line\"><span class=\"string\">    permission_classes list, but it's useful because it makes the intention</span></span><br><span class=\"line\"><span class=\"string\">    more explicit.</span></span><br><span class=\"line\"><span class=\"string\">    \"\"\"</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">has_permission</span><span class=\"params\">(self, request, view)</span>:</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">True</span></span><br></pre></td></tr></table></figure>\n<p>즉, APIView는 기존의 django 에서 체크하고 있는 csrf 공격방어에 대한 인증을 제외하고 따로 인증절차를 진행하게되는데, 인증 유저를 익명유저로 설정하여 유저에 대한 권한검사를 하지 않고 default로 설정이 된 권한체크 클래스로 검사를 한다.<br>\nAllowAny는 접근 허용여부를 모두 True로 반환하여 접근에 대해 유효하다고 판단하여 csrf토큰 없이 요청 수행이 가능한 것이다.<br>\n데이터를 모두 처리하고 나서의 응답값은 Response 객체를 반환함으로서 처리한다.</p>\n<p>2.View ↔ ajax (post, get)<br>\najax를 통해 View class에 메소드를 호출하는 경우는 많지는 않았는데, 이유는 굳이 ajax로 호출하지 않아도 할 수 있는 방법들이 있었기 때문이었다.<br>\n하지만 종종 사용해야할 경우가 있었는데, 이를테면 내부 검색창에서 검색결과를 내부 포멧에 맞게 내용을 채워줘야 하는데 그 template가 별도의 파일로 있는 경우였다.</p>\n<ul>\n<li>template.html</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$(<span class=\"string\">\"#searchFrom\"</span>).submit(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> user_id = $(<span class=\"string\">\"input[name=user_id]\"</span>).val();</span><br><span class=\"line\"> </span><br><span class=\"line\">    $.ajax(&#123;</span><br><span class=\"line\">        url: <span class=\"string\">\"&#123;% url 'user:search' %&#125;\"</span>,</span><br><span class=\"line\">        type: <span class=\"string\">\"POST\"</span>,</span><br><span class=\"line\">        data: &#123;</span><br><span class=\"line\">            <span class=\"string\">\"csrfmiddlewaretoken\"</span>: <span class=\"string\">\"\\&#123;\\&#123; csrf_token \\&#125;\\&#125;\"</span>,</span><br><span class=\"line\">            <span class=\"string\">'user_id'</span>: user_id,</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        success: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">response</span>) </span>&#123;</span><br><span class=\"line\">            $(<span class=\"string\">'#user_list tbody'</span>).html(response);</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        error: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">err</span>) </span>&#123;</span><br><span class=\"line\">            <span class=\"built_in\">console</span>.log(err);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n위의 tempalate에서 입력받은 데이터를 통해 ajax로 호출을 한다. 이 때 호출되는 class는 View를 상속받은 class 이다. form의 submit으로 호출을 한 경우인데 form에 {% csrf_token %}이 들어가있기 때문에 post요청을 날릴 경우엔 403이 떨어진다.(get요청은 안넣어도 상관없다.)\n이런 경우를 방지하기 위해 data필드에 csrf token 을 넣어준다.\n\n<figure class=\"highlight gradle\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">\"csrfmiddlewaretoken\"</span>: <span class=\"string\">\"&#123;&#123; csrf_token &#125;&#125;\"</span>,</span><br></pre></td></tr></table></figure>\n<p>요청을 받고 데이터를 만들고 나면 TemplateResponse를 사용하여 분리되어 생성된 페이지를 반환하게 된다.</p>\n<ul>\n<li><a href=\"http://view.py\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">view.py</a></li>\n</ul>\n<figure class=\"highlight ruby\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">UserSearchView</span>(<span class=\"title\">View</span>):</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">post</span><span class=\"params\">(<span class=\"keyword\">self</span>, request)</span></span><span class=\"symbol\">:</span></span><br><span class=\"line\">        user_id = request.POST.get(<span class=\"string\">'user_id'</span>)</span><br><span class=\"line\">        user_list = service.search_user(user_id)</span><br><span class=\"line\">        context = &#123;</span><br><span class=\"line\">            <span class=\"string\">'user_list'</span>: user_list</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> TemplateResponse(request, <span class=\"string\">'user/user_list.html'</span>, context)</span><br></pre></td></tr></table></figure>\n<p>다시 template에서는 넘어온 html덩어리를 미리 정의해둔 위치에 그대로 붙여줌으로서 화면을 다시 그리지 않고, 필요한 부분만 넣어줄 수 있다.<br>\n(APIView등을 통해 데이터만 받아와 다시 그리는 방법도 있지만 성격이 맞지 않는다고 생각하였고, 일반 호출을 하게 되면 페이지로딩을 다시 하므로 그 방법은 피했다)</p>\n","site":{"data":{}},"excerpt":"","more":"<p>View에서 get, post요청을 할 때 template단에서 ajax요청을 날려야할 때가 있다.<br>\nAPIVIew, View 두개의 경우를 살펴보자.<br>\n1.APIView ↔ ajax (post, get)<br>\n(post의 케이스로 설명을 하였지만 get도 동일한 방식이다.)<br>\n가장 빈번하게 사용하는 케이스이다. template 에서 버튼을 눌러 요청을 ajax로 날려 결과값을 받아와서 전체 화면을 다시 그리지 않고 필요한 부분만 갱신해줄 수 있다.</p>\n<ul>\n<li>template.html</li>\n</ul>\n<figure class=\"highlight lua\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$.ajax(&#123;</span><br><span class=\"line\">    url: <span class=\"string\">\"&#123;% url 'request:url' %&#125;\"</span>,</span><br><span class=\"line\">    <span class=\"built_in\">type</span>: <span class=\"string\">'POST'</span>,</span><br><span class=\"line\">    data: &#123;</span><br><span class=\"line\">        <span class=\"string\">'user_id'</span>: user_id</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    success: <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"params\">(response)</span></span> &#123;</span><br><span class=\"line\">        // TODO: <span class=\"keyword\">do</span> something.</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    <span class=\"built_in\">error</span>: <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"params\">(err)</span></span> &#123;</span><br><span class=\"line\">        console.<span class=\"built_in\">log</span>(err);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<ul>\n<li><a href=\"http://url.py\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">url.py</a></li>\n</ul>\n <figure class=\"highlight awk\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">url(<span class=\"string\">r'^request/url$'</span>, views.TestView.as_view(), name=<span class=\"string\">'url'</span>),</span><br></pre></td></tr></table></figure>\n<ul>\n<li><a href=\"http://view.py\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">view.py</a></li>\n</ul>\n<figure class=\"highlight ruby\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">TestView</span>(<span class=\"title\">APIView</span>):</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">post</span><span class=\"params\">(<span class=\"keyword\">self</span>, request)</span></span><span class=\"symbol\">:</span></span><br><span class=\"line\">        user_id = request.POST.get(<span class=\"string\">'user_id'</span>)</span><br><span class=\"line\">      <span class=\"comment\"># do something</span></span><br><span class=\"line\">       <span class=\"keyword\">return</span> Response()</span><br></pre></td></tr></table></figure>\n<p>View class를 상속받고 post 메소드로 받는다면 ajax 요청시 csrf 토큰이 없다고 하면서 403에러가 발생한다.<br>\n이를 해결해주기 위해 APIView를 상속받아서 처리하면 csrf 인증을 피해갈 수 있다.  (피해간다기보단 이미 인증이 되어있는 요청이라고 판단하는 것이지만)<br>\n이는 APIView의 as_view() 메소드를 보면 알 수 있는데</p>\n<ul>\n<li>api_view.py</li>\n</ul>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">as_view</span><span class=\"params\">(cls, **initkwargs)</span>:</span></span><br><span class=\"line\">    <span class=\"string\">\"\"\"</span></span><br><span class=\"line\"><span class=\"string\">    Store the original class on the view function.</span></span><br><span class=\"line\"><span class=\"string\"> </span></span><br><span class=\"line\"><span class=\"string\">    This allows us to discover information about the view when we do URL</span></span><br><span class=\"line\"><span class=\"string\">    reverse lookups.  Used for breadcrumb generation.</span></span><br><span class=\"line\"><span class=\"string\">    \"\"\"</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> isinstance(getattr(cls, <span class=\"string\">'queryset'</span>, <span class=\"keyword\">None</span>), models.query.QuerySet):</span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">force_evaluation</span><span class=\"params\">()</span>:</span></span><br><span class=\"line\">            <span class=\"keyword\">raise</span> RuntimeError(</span><br><span class=\"line\">                <span class=\"string\">'Do not evaluate the `.queryset` attribute directly, '</span></span><br><span class=\"line\">                <span class=\"string\">'as the result will be cached and reused between requests. '</span></span><br><span class=\"line\">                <span class=\"string\">'Use `.all()` or call `.get_queryset()` instead.'</span></span><br><span class=\"line\">            )</span><br><span class=\"line\">        cls.queryset._fetch_all = force_evaluation</span><br><span class=\"line\">        cls.queryset._result_iter = force_evaluation  <span class=\"comment\"># Django &lt;= 1.5</span></span><br><span class=\"line\"> </span><br><span class=\"line\">    view = super(APIView, cls).as_view(**initkwargs)</span><br><span class=\"line\">    view.cls = cls</span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"comment\"># <span class=\"doctag\">Note:</span> session based authentication is explicitly CSRF validated,</span></span><br><span class=\"line\">    <span class=\"comment\"># all other authentication is CSRF exempt.</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> csrf_exempt(view)</span><br></pre></td></tr></table></figure>\n<p>마지막 라인에 csrf_exempt로 view를 감싸준다. 이는 해당 API요청이 csrf 인증이 되어있다고 명시해주는 것이다.<br>\n그리고, 내부로 파고 들어가면  APIView에서 authentication_classes = api_settings.DEFAULT_AUTHENTICATION_CLASSES 로 설정이 되어있는데, restframework의 setting을 살펴보면 아래와 같이 정의가 되어있음을 알 수 있다.</p>\n<ul>\n<li>api_settings.py</li>\n</ul>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">'DEFAULT_AUTHENTICATION_CLASSES'</span>: (</span><br><span class=\"line\">    <span class=\"string\">'rest_framework.authentication.SessionAuthentication'</span>,</span><br><span class=\"line\">    <span class=\"string\">'rest_framework.authentication.BasicAuthentication'</span></span><br><span class=\"line\">),</span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"comment\"># Authentication</span></span><br><span class=\"line\"><span class=\"string\">'UNAUTHENTICATED_USER'</span>: <span class=\"string\">'django.contrib.auth.models.AnonymousUser'</span>,</span><br><span class=\"line\"><span class=\"string\">'UNAUTHENTICATED_TOKEN'</span>: <span class=\"keyword\">None</span>,</span><br></pre></td></tr></table></figure>\n<p>인증 처리를 rest_framework의 SessionAuthentication으로 하겠다는 내용과 인증 유저를 AnonymousUser 로 설정을 해준다.<br>\n기존의 인증절차에서 default인증 객체를 검사하게 되는데, 이 때 user객체의 active를 검사할 때 이 객체가 유효하지 않으면 unauthenticated_user로 AnonymousUser객체를 생성하게 된다. 접근 허용 체크를 할 때는 APIView에 정의된 permission class로 체크를 하는데 아래와 같다.</p>\n<ul>\n<li>api_settings.py</li>\n</ul>\n<figure class=\"highlight gradle\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">'DEFAULT_PERMISSION_CLASSES'</span>: (</span><br><span class=\"line\">    <span class=\"string\">'rest_framework.permissions.AllowAny'</span>,</span><br><span class=\"line\">),</span><br></pre></td></tr></table></figure>\n<p>AllowAny Class는 permission요청에 대해 무조건 True를 반환해주므로, APIView의 check_permissions 메소드에서 권한 체크를 할 때 권한이 있다고 판단을 한다.</p>\n<ul>\n<li><a href=\"http://permissions.py\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">permissions.py</a></li>\n</ul>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">AllowAny</span><span class=\"params\">(BasePermission)</span>:</span></span><br><span class=\"line\">    <span class=\"string\">\"\"\"</span></span><br><span class=\"line\"><span class=\"string\">    Allow any access.</span></span><br><span class=\"line\"><span class=\"string\">    This isn't strictly required, since you could use an empty</span></span><br><span class=\"line\"><span class=\"string\">    permission_classes list, but it's useful because it makes the intention</span></span><br><span class=\"line\"><span class=\"string\">    more explicit.</span></span><br><span class=\"line\"><span class=\"string\">    \"\"\"</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">has_permission</span><span class=\"params\">(self, request, view)</span>:</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">True</span></span><br></pre></td></tr></table></figure>\n<p>즉, APIView는 기존의 django 에서 체크하고 있는 csrf 공격방어에 대한 인증을 제외하고 따로 인증절차를 진행하게되는데, 인증 유저를 익명유저로 설정하여 유저에 대한 권한검사를 하지 않고 default로 설정이 된 권한체크 클래스로 검사를 한다.<br>\nAllowAny는 접근 허용여부를 모두 True로 반환하여 접근에 대해 유효하다고 판단하여 csrf토큰 없이 요청 수행이 가능한 것이다.<br>\n데이터를 모두 처리하고 나서의 응답값은 Response 객체를 반환함으로서 처리한다.</p>\n<p>2.View ↔ ajax (post, get)<br>\najax를 통해 View class에 메소드를 호출하는 경우는 많지는 않았는데, 이유는 굳이 ajax로 호출하지 않아도 할 수 있는 방법들이 있었기 때문이었다.<br>\n하지만 종종 사용해야할 경우가 있었는데, 이를테면 내부 검색창에서 검색결과를 내부 포멧에 맞게 내용을 채워줘야 하는데 그 template가 별도의 파일로 있는 경우였다.</p>\n<ul>\n<li>template.html</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$(<span class=\"string\">\"#searchFrom\"</span>).submit(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> user_id = $(<span class=\"string\">\"input[name=user_id]\"</span>).val();</span><br><span class=\"line\"> </span><br><span class=\"line\">    $.ajax(&#123;</span><br><span class=\"line\">        url: <span class=\"string\">\"&#123;% url 'user:search' %&#125;\"</span>,</span><br><span class=\"line\">        type: <span class=\"string\">\"POST\"</span>,</span><br><span class=\"line\">        data: &#123;</span><br><span class=\"line\">            <span class=\"string\">\"csrfmiddlewaretoken\"</span>: <span class=\"string\">\"\\&#123;\\&#123; csrf_token \\&#125;\\&#125;\"</span>,</span><br><span class=\"line\">            <span class=\"string\">'user_id'</span>: user_id,</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        success: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">response</span>) </span>&#123;</span><br><span class=\"line\">            $(<span class=\"string\">'#user_list tbody'</span>).html(response);</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        error: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">err</span>) </span>&#123;</span><br><span class=\"line\">            <span class=\"built_in\">console</span>.log(err);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n위의 tempalate에서 입력받은 데이터를 통해 ajax로 호출을 한다. 이 때 호출되는 class는 View를 상속받은 class 이다. form의 submit으로 호출을 한 경우인데 form에 {% csrf_token %}이 들어가있기 때문에 post요청을 날릴 경우엔 403이 떨어진다.(get요청은 안넣어도 상관없다.)\n이런 경우를 방지하기 위해 data필드에 csrf token 을 넣어준다.\n\n<figure class=\"highlight gradle\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">\"csrfmiddlewaretoken\"</span>: <span class=\"string\">\"&#123;&#123; csrf_token &#125;&#125;\"</span>,</span><br></pre></td></tr></table></figure>\n<p>요청을 받고 데이터를 만들고 나면 TemplateResponse를 사용하여 분리되어 생성된 페이지를 반환하게 된다.</p>\n<ul>\n<li><a href=\"http://view.py\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">view.py</a></li>\n</ul>\n<figure class=\"highlight ruby\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">UserSearchView</span>(<span class=\"title\">View</span>):</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">post</span><span class=\"params\">(<span class=\"keyword\">self</span>, request)</span></span><span class=\"symbol\">:</span></span><br><span class=\"line\">        user_id = request.POST.get(<span class=\"string\">'user_id'</span>)</span><br><span class=\"line\">        user_list = service.search_user(user_id)</span><br><span class=\"line\">        context = &#123;</span><br><span class=\"line\">            <span class=\"string\">'user_list'</span>: user_list</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> TemplateResponse(request, <span class=\"string\">'user/user_list.html'</span>, context)</span><br></pre></td></tr></table></figure>\n<p>다시 template에서는 넘어온 html덩어리를 미리 정의해둔 위치에 그대로 붙여줌으로서 화면을 다시 그리지 않고, 필요한 부분만 넣어줄 수 있다.<br>\n(APIView등을 통해 데이터만 받아와 다시 그리는 방법도 있지만 성격이 맞지 않는다고 생각하였고, 일반 호출을 하게 되면 페이지로딩을 다시 하므로 그 방법은 피했다)</p>\n"},{"title":"Django에서 SSO하기","catalog":true,"date":"2016-05-06T07:59:58.000Z","subtitle":null,"header-img":"/img/header_img/bg.png","_content":"\n회사에서 필요에 의해 [Single Sign On](https://ko.wikipedia.org/wiki/%ED%86%B5%ED%95%A9_%EC%9D%B8%EC%A6%9D, \"Single Sign On\")을 구현해야 할 일이 있었다. 3개의 독립된 사이트가 있었고, 각자 로그인을 따로 해야 한다는 점이 사용자 입장에서는 번거로운 일이 될 수 있다는 이유에서 였다. \n\n 3개의 사이트는 하나의 유저테이블을 바라보고 있었기 때문에 충분히 합당한 이유였다. 하지만 django에서 제공하는 기본 유저 테이블을 사용하지 않기 때문에 찾아봤었던 다른 인증 툴들은 그대로 사용하기 까다로워 보였다. 내가 구현해야 하는 상황에는 몇가지 제약사항이 있었다.  \n  \n1. 로그인을 시도할 때 기존에 제공되는 auth_user 테이블이 아닌 <U>별도의 user 테이블을 사용하고 있다.</U>\n  \n2. 기존에 제공되는 user 모델을 사용하지 않기 때문에 <U>reatframework 에서 기존에 제공하는 인증방식을 그대로 사용할 수 없었다.</U>\n  \n3. 이미 테이블이 존재하고 <U>django 프로젝트에서 migration 을 할 수 없는 상황이다.</U> 기존에 생성되어 있는 테이블들의 구성을 변경할 수는 있지만 그 과정과 절차가 까다롭고 (회사의 사정에 의해), 외래키를 사용하지 않았기 때문에 모델과 테이블간의 100% 싱크가 맞지 않는 상황이었다.\n  \n4. 위와 같은 이유로 찾아봤었던 [MamaCAS](https://github.com/jbittel/django-mama-cas, \"MamaCas\") 같은 외부 인증툴을 사용할 수 없었다. (migration을 할 수 없었기에 인증을 위해 별도의 테이블을 생성하기 까다로운 상황이었다.)\n  \n3개의 프로젝트들이 출시가 얼마 남지 않은 상황이고, 인증을 위해서 별도의 커다란 작업이 있는 것은 별로 좋은 선택이 아니였다. 물론 외부의 다른 툴들을 이용할 수도 있었지만, 단순 인증을 위해 외부툴을 사용하기엔 부담스러운 부분이 있었고, 볼륨을 크게 잡고 싶지 않았다. \n  \n여러 방법을 찾아보면서 몇가지 아이디어가 나왔었다.\n  \n1. [redis](https://redis.io/, \"redis\") 를 이용해서 인증 정보를 저장하는 방식\n  \n2. [jwt](https://jwt.io/, \"jwt\")를 이용해서 javascript 내부에서 localStorage 에 인증 정보를 저장하는 방식\n  \n3. cookie에 저장하는 방식\n  \n나는 일단 1번의 redis는 제외하기로 했다. 이미 각각의 프로젝트에서 redis를 사용하고 있었고, 인증을 위해 별도의 redis를 띄우는게 번거롭다고 생각했다. 그리고 2번의 localStorage 방식은 javascript에서 ajax통신을 각 페이지별로 날려 유효한 인증을 판단하는 방식이었는데, django 단에서 각 request마다 헤더에 인증 정보를 넣기가 까다로웠다. (하지만 jwt로 토큰을 암호화 하는건 괜찮은 방법이라 생각했다.) 3번의 cookie 방식은 별도의 작업 없이 구현이 가능했지만 3개의 사이트가 같은 메인 도메인 하에 있어야 가능했었다. 어차피 모든 사이트가 회사 내부에서 사용할 목적으로 만들어 지고 있는 프로젝트 였고 같은 메인 도메인만 사용하면 되었기 때문에 나는 3번째의 방법을 사용하기로 했다. \n  \n서론이 길었지만.. 그리하여 jwt와 cookie를 이용해서 sso를 구현해 보기로 했다.\n  \n여러 사이트가 있고 각각 로그인(유저 인증)이 필요하고 기능 마다 해당 유저가 접근할 수 있는(허가) 기능이 필요하다. \n  \n(single sign on 을 하다보니 authentication 과 permission 처리가 필요했다..)\n  \n여러 개의 사이트가 공유하는 유저 정보가 있고, 이 정보로 로그인을 하기 때문에 모든 사이트에서 한번의 로그인을 하면 되는 기능이 필요했다.추가적으로 각 사이트 별로는 각자의 허가 정보가 있으므로 이 정보는 공유하지 않고 각자 구현한다. (템플릿만 제공)\n  \n한마디로 요약하면 쿠키에 암호화된 토큰 정보를 도메인이 같은 사이트들끼리 로그인 정보를 공유를 해서 사용하는 방법이다. \n  \n## 예상 시나리오\n  \nalpha.mysite.com, beta.mysite.com, charlie.mysite.com 3개의 사이트가 있다.  \nbeta 에서 로그인을 하고 charlie 사이트에 접속할 경우 이미 로그인이 되어 있다.  \n3개의 사이트는 각자 permission 이 따로 존재한다.  \nalpha 에서 로그아웃을 할 경우, 나머지 사이트에서도 모두 로그아웃이 된다.  \n로그인 정보가 만료되었을 경우에도 로그아웃 처리된다.  \n  \n## 시나리오 순서 별 설명\n\n1. 로그인 시 : <U>jwt token</U> 을 발급해서 request cookie에 저장한다. (이 때, <U>cookie</U> 의 domain은 main domain 값을 넣어준다.<mysite.com>)  \n2. 인증이 필요한 페이지에 접속할 경우  \nrest framework 의 <U>authentication</U> class 에서 cookie 에 저장되어 있는 token 값의 유효성을 검사한다.  \nrest framework 의 <U>permission</U> class 에서 해당 유저가 기능에 접근 허가 여부를 판단한다.  \n3. 로그아웃 시 : cookie 의 token 값을 지워준다.  \n4. 추가 정보  \n\t* 인증에 실패한 경우 : cookie 값을 삭제하고 login 페이지로 보낸다.  \n\t* 기능 접근 허가가 거부된 경우 : block page 를 표시한다.  \n\t* 토큰이 만료된 경우 : cookie 값을 삭제하고 login 페이지로 보낸다.    \n5. 제약사항  \n\t* 메인 도메인이 동일해야한다.  \n\t* permission 정보는 공유하지 않기 때문에 각자 사이트에서 구현해야 한다.  \n\n## 환경 설정\n\n```\npython 3.4.3\ndjango 1.8.4\ndjangorestframework 3.3.0\n```\n  \n하나씩 시작해보자.  \n  \n### 패키지 추가하기\n\n```\n$ pip install djangorestframework-jwt\n```\n\n### 로그인 하기\n\n#### 토큰 생성하기\n\n유저 정보가 맞을 경우 이 정보를 토대로 jwt token을 생성해준다.  \njwt_util.py   \n \n```\nfrom calendar import timegm\nfrom datetime import datetime\n \nimport jwt\nfrom rest_framework_jwt.settings import api_settings\n \nfrom user.models.CustomUser import CustomUser\n \n \ndef obtain_token(user: CustomUser):\n    jwt_payload_handler = api_settings.JWT_PAYLOAD_HANDLER\n    jwt_encode_handler = api_settings.JWT_ENCODE_HANDLER\n \n    payload = jwt_payload_handler(user)\n \n    # Include original issued at time for a brand new token,\n    # to allow token refresh\n    if api_settings.JWT_ALLOW_REFRESH:\n        payload['orig_iat'] = timegm(\n            datetime.utcnow().utctimetuple()\n        )\n \n    return jwt_encode_handler(payload)\n```\n\njwt 변수들에 대한 자세한 설정은 Rest Framework JWT 에서 확인 할 수 있다. 그리고 default 로 설정된 변수들을 재선언 하고 싶다면 setting 에 해주면 된다.  \n\nsettings.py  \n\n``` \nJWT_AUTH = {\n    'JWT_EXPIRATION_DELTA': datetime.timedelta(hours=24),\n}\n```\n\n#### 쿠키에 저장하기\n\n사용자가 입력한 아이디와 암호가 맞을 경우 이 정보를 cookie 에 저장을 한다. 저장할 때 domain option 을 main domain(mysite.com) 로 설정해준다. domain 설정을 해주지 않을 경우 다른 사이트에서 쿠키정보를 공유할 수 없다.   \n  \n  \nview.py\n  \n``` \nclass LoginView(View):\n \n    def get(self, request):\n        return TemplateResponse(request, 'account/login.html')\n \n    def post(self, request):\n        username = request.POST.get('username')\n        password = request.POST.get('password')\n \n        try:\n            admin = CustomUser.objects.get(username=username)\n            # 유저 암호 검사하기.\n            if security.matches_password(password, admin.password):\n                # obtain jwt token\n                token = obtain_token(admin)\n \n                # set cookie\n                response = HttpResponseRedirect(reverse('root'))\n                response.set_cookie(key='token', value=token, domain=settings.COOKIE_DOMAIN)\n                return response\n            else:\n                context = {\n                    'error': '비밀번호가 일치하지 않습니다.'\n                }\n        except TAdmin.DoesNotExist:\n            context = {\n                'error': '존재하지 않는 ID입니다.'\n            }\n \n        return TemplateResponse(request, 'account/login.html', context)\n}\n```\n  \n공통으로 사용할 메인 도메인 이름은 각 사이트 마다 통일 해줘야 한다.  \n\nsettings.py  \n\n``` \nCOOKIE_DOMAIN = 'mysite.com'\n```\n\n쿠키에 토큰 값을 저장 했으므로 이제 각 사이트에 로그인 되었다고 할 수 있는 첫번 째 단계는 달성했다.  \n\n#### 페이지 인증정보 확인하기\n로그인이 되어 있어야 접근할 수 있는 페이지의 경우 로그인 정보를 확인한 후에 정보를 로드한다. RestFramework 에서 제공하는 APIView 를 사용해서 인증 정보를 확인한다.  \n\nview.py\n\n```\nclass RootView(APIView):\n    authentication_classes = (CustomAuthentication, )\n    def get(self, request):\n        \"\"\"\n        :param request:\n        :return:\n        \"\"\"\n        redirect_url = \"/home\"\n        return HttpResponseRedirect(redirect_url)\n\n}\n```\n\n 여기서 authentication class 를 명시적으로 선언해주었는데, 모든 APIView(인증과 허가가 필요한 페이지의 경우) 에 적용될 수 있도록 settings 에 선언해줄 수 있다.   \n\n(인증 실패나 허가 요청 실패시 처리해줄 수 있는 핸들러도 미리 추가해놓자.)  \n\nsettings.py  \n\n``` \nREST_FRAMEWORK = {\n    'DEFAULT_AUTHENTICATION_CLASSES': (\n        'common.utils.authentication.CustomAuthentication',\n    ),\n    'EXCEPTION_HANDLER': 'common.utils.custom_exception_handler.custom_exception_handler'\n}\n```\n\n인증 확인은 쿠키에 저장되어 있는 토큰 정보로 확인한다. 토큰으로 정상적인 유저를 가져올 수 있다면 유효한 유저라고 판단한다.  \n\nauthentication.py  \n\n```\nfrom rest_framework import authentication\n \nfrom common.utils.jwt_util import obtain_user\n \n \nclass CustomAuthentication(authentication.BaseAuthentication):\n    def authenticate(self, request):\n        \"\"\"\n        쿠키에 저장되어 있는 token 값으로 유저를 가져옵니다. 가져오는 상황에서 예외가 발생할 수 있으며 정상적으로 가져온 경우에는 인증된 유저라고 판단합니다.\n        :param request:\n        :return:\n        \"\"\"\n        token = request.COOKIES.get('token', None)\n        user = obtain_user(token)\n        return (user, None)\n```\n\n쿠키에 저장되어 있는 토큰을 decode 하여 유효한 정보인지를 판단한다.  \n\njwt_util.py  \n  \n``` \ndef obtain_user(token: str):\n    \"\"\"\n    payload = {'username': 'adm001', 'email': 'test@mysite.com', 'user_id': 1, 'exp': 1462187582}\n    :param token:\n    :return:\n    \"\"\"\n    jwt_decode_handler = api_settings.JWT_DECODE_HANDLER\n    jwt_get_username_from_payload = api_settings.JWT_PAYLOAD_GET_USERNAME_HANDLER\n \n    if not token or len(token) == 0:  # case1: 토큰을 분실 했을 경우\n        raise serializers.ValidationError('Invalid token header. Non credentials provided.')\n        # raise exceptions.AuthenticationFailed({'error': 'Invalid token header. No credentials provided.'})\n \n    try:\n        payload = jwt_decode_handler(token)\n \n    except jwt.ExpiredSignature:  # case2: 토큰이 만료되었을 경우\n        raise serializers.ValidationError('Signature has expired.')\n        # raise exceptions.AuthenticationFailed({'error': 'Signature has expired.'})\n    except jwt.DecodeError:  # case3: 디코드 실패\n        raise serializers.ValidationError('Error decoding signature.')\n        # raise exceptions.AuthenticationFailed({'error': 'Error decoding signature.'})\n \n    username = jwt_get_username_from_payload(payload)\n \n    if not username:  # case4: payload 가 잘못되어 username을 가져올 수 없는 경우\n        raise serializers.ValidationError('Invalid payload.')\n        # raise exceptions.AuthenticationFailed({'error': 'Invalid payload.'})\n \n    try:\n        user = CustomUser.objects.get(username=username)\n    except CustomUser.DoesNotExist:  # case5: 해당 유저가 존재하지 않는 경우\n        raise serializers.ValidationError(\"User doesn't exists.\")\n        # raise exceptions.AuthenticationFailed({'error': \"User doesn't exists.\"})\n \n    return user\n```\n    \n여러 이유로 인증에 실패할 경우엔 인증 실패 예외가 발생하게 되는데 이는 따로 핸들러로 처리해주어야 한다. (에러 정보는 response.data 에 담겨온다.)  \n(여기서는 인증 실패 예외가 발생할 경우 쿠키에 저장되어 있는 토큰값을 지워버리고 로그인 페이지로 보내버린다.)  \n\ncustom_exception_handler.py\n\n```\nfrom django.conf import settings\nfrom django.core.urlresolvers import reverse\nfrom django.http import HttpResponseRedirect\nfrom rest_framework import status\nfrom rest_framework.views import exception_handler\n \n \ndef custom_exception_handler(exc, context):\n    # 발생한 exception을 가져온다.\n    response = exception_handler(exc, context)\n \n    if response is not None:\n        # response_data = response.data['detail']\n        # print('response : ', response.__dict__)\n \n        # 예외가 발생할 경우엔 token쿠키를 지워준다\n        response.delete_cookie('token', domain=settings.COOKIE_DOMAIN)\n \n        return HttpResponseRedirect(reverse('login'))\n    else:\n        return None\n```\n\n#### 페이지 접근 허가 정보 확인하기\n접근하고자 하는 페이지가 각 유저별로 인증 정보가 필요하다면 유저의 인증 정보를 확인할 수 있어야 한다.  \n\npermission.py  \n\n```\nfrom rest_framework.permissions import BasePermission\n \n \nclass CustomPermission(BasePermission):\n    def has_permission(self, request, view):\n        # TODO: do something\n        print('CustomPermission user : ', request.user)\n        return True\n```\n\n(현재는 어떤 허가 정보도 판단하지 않지만 이 부분에서 유저 정보를 가지고 해당 페이지에 대한 허가 정보를 판단해서 boolean 값으로 반환해준다. True일 경우 허가된 경우고 False일 경우엔 허가되지 않는 유저이다.)  \n  \nAPIView 에서 허가 정보도 명시적으로 선언해서 확인할 수 있다.  \n\nview.py  \n\n```\nclass RootView(APIView):\n    authentication_classes = (CustomAuthentication, )\n    permission_classes = (CustomPermission, )\n    def get(self, request):\n        \"\"\"\n        :param request:\n        :return:\n        \"\"\"\n        redirect_url = \"/home\"\n        return HttpResponseRedirect(redirect_url)\n```\n\n마찬가지로 모든 APIView 에서 허가 정보를 확인해야 한다면 settings 에 설정해줄 수 있다. 좀 전에 인증 정보를 작성한 부분에 추가해주자.  \n  \nsettings.py\n\n```\nREST_FRAMEWORK = {\n    'DEFAULT_AUTHENTICATION_CLASSES': (\n        'common.utils.authentication.CustomAuthentication',\n    ),\n    'DEFAULT_PERMISSION_CLASSES': (\n        'common.utils.permission.CustomPermission',\n    ),\n    'EXCEPTION_HANDLER': 'common.utils.custom_exception_handler.custom_exception_handler'\n}\n```\n\n허가 요청에 대한 부분이 추가되었으므로 예외 처리 핸들러에서 이 부분에 대한 처리도 추가해줘야 한다. 요청이 실패할 경우 403 에러가 발생하는데 이 부분에 대한 처리를 해준다.  \n  \ncustom_exception_handler.py  \n\n```\nfrom django.conf import settings\nfrom django.core.urlresolvers import reverse\nfrom django.http import HttpResponseRedirect\nfrom rest_framework import status\nfrom rest_framework.views import exception_handler\n \n \ndef custom_exception_handler(exc, context):\n    # 발생한 exception을 가져온다.\n    response = exception_handler(exc, context)\n \n    if response is not None:\n        # response_data = response.data['detail']\n        # print('response : ', response.__dict__)\n \n        # permission 이 안되는 경우엔 block page 로 넘겨준다.\n        if response.status_code == status.HTTP_403_FORBIDDEN:\n            return HttpResponseRedirect(reverse('block'))\n \n        # 예외가 발생할 경우엔 token쿠키를 지워준다\n        response.delete_cookie('token', domain=settings.COOKIE_DOMAIN)\n \n        return HttpResponseRedirect(reverse('login'))\n    else:\n        return None\n```\n\n인증 실패인 경우에는 쿠키에서 토큰 정보를 삭제하고   \n로그인 페이지로 보내버리고,   \n허가 요청 거부일 경우에는 block 페이지로 보내버렸는데,   \n이 부분은 각 사이트의 상황에 맞게 처리해주면 된다.  \n  \n#### 로그아웃 하기\n로그아웃은 간단하다. 단지 쿠키에 저장되어 있는 토큰 값을 지워버리면 되기 때문이다.  \n\nview.py\n\n```\nclass LogoutView(View):\n \n    def get(self, request):\n        response = HttpResponseRedirect(reverse('login'))\n        response.delete_cookie('token', domain=settings.COOKIE_DOMAIN)\n        return response\n```\n\n#### 요약\n지금까지 추가된 파일들과 클래스를 정리하자면 다음과 같다.  \n\n```\ncommon/utils/custom_exception_handler.py\n    - custom_exception_handler\ncommon/utils/authentication.py\n    - CustomAuthentication\ncommon/utils/permission.py\n    - CustomerPermission\ncommon/utils/jwt_util.py\n    - obtain_token\n    - obtain_user\n```\n\n여기까지 따라왔다면 sso를 완성 할 수 있다. 하나의 사이트에서 동작하는지 여부를 검사하고 싶다면 hosts 에 도메인을 추가해서 테스트 해보자.  \n\n```\n$ sudo vim /etc/hosts\n```\n\n/etc/hosts  \n\n```\n127.0.0.1   alpha.mysite.com\n127.0.0.1   beta.mysite.com\n```\n\n위와 같이 추가하고 테스트를 해볼 수 있다.  \n\n## 결론\n\n유저의 로그인 검증 후 유저 정보를 jwt 를 이용해서 토큰을 생성한 후, 이 정보는 메인 도메인으로 쿠키에 저장을 한다. 인증이 필요한 페이지의 경우 cookie 에 저장되어 있는 토큰으로 인증된 유저인지 여부를 판단한다. 이 때, 이 토큰 값이 유효하지 않을 경우엔 강제로 로그아웃 처리를 한다. jwt 토큰의 만료 시간을 주어 일정 시간이 지나면 로그인이 풀리도록 했다. 메인 도메인 하위의 3개의 사이트중 하나의 사이트에서만 로그인을 하면 나머지 두개의 사이트에서도 로그인이 되어 있다(같은 쿠키의 토큰을 사용하기 때문)\n\n\n### 추신\n\n나름 간단하게 기능을 구현하고자 했는데 로그인 정보를 저장하고 그 토큰을 처리하기 위해 여러 처리가 붙었다. 그리고 토큰 값을 만들고 검증하고 이를 인증하는 코드들을 직접 쓰다보니 조금은 번거로운 작업들이 포함되어 있는 건 사실이다.. 때로는 오픈소스를 별다른 이해 없이 기능을 사용하기 위해 가져다 쓰는 것 보다 내부 로직을 이해하고 내가 필요한 부분들만 가져다 쓰는 작업을 하면 재미있기도 하고 후에 문제가 생기거나 기능 변경이 생겼을 때 대처가 빠르다. 물론 이런 방식이 정답을 아닐지는 몰라도 덕분에 재미있는 작업을 했다는 점에 만족한다.\n\n\n","source":"_posts/django-sso.md","raw":"---\ntitle: \"Django에서 SSO하기\"\ncatalog: true\ndate: 2016-05-06 16:59:58\nsubtitle:\nheader-img: \"/img/header_img/bg.png\"\ntags:\n- django\n- sso\n\n---\n\n회사에서 필요에 의해 [Single Sign On](https://ko.wikipedia.org/wiki/%ED%86%B5%ED%95%A9_%EC%9D%B8%EC%A6%9D, \"Single Sign On\")을 구현해야 할 일이 있었다. 3개의 독립된 사이트가 있었고, 각자 로그인을 따로 해야 한다는 점이 사용자 입장에서는 번거로운 일이 될 수 있다는 이유에서 였다. \n\n 3개의 사이트는 하나의 유저테이블을 바라보고 있었기 때문에 충분히 합당한 이유였다. 하지만 django에서 제공하는 기본 유저 테이블을 사용하지 않기 때문에 찾아봤었던 다른 인증 툴들은 그대로 사용하기 까다로워 보였다. 내가 구현해야 하는 상황에는 몇가지 제약사항이 있었다.  \n  \n1. 로그인을 시도할 때 기존에 제공되는 auth_user 테이블이 아닌 <U>별도의 user 테이블을 사용하고 있다.</U>\n  \n2. 기존에 제공되는 user 모델을 사용하지 않기 때문에 <U>reatframework 에서 기존에 제공하는 인증방식을 그대로 사용할 수 없었다.</U>\n  \n3. 이미 테이블이 존재하고 <U>django 프로젝트에서 migration 을 할 수 없는 상황이다.</U> 기존에 생성되어 있는 테이블들의 구성을 변경할 수는 있지만 그 과정과 절차가 까다롭고 (회사의 사정에 의해), 외래키를 사용하지 않았기 때문에 모델과 테이블간의 100% 싱크가 맞지 않는 상황이었다.\n  \n4. 위와 같은 이유로 찾아봤었던 [MamaCAS](https://github.com/jbittel/django-mama-cas, \"MamaCas\") 같은 외부 인증툴을 사용할 수 없었다. (migration을 할 수 없었기에 인증을 위해 별도의 테이블을 생성하기 까다로운 상황이었다.)\n  \n3개의 프로젝트들이 출시가 얼마 남지 않은 상황이고, 인증을 위해서 별도의 커다란 작업이 있는 것은 별로 좋은 선택이 아니였다. 물론 외부의 다른 툴들을 이용할 수도 있었지만, 단순 인증을 위해 외부툴을 사용하기엔 부담스러운 부분이 있었고, 볼륨을 크게 잡고 싶지 않았다. \n  \n여러 방법을 찾아보면서 몇가지 아이디어가 나왔었다.\n  \n1. [redis](https://redis.io/, \"redis\") 를 이용해서 인증 정보를 저장하는 방식\n  \n2. [jwt](https://jwt.io/, \"jwt\")를 이용해서 javascript 내부에서 localStorage 에 인증 정보를 저장하는 방식\n  \n3. cookie에 저장하는 방식\n  \n나는 일단 1번의 redis는 제외하기로 했다. 이미 각각의 프로젝트에서 redis를 사용하고 있었고, 인증을 위해 별도의 redis를 띄우는게 번거롭다고 생각했다. 그리고 2번의 localStorage 방식은 javascript에서 ajax통신을 각 페이지별로 날려 유효한 인증을 판단하는 방식이었는데, django 단에서 각 request마다 헤더에 인증 정보를 넣기가 까다로웠다. (하지만 jwt로 토큰을 암호화 하는건 괜찮은 방법이라 생각했다.) 3번의 cookie 방식은 별도의 작업 없이 구현이 가능했지만 3개의 사이트가 같은 메인 도메인 하에 있어야 가능했었다. 어차피 모든 사이트가 회사 내부에서 사용할 목적으로 만들어 지고 있는 프로젝트 였고 같은 메인 도메인만 사용하면 되었기 때문에 나는 3번째의 방법을 사용하기로 했다. \n  \n서론이 길었지만.. 그리하여 jwt와 cookie를 이용해서 sso를 구현해 보기로 했다.\n  \n여러 사이트가 있고 각각 로그인(유저 인증)이 필요하고 기능 마다 해당 유저가 접근할 수 있는(허가) 기능이 필요하다. \n  \n(single sign on 을 하다보니 authentication 과 permission 처리가 필요했다..)\n  \n여러 개의 사이트가 공유하는 유저 정보가 있고, 이 정보로 로그인을 하기 때문에 모든 사이트에서 한번의 로그인을 하면 되는 기능이 필요했다.추가적으로 각 사이트 별로는 각자의 허가 정보가 있으므로 이 정보는 공유하지 않고 각자 구현한다. (템플릿만 제공)\n  \n한마디로 요약하면 쿠키에 암호화된 토큰 정보를 도메인이 같은 사이트들끼리 로그인 정보를 공유를 해서 사용하는 방법이다. \n  \n## 예상 시나리오\n  \nalpha.mysite.com, beta.mysite.com, charlie.mysite.com 3개의 사이트가 있다.  \nbeta 에서 로그인을 하고 charlie 사이트에 접속할 경우 이미 로그인이 되어 있다.  \n3개의 사이트는 각자 permission 이 따로 존재한다.  \nalpha 에서 로그아웃을 할 경우, 나머지 사이트에서도 모두 로그아웃이 된다.  \n로그인 정보가 만료되었을 경우에도 로그아웃 처리된다.  \n  \n## 시나리오 순서 별 설명\n\n1. 로그인 시 : <U>jwt token</U> 을 발급해서 request cookie에 저장한다. (이 때, <U>cookie</U> 의 domain은 main domain 값을 넣어준다.<mysite.com>)  \n2. 인증이 필요한 페이지에 접속할 경우  \nrest framework 의 <U>authentication</U> class 에서 cookie 에 저장되어 있는 token 값의 유효성을 검사한다.  \nrest framework 의 <U>permission</U> class 에서 해당 유저가 기능에 접근 허가 여부를 판단한다.  \n3. 로그아웃 시 : cookie 의 token 값을 지워준다.  \n4. 추가 정보  \n\t* 인증에 실패한 경우 : cookie 값을 삭제하고 login 페이지로 보낸다.  \n\t* 기능 접근 허가가 거부된 경우 : block page 를 표시한다.  \n\t* 토큰이 만료된 경우 : cookie 값을 삭제하고 login 페이지로 보낸다.    \n5. 제약사항  \n\t* 메인 도메인이 동일해야한다.  \n\t* permission 정보는 공유하지 않기 때문에 각자 사이트에서 구현해야 한다.  \n\n## 환경 설정\n\n```\npython 3.4.3\ndjango 1.8.4\ndjangorestframework 3.3.0\n```\n  \n하나씩 시작해보자.  \n  \n### 패키지 추가하기\n\n```\n$ pip install djangorestframework-jwt\n```\n\n### 로그인 하기\n\n#### 토큰 생성하기\n\n유저 정보가 맞을 경우 이 정보를 토대로 jwt token을 생성해준다.  \njwt_util.py   \n \n```\nfrom calendar import timegm\nfrom datetime import datetime\n \nimport jwt\nfrom rest_framework_jwt.settings import api_settings\n \nfrom user.models.CustomUser import CustomUser\n \n \ndef obtain_token(user: CustomUser):\n    jwt_payload_handler = api_settings.JWT_PAYLOAD_HANDLER\n    jwt_encode_handler = api_settings.JWT_ENCODE_HANDLER\n \n    payload = jwt_payload_handler(user)\n \n    # Include original issued at time for a brand new token,\n    # to allow token refresh\n    if api_settings.JWT_ALLOW_REFRESH:\n        payload['orig_iat'] = timegm(\n            datetime.utcnow().utctimetuple()\n        )\n \n    return jwt_encode_handler(payload)\n```\n\njwt 변수들에 대한 자세한 설정은 Rest Framework JWT 에서 확인 할 수 있다. 그리고 default 로 설정된 변수들을 재선언 하고 싶다면 setting 에 해주면 된다.  \n\nsettings.py  \n\n``` \nJWT_AUTH = {\n    'JWT_EXPIRATION_DELTA': datetime.timedelta(hours=24),\n}\n```\n\n#### 쿠키에 저장하기\n\n사용자가 입력한 아이디와 암호가 맞을 경우 이 정보를 cookie 에 저장을 한다. 저장할 때 domain option 을 main domain(mysite.com) 로 설정해준다. domain 설정을 해주지 않을 경우 다른 사이트에서 쿠키정보를 공유할 수 없다.   \n  \n  \nview.py\n  \n``` \nclass LoginView(View):\n \n    def get(self, request):\n        return TemplateResponse(request, 'account/login.html')\n \n    def post(self, request):\n        username = request.POST.get('username')\n        password = request.POST.get('password')\n \n        try:\n            admin = CustomUser.objects.get(username=username)\n            # 유저 암호 검사하기.\n            if security.matches_password(password, admin.password):\n                # obtain jwt token\n                token = obtain_token(admin)\n \n                # set cookie\n                response = HttpResponseRedirect(reverse('root'))\n                response.set_cookie(key='token', value=token, domain=settings.COOKIE_DOMAIN)\n                return response\n            else:\n                context = {\n                    'error': '비밀번호가 일치하지 않습니다.'\n                }\n        except TAdmin.DoesNotExist:\n            context = {\n                'error': '존재하지 않는 ID입니다.'\n            }\n \n        return TemplateResponse(request, 'account/login.html', context)\n}\n```\n  \n공통으로 사용할 메인 도메인 이름은 각 사이트 마다 통일 해줘야 한다.  \n\nsettings.py  \n\n``` \nCOOKIE_DOMAIN = 'mysite.com'\n```\n\n쿠키에 토큰 값을 저장 했으므로 이제 각 사이트에 로그인 되었다고 할 수 있는 첫번 째 단계는 달성했다.  \n\n#### 페이지 인증정보 확인하기\n로그인이 되어 있어야 접근할 수 있는 페이지의 경우 로그인 정보를 확인한 후에 정보를 로드한다. RestFramework 에서 제공하는 APIView 를 사용해서 인증 정보를 확인한다.  \n\nview.py\n\n```\nclass RootView(APIView):\n    authentication_classes = (CustomAuthentication, )\n    def get(self, request):\n        \"\"\"\n        :param request:\n        :return:\n        \"\"\"\n        redirect_url = \"/home\"\n        return HttpResponseRedirect(redirect_url)\n\n}\n```\n\n 여기서 authentication class 를 명시적으로 선언해주었는데, 모든 APIView(인증과 허가가 필요한 페이지의 경우) 에 적용될 수 있도록 settings 에 선언해줄 수 있다.   \n\n(인증 실패나 허가 요청 실패시 처리해줄 수 있는 핸들러도 미리 추가해놓자.)  \n\nsettings.py  \n\n``` \nREST_FRAMEWORK = {\n    'DEFAULT_AUTHENTICATION_CLASSES': (\n        'common.utils.authentication.CustomAuthentication',\n    ),\n    'EXCEPTION_HANDLER': 'common.utils.custom_exception_handler.custom_exception_handler'\n}\n```\n\n인증 확인은 쿠키에 저장되어 있는 토큰 정보로 확인한다. 토큰으로 정상적인 유저를 가져올 수 있다면 유효한 유저라고 판단한다.  \n\nauthentication.py  \n\n```\nfrom rest_framework import authentication\n \nfrom common.utils.jwt_util import obtain_user\n \n \nclass CustomAuthentication(authentication.BaseAuthentication):\n    def authenticate(self, request):\n        \"\"\"\n        쿠키에 저장되어 있는 token 값으로 유저를 가져옵니다. 가져오는 상황에서 예외가 발생할 수 있으며 정상적으로 가져온 경우에는 인증된 유저라고 판단합니다.\n        :param request:\n        :return:\n        \"\"\"\n        token = request.COOKIES.get('token', None)\n        user = obtain_user(token)\n        return (user, None)\n```\n\n쿠키에 저장되어 있는 토큰을 decode 하여 유효한 정보인지를 판단한다.  \n\njwt_util.py  \n  \n``` \ndef obtain_user(token: str):\n    \"\"\"\n    payload = {'username': 'adm001', 'email': 'test@mysite.com', 'user_id': 1, 'exp': 1462187582}\n    :param token:\n    :return:\n    \"\"\"\n    jwt_decode_handler = api_settings.JWT_DECODE_HANDLER\n    jwt_get_username_from_payload = api_settings.JWT_PAYLOAD_GET_USERNAME_HANDLER\n \n    if not token or len(token) == 0:  # case1: 토큰을 분실 했을 경우\n        raise serializers.ValidationError('Invalid token header. Non credentials provided.')\n        # raise exceptions.AuthenticationFailed({'error': 'Invalid token header. No credentials provided.'})\n \n    try:\n        payload = jwt_decode_handler(token)\n \n    except jwt.ExpiredSignature:  # case2: 토큰이 만료되었을 경우\n        raise serializers.ValidationError('Signature has expired.')\n        # raise exceptions.AuthenticationFailed({'error': 'Signature has expired.'})\n    except jwt.DecodeError:  # case3: 디코드 실패\n        raise serializers.ValidationError('Error decoding signature.')\n        # raise exceptions.AuthenticationFailed({'error': 'Error decoding signature.'})\n \n    username = jwt_get_username_from_payload(payload)\n \n    if not username:  # case4: payload 가 잘못되어 username을 가져올 수 없는 경우\n        raise serializers.ValidationError('Invalid payload.')\n        # raise exceptions.AuthenticationFailed({'error': 'Invalid payload.'})\n \n    try:\n        user = CustomUser.objects.get(username=username)\n    except CustomUser.DoesNotExist:  # case5: 해당 유저가 존재하지 않는 경우\n        raise serializers.ValidationError(\"User doesn't exists.\")\n        # raise exceptions.AuthenticationFailed({'error': \"User doesn't exists.\"})\n \n    return user\n```\n    \n여러 이유로 인증에 실패할 경우엔 인증 실패 예외가 발생하게 되는데 이는 따로 핸들러로 처리해주어야 한다. (에러 정보는 response.data 에 담겨온다.)  \n(여기서는 인증 실패 예외가 발생할 경우 쿠키에 저장되어 있는 토큰값을 지워버리고 로그인 페이지로 보내버린다.)  \n\ncustom_exception_handler.py\n\n```\nfrom django.conf import settings\nfrom django.core.urlresolvers import reverse\nfrom django.http import HttpResponseRedirect\nfrom rest_framework import status\nfrom rest_framework.views import exception_handler\n \n \ndef custom_exception_handler(exc, context):\n    # 발생한 exception을 가져온다.\n    response = exception_handler(exc, context)\n \n    if response is not None:\n        # response_data = response.data['detail']\n        # print('response : ', response.__dict__)\n \n        # 예외가 발생할 경우엔 token쿠키를 지워준다\n        response.delete_cookie('token', domain=settings.COOKIE_DOMAIN)\n \n        return HttpResponseRedirect(reverse('login'))\n    else:\n        return None\n```\n\n#### 페이지 접근 허가 정보 확인하기\n접근하고자 하는 페이지가 각 유저별로 인증 정보가 필요하다면 유저의 인증 정보를 확인할 수 있어야 한다.  \n\npermission.py  \n\n```\nfrom rest_framework.permissions import BasePermission\n \n \nclass CustomPermission(BasePermission):\n    def has_permission(self, request, view):\n        # TODO: do something\n        print('CustomPermission user : ', request.user)\n        return True\n```\n\n(현재는 어떤 허가 정보도 판단하지 않지만 이 부분에서 유저 정보를 가지고 해당 페이지에 대한 허가 정보를 판단해서 boolean 값으로 반환해준다. True일 경우 허가된 경우고 False일 경우엔 허가되지 않는 유저이다.)  \n  \nAPIView 에서 허가 정보도 명시적으로 선언해서 확인할 수 있다.  \n\nview.py  \n\n```\nclass RootView(APIView):\n    authentication_classes = (CustomAuthentication, )\n    permission_classes = (CustomPermission, )\n    def get(self, request):\n        \"\"\"\n        :param request:\n        :return:\n        \"\"\"\n        redirect_url = \"/home\"\n        return HttpResponseRedirect(redirect_url)\n```\n\n마찬가지로 모든 APIView 에서 허가 정보를 확인해야 한다면 settings 에 설정해줄 수 있다. 좀 전에 인증 정보를 작성한 부분에 추가해주자.  \n  \nsettings.py\n\n```\nREST_FRAMEWORK = {\n    'DEFAULT_AUTHENTICATION_CLASSES': (\n        'common.utils.authentication.CustomAuthentication',\n    ),\n    'DEFAULT_PERMISSION_CLASSES': (\n        'common.utils.permission.CustomPermission',\n    ),\n    'EXCEPTION_HANDLER': 'common.utils.custom_exception_handler.custom_exception_handler'\n}\n```\n\n허가 요청에 대한 부분이 추가되었으므로 예외 처리 핸들러에서 이 부분에 대한 처리도 추가해줘야 한다. 요청이 실패할 경우 403 에러가 발생하는데 이 부분에 대한 처리를 해준다.  \n  \ncustom_exception_handler.py  \n\n```\nfrom django.conf import settings\nfrom django.core.urlresolvers import reverse\nfrom django.http import HttpResponseRedirect\nfrom rest_framework import status\nfrom rest_framework.views import exception_handler\n \n \ndef custom_exception_handler(exc, context):\n    # 발생한 exception을 가져온다.\n    response = exception_handler(exc, context)\n \n    if response is not None:\n        # response_data = response.data['detail']\n        # print('response : ', response.__dict__)\n \n        # permission 이 안되는 경우엔 block page 로 넘겨준다.\n        if response.status_code == status.HTTP_403_FORBIDDEN:\n            return HttpResponseRedirect(reverse('block'))\n \n        # 예외가 발생할 경우엔 token쿠키를 지워준다\n        response.delete_cookie('token', domain=settings.COOKIE_DOMAIN)\n \n        return HttpResponseRedirect(reverse('login'))\n    else:\n        return None\n```\n\n인증 실패인 경우에는 쿠키에서 토큰 정보를 삭제하고   \n로그인 페이지로 보내버리고,   \n허가 요청 거부일 경우에는 block 페이지로 보내버렸는데,   \n이 부분은 각 사이트의 상황에 맞게 처리해주면 된다.  \n  \n#### 로그아웃 하기\n로그아웃은 간단하다. 단지 쿠키에 저장되어 있는 토큰 값을 지워버리면 되기 때문이다.  \n\nview.py\n\n```\nclass LogoutView(View):\n \n    def get(self, request):\n        response = HttpResponseRedirect(reverse('login'))\n        response.delete_cookie('token', domain=settings.COOKIE_DOMAIN)\n        return response\n```\n\n#### 요약\n지금까지 추가된 파일들과 클래스를 정리하자면 다음과 같다.  \n\n```\ncommon/utils/custom_exception_handler.py\n    - custom_exception_handler\ncommon/utils/authentication.py\n    - CustomAuthentication\ncommon/utils/permission.py\n    - CustomerPermission\ncommon/utils/jwt_util.py\n    - obtain_token\n    - obtain_user\n```\n\n여기까지 따라왔다면 sso를 완성 할 수 있다. 하나의 사이트에서 동작하는지 여부를 검사하고 싶다면 hosts 에 도메인을 추가해서 테스트 해보자.  \n\n```\n$ sudo vim /etc/hosts\n```\n\n/etc/hosts  \n\n```\n127.0.0.1   alpha.mysite.com\n127.0.0.1   beta.mysite.com\n```\n\n위와 같이 추가하고 테스트를 해볼 수 있다.  \n\n## 결론\n\n유저의 로그인 검증 후 유저 정보를 jwt 를 이용해서 토큰을 생성한 후, 이 정보는 메인 도메인으로 쿠키에 저장을 한다. 인증이 필요한 페이지의 경우 cookie 에 저장되어 있는 토큰으로 인증된 유저인지 여부를 판단한다. 이 때, 이 토큰 값이 유효하지 않을 경우엔 강제로 로그아웃 처리를 한다. jwt 토큰의 만료 시간을 주어 일정 시간이 지나면 로그인이 풀리도록 했다. 메인 도메인 하위의 3개의 사이트중 하나의 사이트에서만 로그인을 하면 나머지 두개의 사이트에서도 로그인이 되어 있다(같은 쿠키의 토큰을 사용하기 때문)\n\n\n### 추신\n\n나름 간단하게 기능을 구현하고자 했는데 로그인 정보를 저장하고 그 토큰을 처리하기 위해 여러 처리가 붙었다. 그리고 토큰 값을 만들고 검증하고 이를 인증하는 코드들을 직접 쓰다보니 조금은 번거로운 작업들이 포함되어 있는 건 사실이다.. 때로는 오픈소스를 별다른 이해 없이 기능을 사용하기 위해 가져다 쓰는 것 보다 내부 로직을 이해하고 내가 필요한 부분들만 가져다 쓰는 작업을 하면 재미있기도 하고 후에 문제가 생기거나 기능 변경이 생겼을 때 대처가 빠르다. 물론 이런 방식이 정답을 아닐지는 몰라도 덕분에 재미있는 작업을 했다는 점에 만족한다.\n\n\n","slug":"django-sso","published":1,"updated":"2018-04-15T08:08:51.239Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjq98sopj00078ghhw3vpyg60","content":"<p>회사에서 필요에 의해 <a href=\"https://ko.wikipedia.org/wiki/%ED%86%B5%ED%95%A9_%EC%9D%B8%EC%A6%9D,\" title=\"Single Sign On\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">Single Sign On</a>을 구현해야 할 일이 있었다. 3개의 독립된 사이트가 있었고, 각자 로그인을 따로 해야 한다는 점이 사용자 입장에서는 번거로운 일이 될 수 있다는 이유에서 였다.</p>\n<p>3개의 사이트는 하나의 유저테이블을 바라보고 있었기 때문에 충분히 합당한 이유였다. 하지만 django에서 제공하는 기본 유저 테이블을 사용하지 않기 때문에 찾아봤었던 다른 인증 툴들은 그대로 사용하기 까다로워 보였다. 내가 구현해야 하는 상황에는 몇가지 제약사항이 있었다.</p>\n<ol>\n<li>\n<p>로그인을 시도할 때 기존에 제공되는 auth_user 테이블이 아닌 <u>별도의 user 테이블을 사용하고 있다.</u></p>\n</li>\n<li>\n<p>기존에 제공되는 user 모델을 사용하지 않기 때문에 <u>reatframework 에서 기존에 제공하는 인증방식을 그대로 사용할 수 없었다.</u></p>\n</li>\n<li>\n<p>이미 테이블이 존재하고 <u>django 프로젝트에서 migration 을 할 수 없는 상황이다.</u> 기존에 생성되어 있는 테이블들의 구성을 변경할 수는 있지만 그 과정과 절차가 까다롭고 (회사의 사정에 의해), 외래키를 사용하지 않았기 때문에 모델과 테이블간의 100% 싱크가 맞지 않는 상황이었다.</p>\n</li>\n<li>\n<p>위와 같은 이유로 찾아봤었던 <a href=\"https://github.com/jbittel/django-mama-cas,\" title=\"MamaCas\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">MamaCAS</a> 같은 외부 인증툴을 사용할 수 없었다. (migration을 할 수 없었기에 인증을 위해 별도의 테이블을 생성하기 까다로운 상황이었다.)</p>\n</li>\n</ol>\n<p>3개의 프로젝트들이 출시가 얼마 남지 않은 상황이고, 인증을 위해서 별도의 커다란 작업이 있는 것은 별로 좋은 선택이 아니였다. 물론 외부의 다른 툴들을 이용할 수도 있었지만, 단순 인증을 위해 외부툴을 사용하기엔 부담스러운 부분이 있었고, 볼륨을 크게 잡고 싶지 않았다.</p>\n<p>여러 방법을 찾아보면서 몇가지 아이디어가 나왔었다.</p>\n<ol>\n<li>\n<p><a href=\"https://redis.io/,\" title=\"redis\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">redis</a> 를 이용해서 인증 정보를 저장하는 방식</p>\n</li>\n<li>\n<p><a href=\"https://jwt.io/,\" title=\"jwt\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">jwt</a>를 이용해서 javascript 내부에서 localStorage 에 인증 정보를 저장하는 방식</p>\n</li>\n<li>\n<p>cookie에 저장하는 방식</p>\n</li>\n</ol>\n<p>나는 일단 1번의 redis는 제외하기로 했다. 이미 각각의 프로젝트에서 redis를 사용하고 있었고, 인증을 위해 별도의 redis를 띄우는게 번거롭다고 생각했다. 그리고 2번의 localStorage 방식은 javascript에서 ajax통신을 각 페이지별로 날려 유효한 인증을 판단하는 방식이었는데, django 단에서 각 request마다 헤더에 인증 정보를 넣기가 까다로웠다. (하지만 jwt로 토큰을 암호화 하는건 괜찮은 방법이라 생각했다.) 3번의 cookie 방식은 별도의 작업 없이 구현이 가능했지만 3개의 사이트가 같은 메인 도메인 하에 있어야 가능했었다. 어차피 모든 사이트가 회사 내부에서 사용할 목적으로 만들어 지고 있는 프로젝트 였고 같은 메인 도메인만 사용하면 되었기 때문에 나는 3번째의 방법을 사용하기로 했다.</p>\n<p>서론이 길었지만… 그리하여 jwt와 cookie를 이용해서 sso를 구현해 보기로 했다.</p>\n<p>여러 사이트가 있고 각각 로그인(유저 인증)이 필요하고 기능 마다 해당 유저가 접근할 수 있는(허가) 기능이 필요하다.</p>\n<p>(single sign on 을 하다보니 authentication 과 permission 처리가 필요했다…)</p>\n<p>여러 개의 사이트가 공유하는 유저 정보가 있고, 이 정보로 로그인을 하기 때문에 모든 사이트에서 한번의 로그인을 하면 되는 기능이 필요했다.추가적으로 각 사이트 별로는 각자의 허가 정보가 있으므로 이 정보는 공유하지 않고 각자 구현한다. (템플릿만 제공)</p>\n<p>한마디로 요약하면 쿠키에 암호화된 토큰 정보를 도메인이 같은 사이트들끼리 로그인 정보를 공유를 해서 사용하는 방법이다.</p>\n<h2><span id=\"예상-시나리오\">예상 시나리오</span></h2>\n<p><a href=\"http://alpha.mysite.com\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">alpha.mysite.com</a>, <a href=\"http://beta.mysite.com\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">beta.mysite.com</a>, <a href=\"http://charlie.mysite.com\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">charlie.mysite.com</a> 3개의 사이트가 있다.<br>\nbeta 에서 로그인을 하고 charlie 사이트에 접속할 경우 이미 로그인이 되어 있다.<br>\n3개의 사이트는 각자 permission 이 따로 존재한다.<br>\nalpha 에서 로그아웃을 할 경우, 나머지 사이트에서도 모두 로그아웃이 된다.<br>\n로그인 정보가 만료되었을 경우에도 로그아웃 처리된다.</p>\n<h2><span id=\"시나리오-순서-별-설명\">시나리오 순서 별 설명</span></h2>\n<ol>\n<li>로그인 시 : <u>jwt token</u> 을 발급해서 request cookie에 저장한다. (이 때, <u>cookie</u> 의 domain은 main domain 값을 넣어준다.&lt;<a href=\"http://mysite.com\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">mysite.com</a>&gt;)</li>\n<li>인증이 필요한 페이지에 접속할 경우<br>\nrest framework 의 <u>authentication</u> class 에서 cookie 에 저장되어 있는 token 값의 유효성을 검사한다.<br>\nrest framework 의 <u>permission</u> class 에서 해당 유저가 기능에 접근 허가 여부를 판단한다.</li>\n<li>로그아웃 시 : cookie 의 token 값을 지워준다.</li>\n<li>추가 정보\n<ul>\n<li>인증에 실패한 경우 : cookie 값을 삭제하고 login 페이지로 보낸다.</li>\n<li>기능 접근 허가가 거부된 경우 : block page 를 표시한다.</li>\n<li>토큰이 만료된 경우 : cookie 값을 삭제하고 login 페이지로 보낸다.</li>\n</ul>\n</li>\n<li>제약사항\n<ul>\n<li>메인 도메인이 동일해야한다.</li>\n<li>permission 정보는 공유하지 않기 때문에 각자 사이트에서 구현해야 한다.</li>\n</ul>\n</li>\n</ol>\n<h2><span id=\"환경-설정\">환경 설정</span></h2>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-tag\">python</span> 3<span class=\"selector-class\">.4</span><span class=\"selector-class\">.3</span></span><br><span class=\"line\"><span class=\"selector-tag\">django</span> 1<span class=\"selector-class\">.8</span><span class=\"selector-class\">.4</span></span><br><span class=\"line\"><span class=\"selector-tag\">djangorestframework</span> 3<span class=\"selector-class\">.3</span><span class=\"selector-class\">.0</span></span><br></pre></td></tr></table></figure>\n<p>하나씩 시작해보자.</p>\n<h3><span id=\"패키지-추가하기\">패키지 추가하기</span></h3>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> pip install djangorestframework-jwt</span></span><br></pre></td></tr></table></figure>\n<h3><span id=\"로그인-하기\">로그인 하기</span></h3>\n<h4><span id=\"토큰-생성하기\">토큰 생성하기</span></h4>\n<p>유저 정보가 맞을 경우 이 정보를 토대로 jwt token을 생성해준다.<br>\njwt_util.py</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> calendar <span class=\"keyword\">import</span> timegm</span><br><span class=\"line\"><span class=\"keyword\">from</span> datetime <span class=\"keyword\">import</span> datetime</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"keyword\">import</span> jwt</span><br><span class=\"line\"><span class=\"keyword\">from</span> rest_framework_jwt.settings <span class=\"keyword\">import</span> api_settings</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"keyword\">from</span> user.models.CustomUser <span class=\"keyword\">import</span> CustomUser</span><br><span class=\"line\"> </span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">obtain_token</span><span class=\"params\">(user: CustomUser)</span>:</span></span><br><span class=\"line\">    jwt_payload_handler = api_settings.JWT_PAYLOAD_HANDLER</span><br><span class=\"line\">    jwt_encode_handler = api_settings.JWT_ENCODE_HANDLER</span><br><span class=\"line\"> </span><br><span class=\"line\">    payload = jwt_payload_handler(user)</span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"comment\"># Include original issued at time for a brand new token,</span></span><br><span class=\"line\">    <span class=\"comment\"># to allow token refresh</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> api_settings.JWT_ALLOW_REFRESH:</span><br><span class=\"line\">        payload[<span class=\"string\">'orig_iat'</span>] = timegm(</span><br><span class=\"line\">            datetime.utcnow().utctimetuple()</span><br><span class=\"line\">        )</span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"keyword\">return</span> jwt_encode_handler(payload)</span><br></pre></td></tr></table></figure>\n<p>jwt 변수들에 대한 자세한 설정은 Rest Framework JWT 에서 확인 할 수 있다. 그리고 default 로 설정된 변수들을 재선언 하고 싶다면 setting 에 해주면 된다.</p>\n<p><a href=\"http://settings.py\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">settings.py</a></p>\n<figure class=\"highlight gcode\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">JWT_AUTH = &#123;</span><br><span class=\"line\">    <span class=\"string\">'JWT_EXPIRATION_DELTA'</span>: datetime.timedelta<span class=\"comment\">(hours=24)</span>,</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4><span id=\"쿠키에-저장하기\">쿠키에 저장하기</span></h4>\n<p>사용자가 입력한 아이디와 암호가 맞을 경우 이 정보를 cookie 에 저장을 한다. 저장할 때 domain option 을 main domain(<a href=\"http://mysite.com\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">mysite.com</a>) 로 설정해준다. domain 설정을 해주지 않을 경우 다른 사이트에서 쿠키정보를 공유할 수 없다.</p>\n<p><a href=\"http://view.py\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">view.py</a></p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">LoginView</span><span class=\"params\">(View)</span>:</span></span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">get</span><span class=\"params\">(self, request)</span>:</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> TemplateResponse(request, <span class=\"string\">'account/login.html'</span>)</span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">post</span><span class=\"params\">(self, request)</span>:</span></span><br><span class=\"line\">        username = request.POST.get(<span class=\"string\">'username'</span>)</span><br><span class=\"line\">        password = request.POST.get(<span class=\"string\">'password'</span>)</span><br><span class=\"line\"> </span><br><span class=\"line\">        <span class=\"keyword\">try</span>:</span><br><span class=\"line\">            admin = CustomUser.objects.get(username=username)</span><br><span class=\"line\">            <span class=\"comment\"># 유저 암호 검사하기.</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> security.matches_password(password, admin.password):</span><br><span class=\"line\">                <span class=\"comment\"># obtain jwt token</span></span><br><span class=\"line\">                token = obtain_token(admin)</span><br><span class=\"line\"> </span><br><span class=\"line\">                <span class=\"comment\"># set cookie</span></span><br><span class=\"line\">                response = HttpResponseRedirect(reverse(<span class=\"string\">'root'</span>))</span><br><span class=\"line\">                response.set_cookie(key=<span class=\"string\">'token'</span>, value=token, domain=settings.COOKIE_DOMAIN)</span><br><span class=\"line\">                <span class=\"keyword\">return</span> response</span><br><span class=\"line\">            <span class=\"keyword\">else</span>:</span><br><span class=\"line\">                context = &#123;</span><br><span class=\"line\">                    <span class=\"string\">'error'</span>: <span class=\"string\">'비밀번호가 일치하지 않습니다.'</span></span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">        <span class=\"keyword\">except</span> TAdmin.DoesNotExist:</span><br><span class=\"line\">            context = &#123;</span><br><span class=\"line\">                <span class=\"string\">'error'</span>: <span class=\"string\">'존재하지 않는 ID입니다.'</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">        <span class=\"keyword\">return</span> TemplateResponse(request, <span class=\"string\">'account/login.html'</span>, context)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>공통으로 사용할 메인 도메인 이름은 각 사이트 마다 통일 해줘야 한다.</p>\n<p><a href=\"http://settings.py\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">settings.py</a></p>\n<figure class=\"highlight ini\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">COOKIE_DOMAIN</span> = <span class=\"string\">'mysite.com'</span></span><br></pre></td></tr></table></figure>\n<p>쿠키에 토큰 값을 저장 했으므로 이제 각 사이트에 로그인 되었다고 할 수 있는 첫번 째 단계는 달성했다.</p>\n<h4><span id=\"페이지-인증정보-확인하기\">페이지 인증정보 확인하기</span></h4>\n<p>로그인이 되어 있어야 접근할 수 있는 페이지의 경우 로그인 정보를 확인한 후에 정보를 로드한다. RestFramework 에서 제공하는 APIView 를 사용해서 인증 정보를 확인한다.</p>\n<p><a href=\"http://view.py\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">view.py</a></p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">RootView</span><span class=\"params\">(APIView)</span>:</span></span><br><span class=\"line\">    authentication_classes = (CustomAuthentication, )</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">get</span><span class=\"params\">(self, request)</span>:</span></span><br><span class=\"line\">        <span class=\"string\">\"\"\"</span></span><br><span class=\"line\"><span class=\"string\">        :param request:</span></span><br><span class=\"line\"><span class=\"string\">        :return:</span></span><br><span class=\"line\"><span class=\"string\">        \"\"\"</span></span><br><span class=\"line\">        redirect_url = <span class=\"string\">\"/home\"</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> HttpResponseRedirect(redirect_url)</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>여기서 authentication class 를 명시적으로 선언해주었는데, 모든 APIView(인증과 허가가 필요한 페이지의 경우) 에 적용될 수 있도록 settings 에 선언해줄 수 있다.</p>\n<p>(인증 실패나 허가 요청 실패시 처리해줄 수 있는 핸들러도 미리 추가해놓자.)</p>\n<p><a href=\"http://settings.py\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">settings.py</a></p>\n<figure class=\"highlight roboconf\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">REST_FRAMEWORK = &#123;</span><br><span class=\"line\">    '<span class=\"attribute\">DEFAULT_AUTHENTICATION_CLASSES'</span>: (</span><br><span class=\"line\">        'common<span class=\"variable\">.utils</span><span class=\"variable\">.authentication</span><span class=\"variable\">.CustomAuthentication</span>',</span><br><span class=\"line\">    ),</span><br><span class=\"line\">    'EXCEPTION_HANDLER': 'common<span class=\"variable\">.utils</span><span class=\"variable\">.custom_exception_handler</span><span class=\"variable\">.custom_exception_handler</span>'</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>인증 확인은 쿠키에 저장되어 있는 토큰 정보로 확인한다. 토큰으로 정상적인 유저를 가져올 수 있다면 유효한 유저라고 판단한다.</p>\n<p><a href=\"http://authentication.py\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">authentication.py</a></p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> rest_framework <span class=\"keyword\">import</span> authentication</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"keyword\">from</span> common.utils.jwt_util <span class=\"keyword\">import</span> obtain_user</span><br><span class=\"line\"> </span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">CustomAuthentication</span><span class=\"params\">(authentication.BaseAuthentication)</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">authenticate</span><span class=\"params\">(self, request)</span>:</span></span><br><span class=\"line\">        <span class=\"string\">\"\"\"</span></span><br><span class=\"line\"><span class=\"string\">        쿠키에 저장되어 있는 token 값으로 유저를 가져옵니다. 가져오는 상황에서 예외가 발생할 수 있으며 정상적으로 가져온 경우에는 인증된 유저라고 판단합니다.</span></span><br><span class=\"line\"><span class=\"string\">        :param request:</span></span><br><span class=\"line\"><span class=\"string\">        :return:</span></span><br><span class=\"line\"><span class=\"string\">        \"\"\"</span></span><br><span class=\"line\">        token = request.COOKIES.get(<span class=\"string\">'token'</span>, <span class=\"keyword\">None</span>)</span><br><span class=\"line\">        user = obtain_user(token)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> (user, <span class=\"keyword\">None</span>)</span><br></pre></td></tr></table></figure>\n<p>쿠키에 저장되어 있는 토큰을 decode 하여 유효한 정보인지를 판단한다.</p>\n<p>jwt_util.py</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">obtain_user</span><span class=\"params\">(token: str)</span>:</span></span><br><span class=\"line\">    <span class=\"string\">\"\"\"</span></span><br><span class=\"line\"><span class=\"string\">    payload = &#123;'username': 'adm001', 'email': 'test@mysite.com', 'user_id': 1, 'exp': 1462187582&#125;</span></span><br><span class=\"line\"><span class=\"string\">    :param token:</span></span><br><span class=\"line\"><span class=\"string\">    :return:</span></span><br><span class=\"line\"><span class=\"string\">    \"\"\"</span></span><br><span class=\"line\">    jwt_decode_handler = api_settings.JWT_DECODE_HANDLER</span><br><span class=\"line\">    jwt_get_username_from_payload = api_settings.JWT_PAYLOAD_GET_USERNAME_HANDLER</span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> token <span class=\"keyword\">or</span> len(token) == <span class=\"number\">0</span>:  <span class=\"comment\"># case1: 토큰을 분실 했을 경우</span></span><br><span class=\"line\">        <span class=\"keyword\">raise</span> serializers.ValidationError(<span class=\"string\">'Invalid token header. Non credentials provided.'</span>)</span><br><span class=\"line\">        <span class=\"comment\"># raise exceptions.AuthenticationFailed(&#123;'error': 'Invalid token header. No credentials provided.'&#125;)</span></span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"keyword\">try</span>:</span><br><span class=\"line\">        payload = jwt_decode_handler(token)</span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"keyword\">except</span> jwt.ExpiredSignature:  <span class=\"comment\"># case2: 토큰이 만료되었을 경우</span></span><br><span class=\"line\">        <span class=\"keyword\">raise</span> serializers.ValidationError(<span class=\"string\">'Signature has expired.'</span>)</span><br><span class=\"line\">        <span class=\"comment\"># raise exceptions.AuthenticationFailed(&#123;'error': 'Signature has expired.'&#125;)</span></span><br><span class=\"line\">    <span class=\"keyword\">except</span> jwt.DecodeError:  <span class=\"comment\"># case3: 디코드 실패</span></span><br><span class=\"line\">        <span class=\"keyword\">raise</span> serializers.ValidationError(<span class=\"string\">'Error decoding signature.'</span>)</span><br><span class=\"line\">        <span class=\"comment\"># raise exceptions.AuthenticationFailed(&#123;'error': 'Error decoding signature.'&#125;)</span></span><br><span class=\"line\"> </span><br><span class=\"line\">    username = jwt_get_username_from_payload(payload)</span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> username:  <span class=\"comment\"># case4: payload 가 잘못되어 username을 가져올 수 없는 경우</span></span><br><span class=\"line\">        <span class=\"keyword\">raise</span> serializers.ValidationError(<span class=\"string\">'Invalid payload.'</span>)</span><br><span class=\"line\">        <span class=\"comment\"># raise exceptions.AuthenticationFailed(&#123;'error': 'Invalid payload.'&#125;)</span></span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"keyword\">try</span>:</span><br><span class=\"line\">        user = CustomUser.objects.get(username=username)</span><br><span class=\"line\">    <span class=\"keyword\">except</span> CustomUser.DoesNotExist:  <span class=\"comment\"># case5: 해당 유저가 존재하지 않는 경우</span></span><br><span class=\"line\">        <span class=\"keyword\">raise</span> serializers.ValidationError(<span class=\"string\">\"User doesn't exists.\"</span>)</span><br><span class=\"line\">        <span class=\"comment\"># raise exceptions.AuthenticationFailed(&#123;'error': \"User doesn't exists.\"&#125;)</span></span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"keyword\">return</span> user</span><br></pre></td></tr></table></figure>\n<p>여러 이유로 인증에 실패할 경우엔 인증 실패 예외가 발생하게 되는데 이는 따로 핸들러로 처리해주어야 한다. (에러 정보는 response.data 에 담겨온다.)<br>\n(여기서는 인증 실패 예외가 발생할 경우 쿠키에 저장되어 있는 토큰값을 지워버리고 로그인 페이지로 보내버린다.)</p>\n<p>custom_exception_handler.py</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> django.conf <span class=\"keyword\">import</span> settings</span><br><span class=\"line\"><span class=\"keyword\">from</span> django.core.urlresolvers <span class=\"keyword\">import</span> reverse</span><br><span class=\"line\"><span class=\"keyword\">from</span> django.http <span class=\"keyword\">import</span> HttpResponseRedirect</span><br><span class=\"line\"><span class=\"keyword\">from</span> rest_framework <span class=\"keyword\">import</span> status</span><br><span class=\"line\"><span class=\"keyword\">from</span> rest_framework.views <span class=\"keyword\">import</span> exception_handler</span><br><span class=\"line\"> </span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">custom_exception_handler</span><span class=\"params\">(exc, context)</span>:</span></span><br><span class=\"line\">    <span class=\"comment\"># 발생한 exception을 가져온다.</span></span><br><span class=\"line\">    response = exception_handler(exc, context)</span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"keyword\">if</span> response <span class=\"keyword\">is</span> <span class=\"keyword\">not</span> <span class=\"keyword\">None</span>:</span><br><span class=\"line\">        <span class=\"comment\"># response_data = response.data['detail']</span></span><br><span class=\"line\">        <span class=\"comment\"># print('response : ', response.__dict__)</span></span><br><span class=\"line\"> </span><br><span class=\"line\">        <span class=\"comment\"># 예외가 발생할 경우엔 token쿠키를 지워준다</span></span><br><span class=\"line\">        response.delete_cookie(<span class=\"string\">'token'</span>, domain=settings.COOKIE_DOMAIN)</span><br><span class=\"line\"> </span><br><span class=\"line\">        <span class=\"keyword\">return</span> HttpResponseRedirect(reverse(<span class=\"string\">'login'</span>))</span><br><span class=\"line\">    <span class=\"keyword\">else</span>:</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">None</span></span><br></pre></td></tr></table></figure>\n<h4><span id=\"페이지-접근-허가-정보-확인하기\">페이지 접근 허가 정보 확인하기</span></h4>\n<p>접근하고자 하는 페이지가 각 유저별로 인증 정보가 필요하다면 유저의 인증 정보를 확인할 수 있어야 한다.</p>\n<p><a href=\"http://permission.py\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">permission.py</a></p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> rest_framework.permissions <span class=\"keyword\">import</span> BasePermission</span><br><span class=\"line\"> </span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">CustomPermission</span><span class=\"params\">(BasePermission)</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">has_permission</span><span class=\"params\">(self, request, view)</span>:</span></span><br><span class=\"line\">        <span class=\"comment\"># <span class=\"doctag\">TODO:</span> do something</span></span><br><span class=\"line\">        print(<span class=\"string\">'CustomPermission user : '</span>, request.user)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">True</span></span><br></pre></td></tr></table></figure>\n<p>(현재는 어떤 허가 정보도 판단하지 않지만 이 부분에서 유저 정보를 가지고 해당 페이지에 대한 허가 정보를 판단해서 boolean 값으로 반환해준다. True일 경우 허가된 경우고 False일 경우엔 허가되지 않는 유저이다.)</p>\n<p>APIView 에서 허가 정보도 명시적으로 선언해서 확인할 수 있다.</p>\n<p><a href=\"http://view.py\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">view.py</a></p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">RootView</span><span class=\"params\">(APIView)</span>:</span></span><br><span class=\"line\">    authentication_classes = (CustomAuthentication, )</span><br><span class=\"line\">    permission_classes = (CustomPermission, )</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">get</span><span class=\"params\">(self, request)</span>:</span></span><br><span class=\"line\">        <span class=\"string\">\"\"\"</span></span><br><span class=\"line\"><span class=\"string\">        :param request:</span></span><br><span class=\"line\"><span class=\"string\">        :return:</span></span><br><span class=\"line\"><span class=\"string\">        \"\"\"</span></span><br><span class=\"line\">        redirect_url = <span class=\"string\">\"/home\"</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> HttpResponseRedirect(redirect_url)</span><br></pre></td></tr></table></figure>\n<p>마찬가지로 모든 APIView 에서 허가 정보를 확인해야 한다면 settings 에 설정해줄 수 있다. 좀 전에 인증 정보를 작성한 부분에 추가해주자.</p>\n<p><a href=\"http://settings.py\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">settings.py</a></p>\n<figure class=\"highlight roboconf\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">REST_FRAMEWORK = &#123;</span><br><span class=\"line\">    '<span class=\"attribute\">DEFAULT_AUTHENTICATION_CLASSES'</span>: (</span><br><span class=\"line\">        'common<span class=\"variable\">.utils</span><span class=\"variable\">.authentication</span><span class=\"variable\">.CustomAuthentication</span>',</span><br><span class=\"line\">    ),</span><br><span class=\"line\">    'DEFAULT_PERMISSION_CLASSES': (</span><br><span class=\"line\">        'common<span class=\"variable\">.utils</span><span class=\"variable\">.permission</span><span class=\"variable\">.CustomPermission</span>',</span><br><span class=\"line\">    ),</span><br><span class=\"line\">    'EXCEPTION_HANDLER': 'common<span class=\"variable\">.utils</span><span class=\"variable\">.custom_exception_handler</span><span class=\"variable\">.custom_exception_handler</span>'</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>허가 요청에 대한 부분이 추가되었으므로 예외 처리 핸들러에서 이 부분에 대한 처리도 추가해줘야 한다. 요청이 실패할 경우 403 에러가 발생하는데 이 부분에 대한 처리를 해준다.</p>\n<p>custom_exception_handler.py</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> django.conf <span class=\"keyword\">import</span> settings</span><br><span class=\"line\"><span class=\"keyword\">from</span> django.core.urlresolvers <span class=\"keyword\">import</span> reverse</span><br><span class=\"line\"><span class=\"keyword\">from</span> django.http <span class=\"keyword\">import</span> HttpResponseRedirect</span><br><span class=\"line\"><span class=\"keyword\">from</span> rest_framework <span class=\"keyword\">import</span> status</span><br><span class=\"line\"><span class=\"keyword\">from</span> rest_framework.views <span class=\"keyword\">import</span> exception_handler</span><br><span class=\"line\"> </span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">custom_exception_handler</span><span class=\"params\">(exc, context)</span>:</span></span><br><span class=\"line\">    <span class=\"comment\"># 발생한 exception을 가져온다.</span></span><br><span class=\"line\">    response = exception_handler(exc, context)</span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"keyword\">if</span> response <span class=\"keyword\">is</span> <span class=\"keyword\">not</span> <span class=\"keyword\">None</span>:</span><br><span class=\"line\">        <span class=\"comment\"># response_data = response.data['detail']</span></span><br><span class=\"line\">        <span class=\"comment\"># print('response : ', response.__dict__)</span></span><br><span class=\"line\"> </span><br><span class=\"line\">        <span class=\"comment\"># permission 이 안되는 경우엔 block page 로 넘겨준다.</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> response.status_code == status.HTTP_403_FORBIDDEN:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> HttpResponseRedirect(reverse(<span class=\"string\">'block'</span>))</span><br><span class=\"line\"> </span><br><span class=\"line\">        <span class=\"comment\"># 예외가 발생할 경우엔 token쿠키를 지워준다</span></span><br><span class=\"line\">        response.delete_cookie(<span class=\"string\">'token'</span>, domain=settings.COOKIE_DOMAIN)</span><br><span class=\"line\"> </span><br><span class=\"line\">        <span class=\"keyword\">return</span> HttpResponseRedirect(reverse(<span class=\"string\">'login'</span>))</span><br><span class=\"line\">    <span class=\"keyword\">else</span>:</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">None</span></span><br></pre></td></tr></table></figure>\n<p>인증 실패인 경우에는 쿠키에서 토큰 정보를 삭제하고<br>\n로그인 페이지로 보내버리고,<br>\n허가 요청 거부일 경우에는 block 페이지로 보내버렸는데,<br>\n이 부분은 각 사이트의 상황에 맞게 처리해주면 된다.</p>\n<h4><span id=\"로그아웃-하기\">로그아웃 하기</span></h4>\n<p>로그아웃은 간단하다. 단지 쿠키에 저장되어 있는 토큰 값을 지워버리면 되기 때문이다.</p>\n<p><a href=\"http://view.py\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">view.py</a></p>\n<figure class=\"highlight ruby\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">LogoutView</span>(<span class=\"title\">View</span>):</span></span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">get</span><span class=\"params\">(<span class=\"keyword\">self</span>, request)</span></span><span class=\"symbol\">:</span></span><br><span class=\"line\">        response = HttpResponseRedirect(reverse(<span class=\"string\">'login'</span>))</span><br><span class=\"line\">        response.delete_cookie(<span class=\"string\">'token'</span>, domain=settings.COOKIE_DOMAIN)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> response</span><br></pre></td></tr></table></figure>\n<h4><span id=\"요약\">요약</span></h4>\n<p>지금까지 추가된 파일들과 클래스를 정리하자면 다음과 같다.</p>\n<figure class=\"highlight haml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">common/utils/custom_exception_handler.py</span><br><span class=\"line\">    -<span class=\"ruby\"> custom_exception_handler</span></span><br><span class=\"line\"><span class=\"ruby\">common/utils/authentication.py</span></span><br><span class=\"line\"><span class=\"ruby\">    - CustomAuthentication</span></span><br><span class=\"line\"><span class=\"ruby\">common/utils/permission.py</span></span><br><span class=\"line\"><span class=\"ruby\">    - CustomerPermission</span></span><br><span class=\"line\"><span class=\"ruby\">common/utils/jwt_util.py</span></span><br><span class=\"line\"><span class=\"ruby\">    - obtain_token</span></span><br><span class=\"line\"><span class=\"ruby\">    - obtain_user</span></span><br></pre></td></tr></table></figure>\n<p>여기까지 따라왔다면 sso를 완성 할 수 있다. 하나의 사이트에서 동작하는지 여부를 검사하고 싶다면 hosts 에 도메인을 추가해서 테스트 해보자.</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> sudo vim /etc/hosts</span></span><br></pre></td></tr></table></figure>\n<p>/etc/hosts</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">127<span class=\"selector-class\">.0</span><span class=\"selector-class\">.0</span><span class=\"selector-class\">.1</span>   <span class=\"selector-tag\">alpha</span><span class=\"selector-class\">.mysite</span><span class=\"selector-class\">.com</span></span><br><span class=\"line\">127<span class=\"selector-class\">.0</span><span class=\"selector-class\">.0</span><span class=\"selector-class\">.1</span>   <span class=\"selector-tag\">beta</span><span class=\"selector-class\">.mysite</span><span class=\"selector-class\">.com</span></span><br></pre></td></tr></table></figure>\n<p>위와 같이 추가하고 테스트를 해볼 수 있다.</p>\n<h2><span id=\"결론\">결론</span></h2>\n<p>유저의 로그인 검증 후 유저 정보를 jwt 를 이용해서 토큰을 생성한 후, 이 정보는 메인 도메인으로 쿠키에 저장을 한다. 인증이 필요한 페이지의 경우 cookie 에 저장되어 있는 토큰으로 인증된 유저인지 여부를 판단한다. 이 때, 이 토큰 값이 유효하지 않을 경우엔 강제로 로그아웃 처리를 한다. jwt 토큰의 만료 시간을 주어 일정 시간이 지나면 로그인이 풀리도록 했다. 메인 도메인 하위의 3개의 사이트중 하나의 사이트에서만 로그인을 하면 나머지 두개의 사이트에서도 로그인이 되어 있다(같은 쿠키의 토큰을 사용하기 때문)</p>\n<h3><span id=\"추신\">추신</span></h3>\n<p>나름 간단하게 기능을 구현하고자 했는데 로그인 정보를 저장하고 그 토큰을 처리하기 위해 여러 처리가 붙었다. 그리고 토큰 값을 만들고 검증하고 이를 인증하는 코드들을 직접 쓰다보니 조금은 번거로운 작업들이 포함되어 있는 건 사실이다… 때로는 오픈소스를 별다른 이해 없이 기능을 사용하기 위해 가져다 쓰는 것 보다 내부 로직을 이해하고 내가 필요한 부분들만 가져다 쓰는 작업을 하면 재미있기도 하고 후에 문제가 생기거나 기능 변경이 생겼을 때 대처가 빠르다. 물론 이런 방식이 정답을 아닐지는 몰라도 덕분에 재미있는 작업을 했다는 점에 만족한다.</p>\n","site":{"data":{}},"excerpt":"","more":"<p>회사에서 필요에 의해 <a href=\"https://ko.wikipedia.org/wiki/%ED%86%B5%ED%95%A9_%EC%9D%B8%EC%A6%9D,\" title=\"Single Sign On\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">Single Sign On</a>을 구현해야 할 일이 있었다. 3개의 독립된 사이트가 있었고, 각자 로그인을 따로 해야 한다는 점이 사용자 입장에서는 번거로운 일이 될 수 있다는 이유에서 였다.</p>\n<p>3개의 사이트는 하나의 유저테이블을 바라보고 있었기 때문에 충분히 합당한 이유였다. 하지만 django에서 제공하는 기본 유저 테이블을 사용하지 않기 때문에 찾아봤었던 다른 인증 툴들은 그대로 사용하기 까다로워 보였다. 내가 구현해야 하는 상황에는 몇가지 제약사항이 있었다.</p>\n<ol>\n<li>\n<p>로그인을 시도할 때 기존에 제공되는 auth_user 테이블이 아닌 <u>별도의 user 테이블을 사용하고 있다.</u></p>\n</li>\n<li>\n<p>기존에 제공되는 user 모델을 사용하지 않기 때문에 <u>reatframework 에서 기존에 제공하는 인증방식을 그대로 사용할 수 없었다.</u></p>\n</li>\n<li>\n<p>이미 테이블이 존재하고 <u>django 프로젝트에서 migration 을 할 수 없는 상황이다.</u> 기존에 생성되어 있는 테이블들의 구성을 변경할 수는 있지만 그 과정과 절차가 까다롭고 (회사의 사정에 의해), 외래키를 사용하지 않았기 때문에 모델과 테이블간의 100% 싱크가 맞지 않는 상황이었다.</p>\n</li>\n<li>\n<p>위와 같은 이유로 찾아봤었던 <a href=\"https://github.com/jbittel/django-mama-cas,\" title=\"MamaCas\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">MamaCAS</a> 같은 외부 인증툴을 사용할 수 없었다. (migration을 할 수 없었기에 인증을 위해 별도의 테이블을 생성하기 까다로운 상황이었다.)</p>\n</li>\n</ol>\n<p>3개의 프로젝트들이 출시가 얼마 남지 않은 상황이고, 인증을 위해서 별도의 커다란 작업이 있는 것은 별로 좋은 선택이 아니였다. 물론 외부의 다른 툴들을 이용할 수도 있었지만, 단순 인증을 위해 외부툴을 사용하기엔 부담스러운 부분이 있었고, 볼륨을 크게 잡고 싶지 않았다.</p>\n<p>여러 방법을 찾아보면서 몇가지 아이디어가 나왔었다.</p>\n<ol>\n<li>\n<p><a href=\"https://redis.io/,\" title=\"redis\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">redis</a> 를 이용해서 인증 정보를 저장하는 방식</p>\n</li>\n<li>\n<p><a href=\"https://jwt.io/,\" title=\"jwt\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">jwt</a>를 이용해서 javascript 내부에서 localStorage 에 인증 정보를 저장하는 방식</p>\n</li>\n<li>\n<p>cookie에 저장하는 방식</p>\n</li>\n</ol>\n<p>나는 일단 1번의 redis는 제외하기로 했다. 이미 각각의 프로젝트에서 redis를 사용하고 있었고, 인증을 위해 별도의 redis를 띄우는게 번거롭다고 생각했다. 그리고 2번의 localStorage 방식은 javascript에서 ajax통신을 각 페이지별로 날려 유효한 인증을 판단하는 방식이었는데, django 단에서 각 request마다 헤더에 인증 정보를 넣기가 까다로웠다. (하지만 jwt로 토큰을 암호화 하는건 괜찮은 방법이라 생각했다.) 3번의 cookie 방식은 별도의 작업 없이 구현이 가능했지만 3개의 사이트가 같은 메인 도메인 하에 있어야 가능했었다. 어차피 모든 사이트가 회사 내부에서 사용할 목적으로 만들어 지고 있는 프로젝트 였고 같은 메인 도메인만 사용하면 되었기 때문에 나는 3번째의 방법을 사용하기로 했다.</p>\n<p>서론이 길었지만… 그리하여 jwt와 cookie를 이용해서 sso를 구현해 보기로 했다.</p>\n<p>여러 사이트가 있고 각각 로그인(유저 인증)이 필요하고 기능 마다 해당 유저가 접근할 수 있는(허가) 기능이 필요하다.</p>\n<p>(single sign on 을 하다보니 authentication 과 permission 처리가 필요했다…)</p>\n<p>여러 개의 사이트가 공유하는 유저 정보가 있고, 이 정보로 로그인을 하기 때문에 모든 사이트에서 한번의 로그인을 하면 되는 기능이 필요했다.추가적으로 각 사이트 별로는 각자의 허가 정보가 있으므로 이 정보는 공유하지 않고 각자 구현한다. (템플릿만 제공)</p>\n<p>한마디로 요약하면 쿠키에 암호화된 토큰 정보를 도메인이 같은 사이트들끼리 로그인 정보를 공유를 해서 사용하는 방법이다.</p>\n<h2>예상 시나리오</h2>\n<p><a href=\"http://alpha.mysite.com\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">alpha.mysite.com</a>, <a href=\"http://beta.mysite.com\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">beta.mysite.com</a>, <a href=\"http://charlie.mysite.com\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">charlie.mysite.com</a> 3개의 사이트가 있다.<br>\nbeta 에서 로그인을 하고 charlie 사이트에 접속할 경우 이미 로그인이 되어 있다.<br>\n3개의 사이트는 각자 permission 이 따로 존재한다.<br>\nalpha 에서 로그아웃을 할 경우, 나머지 사이트에서도 모두 로그아웃이 된다.<br>\n로그인 정보가 만료되었을 경우에도 로그아웃 처리된다.</p>\n<h2>시나리오 순서 별 설명</h2>\n<ol>\n<li>로그인 시 : <u>jwt token</u> 을 발급해서 request cookie에 저장한다. (이 때, <u>cookie</u> 의 domain은 main domain 값을 넣어준다.&lt;<a href=\"http://mysite.com\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">mysite.com</a>&gt;)</li>\n<li>인증이 필요한 페이지에 접속할 경우<br>\nrest framework 의 <u>authentication</u> class 에서 cookie 에 저장되어 있는 token 값의 유효성을 검사한다.<br>\nrest framework 의 <u>permission</u> class 에서 해당 유저가 기능에 접근 허가 여부를 판단한다.</li>\n<li>로그아웃 시 : cookie 의 token 값을 지워준다.</li>\n<li>추가 정보\n<ul>\n<li>인증에 실패한 경우 : cookie 값을 삭제하고 login 페이지로 보낸다.</li>\n<li>기능 접근 허가가 거부된 경우 : block page 를 표시한다.</li>\n<li>토큰이 만료된 경우 : cookie 값을 삭제하고 login 페이지로 보낸다.</li>\n</ul>\n</li>\n<li>제약사항\n<ul>\n<li>메인 도메인이 동일해야한다.</li>\n<li>permission 정보는 공유하지 않기 때문에 각자 사이트에서 구현해야 한다.</li>\n</ul>\n</li>\n</ol>\n<h2>환경 설정</h2>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-tag\">python</span> 3<span class=\"selector-class\">.4</span><span class=\"selector-class\">.3</span></span><br><span class=\"line\"><span class=\"selector-tag\">django</span> 1<span class=\"selector-class\">.8</span><span class=\"selector-class\">.4</span></span><br><span class=\"line\"><span class=\"selector-tag\">djangorestframework</span> 3<span class=\"selector-class\">.3</span><span class=\"selector-class\">.0</span></span><br></pre></td></tr></table></figure>\n<p>하나씩 시작해보자.</p>\n<h3>패키지 추가하기</h3>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> pip install djangorestframework-jwt</span></span><br></pre></td></tr></table></figure>\n<h3>로그인 하기</h3>\n<h4>토큰 생성하기</h4>\n<p>유저 정보가 맞을 경우 이 정보를 토대로 jwt token을 생성해준다.<br>\njwt_util.py</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> calendar <span class=\"keyword\">import</span> timegm</span><br><span class=\"line\"><span class=\"keyword\">from</span> datetime <span class=\"keyword\">import</span> datetime</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"keyword\">import</span> jwt</span><br><span class=\"line\"><span class=\"keyword\">from</span> rest_framework_jwt.settings <span class=\"keyword\">import</span> api_settings</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"keyword\">from</span> user.models.CustomUser <span class=\"keyword\">import</span> CustomUser</span><br><span class=\"line\"> </span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">obtain_token</span><span class=\"params\">(user: CustomUser)</span>:</span></span><br><span class=\"line\">    jwt_payload_handler = api_settings.JWT_PAYLOAD_HANDLER</span><br><span class=\"line\">    jwt_encode_handler = api_settings.JWT_ENCODE_HANDLER</span><br><span class=\"line\"> </span><br><span class=\"line\">    payload = jwt_payload_handler(user)</span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"comment\"># Include original issued at time for a brand new token,</span></span><br><span class=\"line\">    <span class=\"comment\"># to allow token refresh</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> api_settings.JWT_ALLOW_REFRESH:</span><br><span class=\"line\">        payload[<span class=\"string\">'orig_iat'</span>] = timegm(</span><br><span class=\"line\">            datetime.utcnow().utctimetuple()</span><br><span class=\"line\">        )</span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"keyword\">return</span> jwt_encode_handler(payload)</span><br></pre></td></tr></table></figure>\n<p>jwt 변수들에 대한 자세한 설정은 Rest Framework JWT 에서 확인 할 수 있다. 그리고 default 로 설정된 변수들을 재선언 하고 싶다면 setting 에 해주면 된다.</p>\n<p><a href=\"http://settings.py\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">settings.py</a></p>\n<figure class=\"highlight gcode\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">JWT_AUTH = &#123;</span><br><span class=\"line\">    <span class=\"string\">'JWT_EXPIRATION_DELTA'</span>: datetime.timedelta<span class=\"comment\">(hours=24)</span>,</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4>쿠키에 저장하기</h4>\n<p>사용자가 입력한 아이디와 암호가 맞을 경우 이 정보를 cookie 에 저장을 한다. 저장할 때 domain option 을 main domain(<a href=\"http://mysite.com\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">mysite.com</a>) 로 설정해준다. domain 설정을 해주지 않을 경우 다른 사이트에서 쿠키정보를 공유할 수 없다.</p>\n<p><a href=\"http://view.py\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">view.py</a></p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">LoginView</span><span class=\"params\">(View)</span>:</span></span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">get</span><span class=\"params\">(self, request)</span>:</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> TemplateResponse(request, <span class=\"string\">'account/login.html'</span>)</span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">post</span><span class=\"params\">(self, request)</span>:</span></span><br><span class=\"line\">        username = request.POST.get(<span class=\"string\">'username'</span>)</span><br><span class=\"line\">        password = request.POST.get(<span class=\"string\">'password'</span>)</span><br><span class=\"line\"> </span><br><span class=\"line\">        <span class=\"keyword\">try</span>:</span><br><span class=\"line\">            admin = CustomUser.objects.get(username=username)</span><br><span class=\"line\">            <span class=\"comment\"># 유저 암호 검사하기.</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> security.matches_password(password, admin.password):</span><br><span class=\"line\">                <span class=\"comment\"># obtain jwt token</span></span><br><span class=\"line\">                token = obtain_token(admin)</span><br><span class=\"line\"> </span><br><span class=\"line\">                <span class=\"comment\"># set cookie</span></span><br><span class=\"line\">                response = HttpResponseRedirect(reverse(<span class=\"string\">'root'</span>))</span><br><span class=\"line\">                response.set_cookie(key=<span class=\"string\">'token'</span>, value=token, domain=settings.COOKIE_DOMAIN)</span><br><span class=\"line\">                <span class=\"keyword\">return</span> response</span><br><span class=\"line\">            <span class=\"keyword\">else</span>:</span><br><span class=\"line\">                context = &#123;</span><br><span class=\"line\">                    <span class=\"string\">'error'</span>: <span class=\"string\">'비밀번호가 일치하지 않습니다.'</span></span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">        <span class=\"keyword\">except</span> TAdmin.DoesNotExist:</span><br><span class=\"line\">            context = &#123;</span><br><span class=\"line\">                <span class=\"string\">'error'</span>: <span class=\"string\">'존재하지 않는 ID입니다.'</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">        <span class=\"keyword\">return</span> TemplateResponse(request, <span class=\"string\">'account/login.html'</span>, context)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>공통으로 사용할 메인 도메인 이름은 각 사이트 마다 통일 해줘야 한다.</p>\n<p><a href=\"http://settings.py\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">settings.py</a></p>\n<figure class=\"highlight ini\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">COOKIE_DOMAIN</span> = <span class=\"string\">'mysite.com'</span></span><br></pre></td></tr></table></figure>\n<p>쿠키에 토큰 값을 저장 했으므로 이제 각 사이트에 로그인 되었다고 할 수 있는 첫번 째 단계는 달성했다.</p>\n<h4>페이지 인증정보 확인하기</h4>\n<p>로그인이 되어 있어야 접근할 수 있는 페이지의 경우 로그인 정보를 확인한 후에 정보를 로드한다. RestFramework 에서 제공하는 APIView 를 사용해서 인증 정보를 확인한다.</p>\n<p><a href=\"http://view.py\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">view.py</a></p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">RootView</span><span class=\"params\">(APIView)</span>:</span></span><br><span class=\"line\">    authentication_classes = (CustomAuthentication, )</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">get</span><span class=\"params\">(self, request)</span>:</span></span><br><span class=\"line\">        <span class=\"string\">\"\"\"</span></span><br><span class=\"line\"><span class=\"string\">        :param request:</span></span><br><span class=\"line\"><span class=\"string\">        :return:</span></span><br><span class=\"line\"><span class=\"string\">        \"\"\"</span></span><br><span class=\"line\">        redirect_url = <span class=\"string\">\"/home\"</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> HttpResponseRedirect(redirect_url)</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>여기서 authentication class 를 명시적으로 선언해주었는데, 모든 APIView(인증과 허가가 필요한 페이지의 경우) 에 적용될 수 있도록 settings 에 선언해줄 수 있다.</p>\n<p>(인증 실패나 허가 요청 실패시 처리해줄 수 있는 핸들러도 미리 추가해놓자.)</p>\n<p><a href=\"http://settings.py\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">settings.py</a></p>\n<figure class=\"highlight roboconf\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">REST_FRAMEWORK = &#123;</span><br><span class=\"line\">    '<span class=\"attribute\">DEFAULT_AUTHENTICATION_CLASSES'</span>: (</span><br><span class=\"line\">        'common<span class=\"variable\">.utils</span><span class=\"variable\">.authentication</span><span class=\"variable\">.CustomAuthentication</span>',</span><br><span class=\"line\">    ),</span><br><span class=\"line\">    'EXCEPTION_HANDLER': 'common<span class=\"variable\">.utils</span><span class=\"variable\">.custom_exception_handler</span><span class=\"variable\">.custom_exception_handler</span>'</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>인증 확인은 쿠키에 저장되어 있는 토큰 정보로 확인한다. 토큰으로 정상적인 유저를 가져올 수 있다면 유효한 유저라고 판단한다.</p>\n<p><a href=\"http://authentication.py\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">authentication.py</a></p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> rest_framework <span class=\"keyword\">import</span> authentication</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"keyword\">from</span> common.utils.jwt_util <span class=\"keyword\">import</span> obtain_user</span><br><span class=\"line\"> </span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">CustomAuthentication</span><span class=\"params\">(authentication.BaseAuthentication)</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">authenticate</span><span class=\"params\">(self, request)</span>:</span></span><br><span class=\"line\">        <span class=\"string\">\"\"\"</span></span><br><span class=\"line\"><span class=\"string\">        쿠키에 저장되어 있는 token 값으로 유저를 가져옵니다. 가져오는 상황에서 예외가 발생할 수 있으며 정상적으로 가져온 경우에는 인증된 유저라고 판단합니다.</span></span><br><span class=\"line\"><span class=\"string\">        :param request:</span></span><br><span class=\"line\"><span class=\"string\">        :return:</span></span><br><span class=\"line\"><span class=\"string\">        \"\"\"</span></span><br><span class=\"line\">        token = request.COOKIES.get(<span class=\"string\">'token'</span>, <span class=\"keyword\">None</span>)</span><br><span class=\"line\">        user = obtain_user(token)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> (user, <span class=\"keyword\">None</span>)</span><br></pre></td></tr></table></figure>\n<p>쿠키에 저장되어 있는 토큰을 decode 하여 유효한 정보인지를 판단한다.</p>\n<p>jwt_util.py</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">obtain_user</span><span class=\"params\">(token: str)</span>:</span></span><br><span class=\"line\">    <span class=\"string\">\"\"\"</span></span><br><span class=\"line\"><span class=\"string\">    payload = &#123;'username': 'adm001', 'email': 'test@mysite.com', 'user_id': 1, 'exp': 1462187582&#125;</span></span><br><span class=\"line\"><span class=\"string\">    :param token:</span></span><br><span class=\"line\"><span class=\"string\">    :return:</span></span><br><span class=\"line\"><span class=\"string\">    \"\"\"</span></span><br><span class=\"line\">    jwt_decode_handler = api_settings.JWT_DECODE_HANDLER</span><br><span class=\"line\">    jwt_get_username_from_payload = api_settings.JWT_PAYLOAD_GET_USERNAME_HANDLER</span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> token <span class=\"keyword\">or</span> len(token) == <span class=\"number\">0</span>:  <span class=\"comment\"># case1: 토큰을 분실 했을 경우</span></span><br><span class=\"line\">        <span class=\"keyword\">raise</span> serializers.ValidationError(<span class=\"string\">'Invalid token header. Non credentials provided.'</span>)</span><br><span class=\"line\">        <span class=\"comment\"># raise exceptions.AuthenticationFailed(&#123;'error': 'Invalid token header. No credentials provided.'&#125;)</span></span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"keyword\">try</span>:</span><br><span class=\"line\">        payload = jwt_decode_handler(token)</span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"keyword\">except</span> jwt.ExpiredSignature:  <span class=\"comment\"># case2: 토큰이 만료되었을 경우</span></span><br><span class=\"line\">        <span class=\"keyword\">raise</span> serializers.ValidationError(<span class=\"string\">'Signature has expired.'</span>)</span><br><span class=\"line\">        <span class=\"comment\"># raise exceptions.AuthenticationFailed(&#123;'error': 'Signature has expired.'&#125;)</span></span><br><span class=\"line\">    <span class=\"keyword\">except</span> jwt.DecodeError:  <span class=\"comment\"># case3: 디코드 실패</span></span><br><span class=\"line\">        <span class=\"keyword\">raise</span> serializers.ValidationError(<span class=\"string\">'Error decoding signature.'</span>)</span><br><span class=\"line\">        <span class=\"comment\"># raise exceptions.AuthenticationFailed(&#123;'error': 'Error decoding signature.'&#125;)</span></span><br><span class=\"line\"> </span><br><span class=\"line\">    username = jwt_get_username_from_payload(payload)</span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> username:  <span class=\"comment\"># case4: payload 가 잘못되어 username을 가져올 수 없는 경우</span></span><br><span class=\"line\">        <span class=\"keyword\">raise</span> serializers.ValidationError(<span class=\"string\">'Invalid payload.'</span>)</span><br><span class=\"line\">        <span class=\"comment\"># raise exceptions.AuthenticationFailed(&#123;'error': 'Invalid payload.'&#125;)</span></span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"keyword\">try</span>:</span><br><span class=\"line\">        user = CustomUser.objects.get(username=username)</span><br><span class=\"line\">    <span class=\"keyword\">except</span> CustomUser.DoesNotExist:  <span class=\"comment\"># case5: 해당 유저가 존재하지 않는 경우</span></span><br><span class=\"line\">        <span class=\"keyword\">raise</span> serializers.ValidationError(<span class=\"string\">\"User doesn't exists.\"</span>)</span><br><span class=\"line\">        <span class=\"comment\"># raise exceptions.AuthenticationFailed(&#123;'error': \"User doesn't exists.\"&#125;)</span></span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"keyword\">return</span> user</span><br></pre></td></tr></table></figure>\n<p>여러 이유로 인증에 실패할 경우엔 인증 실패 예외가 발생하게 되는데 이는 따로 핸들러로 처리해주어야 한다. (에러 정보는 response.data 에 담겨온다.)<br>\n(여기서는 인증 실패 예외가 발생할 경우 쿠키에 저장되어 있는 토큰값을 지워버리고 로그인 페이지로 보내버린다.)</p>\n<p>custom_exception_handler.py</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> django.conf <span class=\"keyword\">import</span> settings</span><br><span class=\"line\"><span class=\"keyword\">from</span> django.core.urlresolvers <span class=\"keyword\">import</span> reverse</span><br><span class=\"line\"><span class=\"keyword\">from</span> django.http <span class=\"keyword\">import</span> HttpResponseRedirect</span><br><span class=\"line\"><span class=\"keyword\">from</span> rest_framework <span class=\"keyword\">import</span> status</span><br><span class=\"line\"><span class=\"keyword\">from</span> rest_framework.views <span class=\"keyword\">import</span> exception_handler</span><br><span class=\"line\"> </span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">custom_exception_handler</span><span class=\"params\">(exc, context)</span>:</span></span><br><span class=\"line\">    <span class=\"comment\"># 발생한 exception을 가져온다.</span></span><br><span class=\"line\">    response = exception_handler(exc, context)</span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"keyword\">if</span> response <span class=\"keyword\">is</span> <span class=\"keyword\">not</span> <span class=\"keyword\">None</span>:</span><br><span class=\"line\">        <span class=\"comment\"># response_data = response.data['detail']</span></span><br><span class=\"line\">        <span class=\"comment\"># print('response : ', response.__dict__)</span></span><br><span class=\"line\"> </span><br><span class=\"line\">        <span class=\"comment\"># 예외가 발생할 경우엔 token쿠키를 지워준다</span></span><br><span class=\"line\">        response.delete_cookie(<span class=\"string\">'token'</span>, domain=settings.COOKIE_DOMAIN)</span><br><span class=\"line\"> </span><br><span class=\"line\">        <span class=\"keyword\">return</span> HttpResponseRedirect(reverse(<span class=\"string\">'login'</span>))</span><br><span class=\"line\">    <span class=\"keyword\">else</span>:</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">None</span></span><br></pre></td></tr></table></figure>\n<h4>페이지 접근 허가 정보 확인하기</h4>\n<p>접근하고자 하는 페이지가 각 유저별로 인증 정보가 필요하다면 유저의 인증 정보를 확인할 수 있어야 한다.</p>\n<p><a href=\"http://permission.py\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">permission.py</a></p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> rest_framework.permissions <span class=\"keyword\">import</span> BasePermission</span><br><span class=\"line\"> </span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">CustomPermission</span><span class=\"params\">(BasePermission)</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">has_permission</span><span class=\"params\">(self, request, view)</span>:</span></span><br><span class=\"line\">        <span class=\"comment\"># <span class=\"doctag\">TODO:</span> do something</span></span><br><span class=\"line\">        print(<span class=\"string\">'CustomPermission user : '</span>, request.user)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">True</span></span><br></pre></td></tr></table></figure>\n<p>(현재는 어떤 허가 정보도 판단하지 않지만 이 부분에서 유저 정보를 가지고 해당 페이지에 대한 허가 정보를 판단해서 boolean 값으로 반환해준다. True일 경우 허가된 경우고 False일 경우엔 허가되지 않는 유저이다.)</p>\n<p>APIView 에서 허가 정보도 명시적으로 선언해서 확인할 수 있다.</p>\n<p><a href=\"http://view.py\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">view.py</a></p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">RootView</span><span class=\"params\">(APIView)</span>:</span></span><br><span class=\"line\">    authentication_classes = (CustomAuthentication, )</span><br><span class=\"line\">    permission_classes = (CustomPermission, )</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">get</span><span class=\"params\">(self, request)</span>:</span></span><br><span class=\"line\">        <span class=\"string\">\"\"\"</span></span><br><span class=\"line\"><span class=\"string\">        :param request:</span></span><br><span class=\"line\"><span class=\"string\">        :return:</span></span><br><span class=\"line\"><span class=\"string\">        \"\"\"</span></span><br><span class=\"line\">        redirect_url = <span class=\"string\">\"/home\"</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> HttpResponseRedirect(redirect_url)</span><br></pre></td></tr></table></figure>\n<p>마찬가지로 모든 APIView 에서 허가 정보를 확인해야 한다면 settings 에 설정해줄 수 있다. 좀 전에 인증 정보를 작성한 부분에 추가해주자.</p>\n<p><a href=\"http://settings.py\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">settings.py</a></p>\n<figure class=\"highlight roboconf\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">REST_FRAMEWORK = &#123;</span><br><span class=\"line\">    '<span class=\"attribute\">DEFAULT_AUTHENTICATION_CLASSES'</span>: (</span><br><span class=\"line\">        'common<span class=\"variable\">.utils</span><span class=\"variable\">.authentication</span><span class=\"variable\">.CustomAuthentication</span>',</span><br><span class=\"line\">    ),</span><br><span class=\"line\">    'DEFAULT_PERMISSION_CLASSES': (</span><br><span class=\"line\">        'common<span class=\"variable\">.utils</span><span class=\"variable\">.permission</span><span class=\"variable\">.CustomPermission</span>',</span><br><span class=\"line\">    ),</span><br><span class=\"line\">    'EXCEPTION_HANDLER': 'common<span class=\"variable\">.utils</span><span class=\"variable\">.custom_exception_handler</span><span class=\"variable\">.custom_exception_handler</span>'</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>허가 요청에 대한 부분이 추가되었으므로 예외 처리 핸들러에서 이 부분에 대한 처리도 추가해줘야 한다. 요청이 실패할 경우 403 에러가 발생하는데 이 부분에 대한 처리를 해준다.</p>\n<p>custom_exception_handler.py</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> django.conf <span class=\"keyword\">import</span> settings</span><br><span class=\"line\"><span class=\"keyword\">from</span> django.core.urlresolvers <span class=\"keyword\">import</span> reverse</span><br><span class=\"line\"><span class=\"keyword\">from</span> django.http <span class=\"keyword\">import</span> HttpResponseRedirect</span><br><span class=\"line\"><span class=\"keyword\">from</span> rest_framework <span class=\"keyword\">import</span> status</span><br><span class=\"line\"><span class=\"keyword\">from</span> rest_framework.views <span class=\"keyword\">import</span> exception_handler</span><br><span class=\"line\"> </span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">custom_exception_handler</span><span class=\"params\">(exc, context)</span>:</span></span><br><span class=\"line\">    <span class=\"comment\"># 발생한 exception을 가져온다.</span></span><br><span class=\"line\">    response = exception_handler(exc, context)</span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"keyword\">if</span> response <span class=\"keyword\">is</span> <span class=\"keyword\">not</span> <span class=\"keyword\">None</span>:</span><br><span class=\"line\">        <span class=\"comment\"># response_data = response.data['detail']</span></span><br><span class=\"line\">        <span class=\"comment\"># print('response : ', response.__dict__)</span></span><br><span class=\"line\"> </span><br><span class=\"line\">        <span class=\"comment\"># permission 이 안되는 경우엔 block page 로 넘겨준다.</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> response.status_code == status.HTTP_403_FORBIDDEN:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> HttpResponseRedirect(reverse(<span class=\"string\">'block'</span>))</span><br><span class=\"line\"> </span><br><span class=\"line\">        <span class=\"comment\"># 예외가 발생할 경우엔 token쿠키를 지워준다</span></span><br><span class=\"line\">        response.delete_cookie(<span class=\"string\">'token'</span>, domain=settings.COOKIE_DOMAIN)</span><br><span class=\"line\"> </span><br><span class=\"line\">        <span class=\"keyword\">return</span> HttpResponseRedirect(reverse(<span class=\"string\">'login'</span>))</span><br><span class=\"line\">    <span class=\"keyword\">else</span>:</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">None</span></span><br></pre></td></tr></table></figure>\n<p>인증 실패인 경우에는 쿠키에서 토큰 정보를 삭제하고<br>\n로그인 페이지로 보내버리고,<br>\n허가 요청 거부일 경우에는 block 페이지로 보내버렸는데,<br>\n이 부분은 각 사이트의 상황에 맞게 처리해주면 된다.</p>\n<h4>로그아웃 하기</h4>\n<p>로그아웃은 간단하다. 단지 쿠키에 저장되어 있는 토큰 값을 지워버리면 되기 때문이다.</p>\n<p><a href=\"http://view.py\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">view.py</a></p>\n<figure class=\"highlight ruby\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">LogoutView</span>(<span class=\"title\">View</span>):</span></span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">get</span><span class=\"params\">(<span class=\"keyword\">self</span>, request)</span></span><span class=\"symbol\">:</span></span><br><span class=\"line\">        response = HttpResponseRedirect(reverse(<span class=\"string\">'login'</span>))</span><br><span class=\"line\">        response.delete_cookie(<span class=\"string\">'token'</span>, domain=settings.COOKIE_DOMAIN)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> response</span><br></pre></td></tr></table></figure>\n<h4>요약</h4>\n<p>지금까지 추가된 파일들과 클래스를 정리하자면 다음과 같다.</p>\n<figure class=\"highlight haml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">common/utils/custom_exception_handler.py</span><br><span class=\"line\">    -<span class=\"ruby\"> custom_exception_handler</span></span><br><span class=\"line\"><span class=\"ruby\">common/utils/authentication.py</span></span><br><span class=\"line\"><span class=\"ruby\">    - CustomAuthentication</span></span><br><span class=\"line\"><span class=\"ruby\">common/utils/permission.py</span></span><br><span class=\"line\"><span class=\"ruby\">    - CustomerPermission</span></span><br><span class=\"line\"><span class=\"ruby\">common/utils/jwt_util.py</span></span><br><span class=\"line\"><span class=\"ruby\">    - obtain_token</span></span><br><span class=\"line\"><span class=\"ruby\">    - obtain_user</span></span><br></pre></td></tr></table></figure>\n<p>여기까지 따라왔다면 sso를 완성 할 수 있다. 하나의 사이트에서 동작하는지 여부를 검사하고 싶다면 hosts 에 도메인을 추가해서 테스트 해보자.</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> sudo vim /etc/hosts</span></span><br></pre></td></tr></table></figure>\n<p>/etc/hosts</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">127<span class=\"selector-class\">.0</span><span class=\"selector-class\">.0</span><span class=\"selector-class\">.1</span>   <span class=\"selector-tag\">alpha</span><span class=\"selector-class\">.mysite</span><span class=\"selector-class\">.com</span></span><br><span class=\"line\">127<span class=\"selector-class\">.0</span><span class=\"selector-class\">.0</span><span class=\"selector-class\">.1</span>   <span class=\"selector-tag\">beta</span><span class=\"selector-class\">.mysite</span><span class=\"selector-class\">.com</span></span><br></pre></td></tr></table></figure>\n<p>위와 같이 추가하고 테스트를 해볼 수 있다.</p>\n<h2>결론</h2>\n<p>유저의 로그인 검증 후 유저 정보를 jwt 를 이용해서 토큰을 생성한 후, 이 정보는 메인 도메인으로 쿠키에 저장을 한다. 인증이 필요한 페이지의 경우 cookie 에 저장되어 있는 토큰으로 인증된 유저인지 여부를 판단한다. 이 때, 이 토큰 값이 유효하지 않을 경우엔 강제로 로그아웃 처리를 한다. jwt 토큰의 만료 시간을 주어 일정 시간이 지나면 로그인이 풀리도록 했다. 메인 도메인 하위의 3개의 사이트중 하나의 사이트에서만 로그인을 하면 나머지 두개의 사이트에서도 로그인이 되어 있다(같은 쿠키의 토큰을 사용하기 때문)</p>\n<h3>추신</h3>\n<p>나름 간단하게 기능을 구현하고자 했는데 로그인 정보를 저장하고 그 토큰을 처리하기 위해 여러 처리가 붙었다. 그리고 토큰 값을 만들고 검증하고 이를 인증하는 코드들을 직접 쓰다보니 조금은 번거로운 작업들이 포함되어 있는 건 사실이다… 때로는 오픈소스를 별다른 이해 없이 기능을 사용하기 위해 가져다 쓰는 것 보다 내부 로직을 이해하고 내가 필요한 부분들만 가져다 쓰는 작업을 하면 재미있기도 하고 후에 문제가 생기거나 기능 변경이 생겼을 때 대처가 빠르다. 물론 이런 방식이 정답을 아닐지는 몰라도 덕분에 재미있는 작업을 했다는 점에 만족한다.</p>\n"},{"title":"Spring-boot 에서 Elasticsearch java rest client 사용하기","catalog":true,"date":"2018-03-15T06:33:02.000Z","subtitle":null,"header-img":"/img/header_img/bg.png","_content":"\n### elasticsearch 버전을 올려야 한다.\n검색 서비스를 개선하면서 사내에서 elasticsearch 를 사용하고 있다.  \n처음에 사용했던 버전은 개발 당시의 가장 최근 버전인 [elasticsearch 5.1.1](https://www.elastic.co/guide/en/elasticsearch/reference/5.1/index.html) 버전이다.  \nspring boot 에 연동했는데 [spring-boot-data-elasticsearch-starter](https://mvnrepository.com/artifact/org.springframework.boot/spring-boot-starter-data-elasticsearch) 는 (글을 작성하는) 아직까지도 2.x 버전만 지원하고 있어 직접 [client](https://www.elastic.co/guide/en/elasticsearch/client/java-api/5.1/client.html) 를 붙이기로 했다.   \n  \n  개인적인 생각으로는 나중에 개발이 되어질 spring-boot-data-elasticsearch-starter 로 재구현해도 되긴 하겠지만 elasticsearch를 사용하면서 느낀점은 굳이 starter를 사용할 필요는 없다고 생각한다.  \nrepository와 model로 나뉘어 orm처럼 사용하면 편하기야 할테지만 직접 쿼리를 만들면서 튜닝하는 부분이 재미있기도 하고 좀 더 세세하게 만질 수 있다고 생각하기 때문이다.  \n\nelasticsearch 는 버전업이 빠른 편이다. 6.x 도 꾸준히 올라가는 추세고 곧있으면 7.x 이 나오고 9.x 까지 로드맵이 그려져 있다. 다행히 5.1.x 버전대에서 [rolling upgrade](https://www.elastic.co/guide/en/elasticsearch/reference/5.6/rolling-upgrades.html) 가 가능하기 때문에 5.x 의 마지막 버전인 5.6.8 까지 따라 올라가야 겠다고 생각했다. 그러다가 문득 [State of the official Elasticsearch Java Clients](https://www.elastic.co/blog/state-of-the-official-elasticsearch-java-clients) 라는 포스팅을 보게 되었다. 처음에 java client 를 붙이려면 공식 문서에서는 [transport client](https://www.elastic.co/guide/en/elasticsearch/client/java-api/5.1/transport-client.html) 로 연동하도록 안내한다. 하지만 위의 포스팅의 여러 문제점으로 인해 앞으로는 [Rest client 를 사용하도록 권장하고 있다.](https://www.elastic.co/guide/en/elasticsearch/client/java-api/6.2/client.html)    \n  \nJava Rest Client 는 두가지 방식이 있다.  \n- Java Low Level REST Client  \n- Java High Level REST Client  \n\nlow level 에서는 요청을 직접 만들어서 호출하는 방식인데, 나는 high level로 작업하기로 했다. \n(참고로 rest client는 5.6부터 제공되었다.)  \n  \n### 서론이 조금 길었다. \n내가 elasticsearch 버전을 올리기로 생각한 이유는 [elasticsearch 기술 지원](https://www.elastic.co/support/eol) 때문이다.  \n내가 사용하고 있는 5.1.x 는 2018-06-08 까지만 공식지원을 하고 있다.  \n물론 공식 지원이 끊기더라도 검색 서비스를 구동함에는 큰 지장은 없지만, 메이져 버전이 두개 이상 차이가 나게 되었을 때 버전을 올려야 하는 상황이 오면 rolling upgrade도  사용할 수 없기 때문에 이참에 6.2 로 올라가기로 마음먹었다. 현재 버전에서 한번에 올라가는건 안되기 때문에 다음과 같이 버전올림 순서를 정하기로 했다.  \n\n## 업데이트 순서 \n1. elasticsearch 5.1.1 -> 5.6.8 로 rolling upgrade  \n2. spring-boot elasticsearch java client 5.1.1 -> 5.6.8 로 업데이트 후 배포  \n3. elasticsearch 5.6.8 -> 6.2.2 로 [rolling upgrade](https://www.elastic.co/guide/en/elasticsearch/reference/current/setup-upgrade.html)  \n4. spring-boot elasticsearch java client 5.6.8 -> 6.2.2 로 업데이트 후 배포  \n\n[메이져 버전별로의 호환성](https://www.elastic.co/guide/en/elasticsearch/client/java-rest/5.6/java-rest-high-compatibility.html)에 따라 5.x 버전끼리는 문제없이 통신을 할 수 있다. 물론 6.x 끼리의 버전도 문제가 없었는데, 테스트 결과 5.6.8 에서 6.2.2 도 호출이 가능했다.  \n클라이언트를 보니 모든 기능을 사용할 수 있지는 않고 부분적인 기능들만 사용가능할 것으로 보인다. 그리고 상위 버전 호환은 괜찮아도 하위 버전 호환은 기능이 구현되지 않을 가능성이 있어 문제의 여지가 있다.\n\n### rolling upgrade\n현재 사용하고 있는 rolling upgrade 스크립트이다. 구글링 해보니 좀 더 유려한 스크립트 들이 많이 있는데 나는 간단한 동작들만 사용하는 중이다.   \n\n일단 구동중인 es를 내린다.  \n`shut_down.sh`  \n\n```bash\n#!/usr/bin/env bash\n\n# disable shard allocation\ncurl -XPUT 'localhost:9200/_cluster/settings?pretty=true' -d '{\n    \"transient\" : {\n        \"cluster.routing.allocation.enable\" : \"none\"\n    }\n}'\n\n# shutdown\nsudo service elasticsearch stop\n```\n\n정상적으로 내려간 것을 확인한 후 elasticsearch 버전을 올려 재설치하도록 한다. 그리고 다시 구동시켜 주자.   \n\n`start.sh`  \n\n```bash\n#!/usr/bin/env bash\n\nsudo service elasticsearch start\n\nSTATUS=\"\"\nwhile ! [[ \"$STATUS\" =~ (\\\"tagline\\\" : \\\"You Know, for Search\\\") ]];\ndo\n    echo \"fetching http://localhost:9200\"\n    STATUS=`curl -sS -XGET http://localhost:9200`\n    sleep 1\ndone\n\ncurl -XPUT 'localhost:9200/_cluster/settings?pretty=true' -d '{\n    \"transient\" : {\n        \"cluster.routing.allocation.enable\" : \"all\"\n    }\n}'\n```\n자 이제 버전도 올렸으니 client 를 변경해보도록 하자.  \n\n## client 에서 rest client\n위에서 설명한 것과 같이 앞으로는 rest client 를 써야만 하는 시점이 온다.  \n지금 당장은 바꾸지 않아도 되지만 (완성이 되지 않아 할 수도 없지만) 어떻게 바뀌는지 느낌만 살펴보자.    \n기존에 transport layer로 붙는 client를 rest client로 변경하는 작업을 해보자. 일단 설정부터 변경해야 한다.  \n\n### setting\n`build.gradle`  \n\n```gradle\ndependencies {\n    compile 'org.elasticsearch:elasticsearch:6.2.2'\n    compile 'org.elasticsearch.client:elasticsearch-rest-high-level-client:6.2.2'\n}\n```\n\n그리고 기존에 붙었던 `9300`포트가 아닌 `9200`포트로 접속해야 한다.    \n`application.yml`  \n\n```yml\nelasticsearch:\n  hosts: host1.com, host2.com\n  port: 9200\n```\n  \n### configuration\n설정파일을 고쳤으면 configuration쪽을 손봐주도록 하자.  \n기존의 config와 비교를 해보면 다음과 같다.  \n\n`기존 ElascitsearchConfig.java`  \n\n```java\n@Configuration\npublic class ElasticsearchConfig {\n\n    @Value(\"#{'${elasticsearch.hosts}'.split(',')}\")\n    private List<String> hosts;\n\n    @Value(\"${elasticsearch.port}\")\n    private int port;\n\n    @Bean\n    public Client client() throws Exception {\n        final Settings settings = Settings.builder()\n                .put(\"client.transport.sniff\", true)\n                .build();\n\n        PreBuiltTransportClient client = new PreBuiltTransportClient(settings);\n        for(String host : hosts) {\n            InetSocketTransportAddress item = new InetSocketTransportAddress(InetAddress.getByName(host), port);\n            client.addTransportAddresses(item);\n        }\n\n        return client;\n    }\n}\n```\n\n`변경된 ElascitsearchConfig.java`  \n\n```java\n@Configuration\npublic class ElasticsearchConfig {\n    @Value(\"#{'${elasticsearch.hosts}'.split(',')}\")\n    private List<String> hosts;\n    \n    @Value(\"${elasticsearch.port}\")\n    private int port;\n\n    @Bean\n    public RestHighLevelClient getRestClient() {\n\n        List<HttpHost> hostList = new ArrayList<>();\n        for(String host : hosts) {\n            hostList.add(new HttpHost(host, port, \"http\"));\n        }\n\n        RestClientBuilder builder = RestClient.builder(hostList.toArray(new HttpHost[hostList.size()]));\n        return new RestHighLevelClient(builder);\n    }\n}\n```\n\n### service\n\n약간씩 달라진 부분들을 살펴보자. 큰틀은 변경되진 않았고 호출하는 클래스나 메소드들이 조금씩 변경되었다.  \n개인 적인 느낌으로는 각 클래스별로 역할이 좀 더 충실해졌다고 생각이 들었다.  \n\n`create`  \n\n```java\n// before\nClient client;\nIndicesAdminClient adminClient = client.admin().indices();\nCreateIndexResponse createIndexResponse = adminClient.prepareCreate(\"index_name\")\n            .setSettings(seriesSettings())\n            .addMapping(\"type name\", seriesIndex()).get();\n\n// after\nRestHighLevelClient client;\nCreateIndexRequest request = new CreateIndexRequest(\"index_name\");\nrequest.settings(seriesSettings(), XContentType.JSON);\nrequest.mapping(\"type_name\", seriesIndex(), XContentType.JSON);\nclient.indices().create(request);\n```\n\n`search query`  \n\n```java\n// common\nQueryBuilder qb = QueryBuilders.matchQuery(\"text\", text);\n\n// before\nClient client;\nSearchResponse response = client.prepareSearch(\"index_name\").setTypes(\"type_name\").setQuery(qb).get();\n\n// after\nRestHighLevelClient client;\nSearchSourceBuilder searchSourceBuilder = new SearchSourceBuilder().query(qb);\nSearchRequest searchRequest = new SearchRequest(\"index_name\").types(\"type_name\").source(searchSourceBuilder);\nSearchResponse response = client.search(searchRequest);\n\n// common\nresponse.getHits().forEach(item -> {\n\t// do something\n});\n```\n\n간단하게 index 를 만들고 검색하는 부분까지의 메소드들을 보았다. 나는 여기에 추가로 alias, exists, multi_search 등을 사용하고 있지만 아직까지 6.2.x 에는 해당 메소드가 없다. 어떻게든 해보려고 엔진소스를 들어가서 한참을 살펴보다가 혹시나 해서 master 브랜치를 받아보니 해당 메소드들이 있더라.. (현재 master 브랜치의 버전은 7.0.0-alpha1 이다.)   \n\n\n## 결론\n미리 적용을 해놓을까 해서 버전별로 소스를 살펴 보았지만 아직까지 모든 메소드들이 구현되어 있지 않기도 하고 [java client가 없어지려면 8.0 까지 올라가야 하니](https://www.elastic.co/guide/en/elasticsearch/client/java-api/5.6/client.html) 아직은 조금 여유가 있어보인다.  \n그래도 버전이 올라가는 속도를 보면 7.0 메이져 버전이 나오고 rest client가 완성이 되었을 때 슬슬 적용하면 될 것 같다. ~~세수하러 왔다가 물만 먹고 가는 느낌~~\n\n\n\n\n\n\n","source":"_posts/elasticsearch-rest-client.md","raw":"---\ntitle: Spring-boot 에서 Elasticsearch java rest client 사용하기\ncatalog: true\ndate: 2018-03-15 15:33:02\nsubtitle:\nheader-img: \"/img/header_img/bg.png\"\ntags:\n- springboot\n- elasticsearch\n- restclient\n- javaclient\n- transportlyer\n---\n\n### elasticsearch 버전을 올려야 한다.\n검색 서비스를 개선하면서 사내에서 elasticsearch 를 사용하고 있다.  \n처음에 사용했던 버전은 개발 당시의 가장 최근 버전인 [elasticsearch 5.1.1](https://www.elastic.co/guide/en/elasticsearch/reference/5.1/index.html) 버전이다.  \nspring boot 에 연동했는데 [spring-boot-data-elasticsearch-starter](https://mvnrepository.com/artifact/org.springframework.boot/spring-boot-starter-data-elasticsearch) 는 (글을 작성하는) 아직까지도 2.x 버전만 지원하고 있어 직접 [client](https://www.elastic.co/guide/en/elasticsearch/client/java-api/5.1/client.html) 를 붙이기로 했다.   \n  \n  개인적인 생각으로는 나중에 개발이 되어질 spring-boot-data-elasticsearch-starter 로 재구현해도 되긴 하겠지만 elasticsearch를 사용하면서 느낀점은 굳이 starter를 사용할 필요는 없다고 생각한다.  \nrepository와 model로 나뉘어 orm처럼 사용하면 편하기야 할테지만 직접 쿼리를 만들면서 튜닝하는 부분이 재미있기도 하고 좀 더 세세하게 만질 수 있다고 생각하기 때문이다.  \n\nelasticsearch 는 버전업이 빠른 편이다. 6.x 도 꾸준히 올라가는 추세고 곧있으면 7.x 이 나오고 9.x 까지 로드맵이 그려져 있다. 다행히 5.1.x 버전대에서 [rolling upgrade](https://www.elastic.co/guide/en/elasticsearch/reference/5.6/rolling-upgrades.html) 가 가능하기 때문에 5.x 의 마지막 버전인 5.6.8 까지 따라 올라가야 겠다고 생각했다. 그러다가 문득 [State of the official Elasticsearch Java Clients](https://www.elastic.co/blog/state-of-the-official-elasticsearch-java-clients) 라는 포스팅을 보게 되었다. 처음에 java client 를 붙이려면 공식 문서에서는 [transport client](https://www.elastic.co/guide/en/elasticsearch/client/java-api/5.1/transport-client.html) 로 연동하도록 안내한다. 하지만 위의 포스팅의 여러 문제점으로 인해 앞으로는 [Rest client 를 사용하도록 권장하고 있다.](https://www.elastic.co/guide/en/elasticsearch/client/java-api/6.2/client.html)    \n  \nJava Rest Client 는 두가지 방식이 있다.  \n- Java Low Level REST Client  \n- Java High Level REST Client  \n\nlow level 에서는 요청을 직접 만들어서 호출하는 방식인데, 나는 high level로 작업하기로 했다. \n(참고로 rest client는 5.6부터 제공되었다.)  \n  \n### 서론이 조금 길었다. \n내가 elasticsearch 버전을 올리기로 생각한 이유는 [elasticsearch 기술 지원](https://www.elastic.co/support/eol) 때문이다.  \n내가 사용하고 있는 5.1.x 는 2018-06-08 까지만 공식지원을 하고 있다.  \n물론 공식 지원이 끊기더라도 검색 서비스를 구동함에는 큰 지장은 없지만, 메이져 버전이 두개 이상 차이가 나게 되었을 때 버전을 올려야 하는 상황이 오면 rolling upgrade도  사용할 수 없기 때문에 이참에 6.2 로 올라가기로 마음먹었다. 현재 버전에서 한번에 올라가는건 안되기 때문에 다음과 같이 버전올림 순서를 정하기로 했다.  \n\n## 업데이트 순서 \n1. elasticsearch 5.1.1 -> 5.6.8 로 rolling upgrade  \n2. spring-boot elasticsearch java client 5.1.1 -> 5.6.8 로 업데이트 후 배포  \n3. elasticsearch 5.6.8 -> 6.2.2 로 [rolling upgrade](https://www.elastic.co/guide/en/elasticsearch/reference/current/setup-upgrade.html)  \n4. spring-boot elasticsearch java client 5.6.8 -> 6.2.2 로 업데이트 후 배포  \n\n[메이져 버전별로의 호환성](https://www.elastic.co/guide/en/elasticsearch/client/java-rest/5.6/java-rest-high-compatibility.html)에 따라 5.x 버전끼리는 문제없이 통신을 할 수 있다. 물론 6.x 끼리의 버전도 문제가 없었는데, 테스트 결과 5.6.8 에서 6.2.2 도 호출이 가능했다.  \n클라이언트를 보니 모든 기능을 사용할 수 있지는 않고 부분적인 기능들만 사용가능할 것으로 보인다. 그리고 상위 버전 호환은 괜찮아도 하위 버전 호환은 기능이 구현되지 않을 가능성이 있어 문제의 여지가 있다.\n\n### rolling upgrade\n현재 사용하고 있는 rolling upgrade 스크립트이다. 구글링 해보니 좀 더 유려한 스크립트 들이 많이 있는데 나는 간단한 동작들만 사용하는 중이다.   \n\n일단 구동중인 es를 내린다.  \n`shut_down.sh`  \n\n```bash\n#!/usr/bin/env bash\n\n# disable shard allocation\ncurl -XPUT 'localhost:9200/_cluster/settings?pretty=true' -d '{\n    \"transient\" : {\n        \"cluster.routing.allocation.enable\" : \"none\"\n    }\n}'\n\n# shutdown\nsudo service elasticsearch stop\n```\n\n정상적으로 내려간 것을 확인한 후 elasticsearch 버전을 올려 재설치하도록 한다. 그리고 다시 구동시켜 주자.   \n\n`start.sh`  \n\n```bash\n#!/usr/bin/env bash\n\nsudo service elasticsearch start\n\nSTATUS=\"\"\nwhile ! [[ \"$STATUS\" =~ (\\\"tagline\\\" : \\\"You Know, for Search\\\") ]];\ndo\n    echo \"fetching http://localhost:9200\"\n    STATUS=`curl -sS -XGET http://localhost:9200`\n    sleep 1\ndone\n\ncurl -XPUT 'localhost:9200/_cluster/settings?pretty=true' -d '{\n    \"transient\" : {\n        \"cluster.routing.allocation.enable\" : \"all\"\n    }\n}'\n```\n자 이제 버전도 올렸으니 client 를 변경해보도록 하자.  \n\n## client 에서 rest client\n위에서 설명한 것과 같이 앞으로는 rest client 를 써야만 하는 시점이 온다.  \n지금 당장은 바꾸지 않아도 되지만 (완성이 되지 않아 할 수도 없지만) 어떻게 바뀌는지 느낌만 살펴보자.    \n기존에 transport layer로 붙는 client를 rest client로 변경하는 작업을 해보자. 일단 설정부터 변경해야 한다.  \n\n### setting\n`build.gradle`  \n\n```gradle\ndependencies {\n    compile 'org.elasticsearch:elasticsearch:6.2.2'\n    compile 'org.elasticsearch.client:elasticsearch-rest-high-level-client:6.2.2'\n}\n```\n\n그리고 기존에 붙었던 `9300`포트가 아닌 `9200`포트로 접속해야 한다.    \n`application.yml`  \n\n```yml\nelasticsearch:\n  hosts: host1.com, host2.com\n  port: 9200\n```\n  \n### configuration\n설정파일을 고쳤으면 configuration쪽을 손봐주도록 하자.  \n기존의 config와 비교를 해보면 다음과 같다.  \n\n`기존 ElascitsearchConfig.java`  \n\n```java\n@Configuration\npublic class ElasticsearchConfig {\n\n    @Value(\"#{'${elasticsearch.hosts}'.split(',')}\")\n    private List<String> hosts;\n\n    @Value(\"${elasticsearch.port}\")\n    private int port;\n\n    @Bean\n    public Client client() throws Exception {\n        final Settings settings = Settings.builder()\n                .put(\"client.transport.sniff\", true)\n                .build();\n\n        PreBuiltTransportClient client = new PreBuiltTransportClient(settings);\n        for(String host : hosts) {\n            InetSocketTransportAddress item = new InetSocketTransportAddress(InetAddress.getByName(host), port);\n            client.addTransportAddresses(item);\n        }\n\n        return client;\n    }\n}\n```\n\n`변경된 ElascitsearchConfig.java`  \n\n```java\n@Configuration\npublic class ElasticsearchConfig {\n    @Value(\"#{'${elasticsearch.hosts}'.split(',')}\")\n    private List<String> hosts;\n    \n    @Value(\"${elasticsearch.port}\")\n    private int port;\n\n    @Bean\n    public RestHighLevelClient getRestClient() {\n\n        List<HttpHost> hostList = new ArrayList<>();\n        for(String host : hosts) {\n            hostList.add(new HttpHost(host, port, \"http\"));\n        }\n\n        RestClientBuilder builder = RestClient.builder(hostList.toArray(new HttpHost[hostList.size()]));\n        return new RestHighLevelClient(builder);\n    }\n}\n```\n\n### service\n\n약간씩 달라진 부분들을 살펴보자. 큰틀은 변경되진 않았고 호출하는 클래스나 메소드들이 조금씩 변경되었다.  \n개인 적인 느낌으로는 각 클래스별로 역할이 좀 더 충실해졌다고 생각이 들었다.  \n\n`create`  \n\n```java\n// before\nClient client;\nIndicesAdminClient adminClient = client.admin().indices();\nCreateIndexResponse createIndexResponse = adminClient.prepareCreate(\"index_name\")\n            .setSettings(seriesSettings())\n            .addMapping(\"type name\", seriesIndex()).get();\n\n// after\nRestHighLevelClient client;\nCreateIndexRequest request = new CreateIndexRequest(\"index_name\");\nrequest.settings(seriesSettings(), XContentType.JSON);\nrequest.mapping(\"type_name\", seriesIndex(), XContentType.JSON);\nclient.indices().create(request);\n```\n\n`search query`  \n\n```java\n// common\nQueryBuilder qb = QueryBuilders.matchQuery(\"text\", text);\n\n// before\nClient client;\nSearchResponse response = client.prepareSearch(\"index_name\").setTypes(\"type_name\").setQuery(qb).get();\n\n// after\nRestHighLevelClient client;\nSearchSourceBuilder searchSourceBuilder = new SearchSourceBuilder().query(qb);\nSearchRequest searchRequest = new SearchRequest(\"index_name\").types(\"type_name\").source(searchSourceBuilder);\nSearchResponse response = client.search(searchRequest);\n\n// common\nresponse.getHits().forEach(item -> {\n\t// do something\n});\n```\n\n간단하게 index 를 만들고 검색하는 부분까지의 메소드들을 보았다. 나는 여기에 추가로 alias, exists, multi_search 등을 사용하고 있지만 아직까지 6.2.x 에는 해당 메소드가 없다. 어떻게든 해보려고 엔진소스를 들어가서 한참을 살펴보다가 혹시나 해서 master 브랜치를 받아보니 해당 메소드들이 있더라.. (현재 master 브랜치의 버전은 7.0.0-alpha1 이다.)   \n\n\n## 결론\n미리 적용을 해놓을까 해서 버전별로 소스를 살펴 보았지만 아직까지 모든 메소드들이 구현되어 있지 않기도 하고 [java client가 없어지려면 8.0 까지 올라가야 하니](https://www.elastic.co/guide/en/elasticsearch/client/java-api/5.6/client.html) 아직은 조금 여유가 있어보인다.  \n그래도 버전이 올라가는 속도를 보면 7.0 메이져 버전이 나오고 rest client가 완성이 되었을 때 슬슬 적용하면 될 것 같다. ~~세수하러 왔다가 물만 먹고 가는 느낌~~\n\n\n\n\n\n\n","slug":"elasticsearch-rest-client","published":1,"updated":"2018-04-15T08:09:00.127Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjq98sopl00088ghh9207svub","content":"<h3><span id=\"elasticsearch-버전을-올려야-한다\">elasticsearch 버전을 올려야 한다.</span></h3>\n<p>검색 서비스를 개선하면서 사내에서 elasticsearch 를 사용하고 있다.<br>\n처음에 사용했던 버전은 개발 당시의 가장 최근 버전인 <a href=\"https://www.elastic.co/guide/en/elasticsearch/reference/5.1/index.html\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">elasticsearch 5.1.1</a> 버전이다.<br>\nspring boot 에 연동했는데 <a href=\"https://mvnrepository.com/artifact/org.springframework.boot/spring-boot-starter-data-elasticsearch\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">spring-boot-data-elasticsearch-starter</a> 는 (글을 작성하는) 아직까지도 2.x 버전만 지원하고 있어 직접 <a href=\"https://www.elastic.co/guide/en/elasticsearch/client/java-api/5.1/client.html\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">client</a> 를 붙이기로 했다.</p>\n<p>개인적인 생각으로는 나중에 개발이 되어질 spring-boot-data-elasticsearch-starter 로 재구현해도 되긴 하겠지만 elasticsearch를 사용하면서 느낀점은 굳이 starter를 사용할 필요는 없다고 생각한다.<br>\nrepository와 model로 나뉘어 orm처럼 사용하면 편하기야 할테지만 직접 쿼리를 만들면서 튜닝하는 부분이 재미있기도 하고 좀 더 세세하게 만질 수 있다고 생각하기 때문이다.</p>\n<p>elasticsearch 는 버전업이 빠른 편이다. 6.x 도 꾸준히 올라가는 추세고 곧있으면 7.x 이 나오고 9.x 까지 로드맵이 그려져 있다. 다행히 5.1.x 버전대에서 <a href=\"https://www.elastic.co/guide/en/elasticsearch/reference/5.6/rolling-upgrades.html\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">rolling upgrade</a> 가 가능하기 때문에 5.x 의 마지막 버전인 5.6.8 까지 따라 올라가야 겠다고 생각했다. 그러다가 문득 <a href=\"https://www.elastic.co/blog/state-of-the-official-elasticsearch-java-clients\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">State of the official Elasticsearch Java Clients</a> 라는 포스팅을 보게 되었다. 처음에 java client 를 붙이려면 공식 문서에서는 <a href=\"https://www.elastic.co/guide/en/elasticsearch/client/java-api/5.1/transport-client.html\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">transport client</a> 로 연동하도록 안내한다. 하지만 위의 포스팅의 여러 문제점으로 인해 앞으로는 <a href=\"https://www.elastic.co/guide/en/elasticsearch/client/java-api/6.2/client.html\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">Rest client 를 사용하도록 권장하고 있다.</a></p>\n<p>Java Rest Client 는 두가지 방식이 있다.</p>\n<ul>\n<li>Java Low Level REST Client</li>\n<li>Java High Level REST Client</li>\n</ul>\n<p>low level 에서는 요청을 직접 만들어서 호출하는 방식인데, 나는 high level로 작업하기로 했다.<br>\n(참고로 rest client는 5.6부터 제공되었다.)</p>\n<h3><span id=\"서론이-조금-길었다\">서론이 조금 길었다.</span></h3>\n<p>내가 elasticsearch 버전을 올리기로 생각한 이유는 <a href=\"https://www.elastic.co/support/eol\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">elasticsearch 기술 지원</a> 때문이다.<br>\n내가 사용하고 있는 5.1.x 는 2018-06-08 까지만 공식지원을 하고 있다.<br>\n물론 공식 지원이 끊기더라도 검색 서비스를 구동함에는 큰 지장은 없지만, 메이져 버전이 두개 이상 차이가 나게 되었을 때 버전을 올려야 하는 상황이 오면 rolling upgrade도  사용할 수 없기 때문에 이참에 6.2 로 올라가기로 마음먹었다. 현재 버전에서 한번에 올라가는건 안되기 때문에 다음과 같이 버전올림 순서를 정하기로 했다.</p>\n<h2><span id=\"업데이트-순서\">업데이트 순서</span></h2>\n<ol>\n<li>elasticsearch 5.1.1 -&gt; 5.6.8 로 rolling upgrade</li>\n<li>spring-boot elasticsearch java client 5.1.1 -&gt; 5.6.8 로 업데이트 후 배포</li>\n<li>elasticsearch 5.6.8 -&gt; 6.2.2 로 <a href=\"https://www.elastic.co/guide/en/elasticsearch/reference/current/setup-upgrade.html\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">rolling upgrade</a></li>\n<li>spring-boot elasticsearch java client 5.6.8 -&gt; 6.2.2 로 업데이트 후 배포</li>\n</ol>\n<p><a href=\"https://www.elastic.co/guide/en/elasticsearch/client/java-rest/5.6/java-rest-high-compatibility.html\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">메이져 버전별로의 호환성</a>에 따라 5.x 버전끼리는 문제없이 통신을 할 수 있다. 물론 6.x 끼리의 버전도 문제가 없었는데, 테스트 결과 5.6.8 에서 6.2.2 도 호출이 가능했다.<br>\n클라이언트를 보니 모든 기능을 사용할 수 있지는 않고 부분적인 기능들만 사용가능할 것으로 보인다. 그리고 상위 버전 호환은 괜찮아도 하위 버전 호환은 기능이 구현되지 않을 가능성이 있어 문제의 여지가 있다.</p>\n<h3><span id=\"rolling-upgrade\">rolling upgrade</span></h3>\n<p>현재 사용하고 있는 rolling upgrade 스크립트이다. 구글링 해보니 좀 더 유려한 스크립트 들이 많이 있는데 나는 간단한 동작들만 사용하는 중이다.</p>\n<p>일단 구동중인 es를 내린다.<br>\n<code>shut_down.sh</code></p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#!/usr/bin/env bash</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># disable shard allocation</span></span><br><span class=\"line\">curl -XPUT <span class=\"string\">'localhost:9200/_cluster/settings?pretty=true'</span> -d <span class=\"string\">'&#123;</span></span><br><span class=\"line\"><span class=\"string\">    \"transient\" : &#123;</span></span><br><span class=\"line\"><span class=\"string\">        \"cluster.routing.allocation.enable\" : \"none\"</span></span><br><span class=\"line\"><span class=\"string\">    &#125;</span></span><br><span class=\"line\"><span class=\"string\">&#125;'</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># shutdown</span></span><br><span class=\"line\">sudo service elasticsearch stop</span><br></pre></td></tr></table></figure>\n<p>정상적으로 내려간 것을 확인한 후 elasticsearch 버전을 올려 재설치하도록 한다. 그리고 다시 구동시켜 주자.</p>\n<p><code>start.sh</code></p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#!/usr/bin/env bash</span></span><br><span class=\"line\"></span><br><span class=\"line\">sudo service elasticsearch start</span><br><span class=\"line\"></span><br><span class=\"line\">STATUS=<span class=\"string\">\"\"</span></span><br><span class=\"line\"><span class=\"keyword\">while</span> ! [[ <span class=\"string\">\"<span class=\"variable\">$STATUS</span>\"</span> =~ (\\<span class=\"string\">\"tagline\\\" : \\\"You Know, for Search\\\") ]];</span></span><br><span class=\"line\"><span class=\"string\">do</span></span><br><span class=\"line\"><span class=\"string\">    echo \"</span>fetching http://localhost:9200<span class=\"string\">\"</span></span><br><span class=\"line\"><span class=\"string\">    STATUS=`curl -sS -XGET http://localhost:9200`</span></span><br><span class=\"line\"><span class=\"string\">    sleep 1</span></span><br><span class=\"line\"><span class=\"string\">done</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">curl -XPUT 'localhost:9200/_cluster/settings?pretty=true' -d '&#123;</span></span><br><span class=\"line\"><span class=\"string\">    \"</span>transient<span class=\"string\">\" : &#123;</span></span><br><span class=\"line\"><span class=\"string\">        \"</span>cluster.routing.allocation.enable<span class=\"string\">\" : \"</span>all<span class=\"string\">\"</span></span><br><span class=\"line\"><span class=\"string\">    &#125;</span></span><br><span class=\"line\"><span class=\"string\">&#125;'</span></span><br></pre></td></tr></table></figure>\n<p>자 이제 버전도 올렸으니 client 를 변경해보도록 하자.</p>\n<h2><span id=\"client-에서-rest-client\">client 에서 rest client</span></h2>\n<p>위에서 설명한 것과 같이 앞으로는 rest client 를 써야만 하는 시점이 온다.<br>\n지금 당장은 바꾸지 않아도 되지만 (완성이 되지 않아 할 수도 없지만) 어떻게 바뀌는지 느낌만 살펴보자.<br>\n기존에 transport layer로 붙는 client를 rest client로 변경하는 작업을 해보자. 일단 설정부터 변경해야 한다.</p>\n<h3><span id=\"setting\">setting</span></h3>\n<p><code>build.gradle</code></p>\n<figure class=\"highlight gradle\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">dependencies</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">compile</span> <span class=\"string\">'org.elasticsearch:elasticsearch:6.2.2'</span></span><br><span class=\"line\">    <span class=\"keyword\">compile</span> <span class=\"string\">'org.elasticsearch.client:elasticsearch-rest-high-level-client:6.2.2'</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>그리고 기존에 붙었던 <code>9300</code>포트가 아닌 <code>9200</code>포트로 접속해야 한다.<br>\n<code>application.yml</code></p>\n<figure class=\"highlight yml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">elasticsearch:</span></span><br><span class=\"line\"><span class=\"attr\">  hosts:</span> <span class=\"string\">host1.com,</span> <span class=\"string\">host2.com</span></span><br><span class=\"line\"><span class=\"attr\">  port:</span> <span class=\"number\">9200</span></span><br></pre></td></tr></table></figure>\n<h3><span id=\"configuration\">configuration</span></h3>\n<p>설정파일을 고쳤으면 configuration쪽을 손봐주도록 하자.<br>\n기존의 config와 비교를 해보면 다음과 같다.</p>\n<p><code>기존 ElascitsearchConfig.java</code></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Configuration</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ElasticsearchConfig</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Value</span>(<span class=\"string\">\"#&#123;'$&#123;elasticsearch.hosts&#125;'.split(',')&#125;\"</span>)</span><br><span class=\"line\">    <span class=\"keyword\">private</span> List&lt;String&gt; hosts;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Value</span>(<span class=\"string\">\"$&#123;elasticsearch.port&#125;\"</span>)</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> port;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Bean</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Client <span class=\"title\">client</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">final</span> Settings settings = Settings.builder()</span><br><span class=\"line\">                .put(<span class=\"string\">\"client.transport.sniff\"</span>, <span class=\"keyword\">true</span>)</span><br><span class=\"line\">                .build();</span><br><span class=\"line\"></span><br><span class=\"line\">        PreBuiltTransportClient client = <span class=\"keyword\">new</span> PreBuiltTransportClient(settings);</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(String host : hosts) &#123;</span><br><span class=\"line\">            InetSocketTransportAddress item = <span class=\"keyword\">new</span> InetSocketTransportAddress(InetAddress.getByName(host), port);</span><br><span class=\"line\">            client.addTransportAddresses(item);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> client;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><code>변경된 ElascitsearchConfig.java</code></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Configuration</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ElasticsearchConfig</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Value</span>(<span class=\"string\">\"#&#123;'$&#123;elasticsearch.hosts&#125;'.split(',')&#125;\"</span>)</span><br><span class=\"line\">    <span class=\"keyword\">private</span> List&lt;String&gt; hosts;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"meta\">@Value</span>(<span class=\"string\">\"$&#123;elasticsearch.port&#125;\"</span>)</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> port;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Bean</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> RestHighLevelClient <span class=\"title\">getRestClient</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        List&lt;HttpHost&gt; hostList = <span class=\"keyword\">new</span> ArrayList&lt;&gt;();</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(String host : hosts) &#123;</span><br><span class=\"line\">            hostList.add(<span class=\"keyword\">new</span> HttpHost(host, port, <span class=\"string\">\"http\"</span>));</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        RestClientBuilder builder = RestClient.builder(hostList.toArray(<span class=\"keyword\">new</span> HttpHost[hostList.size()]));</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> RestHighLevelClient(builder);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3><span id=\"service\">service</span></h3>\n<p>약간씩 달라진 부분들을 살펴보자. 큰틀은 변경되진 않았고 호출하는 클래스나 메소드들이 조금씩 변경되었다.<br>\n개인 적인 느낌으로는 각 클래스별로 역할이 좀 더 충실해졌다고 생각이 들었다.</p>\n<p><code>create</code></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// before</span></span><br><span class=\"line\">Client client;</span><br><span class=\"line\">IndicesAdminClient adminClient = client.admin().indices();</span><br><span class=\"line\">CreateIndexResponse createIndexResponse = adminClient.prepareCreate(<span class=\"string\">\"index_name\"</span>)</span><br><span class=\"line\">            .setSettings(seriesSettings())</span><br><span class=\"line\">            .addMapping(<span class=\"string\">\"type name\"</span>, seriesIndex()).get();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// after</span></span><br><span class=\"line\">RestHighLevelClient client;</span><br><span class=\"line\">CreateIndexRequest request = <span class=\"keyword\">new</span> CreateIndexRequest(<span class=\"string\">\"index_name\"</span>);</span><br><span class=\"line\">request.settings(seriesSettings(), XContentType.JSON);</span><br><span class=\"line\">request.mapping(<span class=\"string\">\"type_name\"</span>, seriesIndex(), XContentType.JSON);</span><br><span class=\"line\">client.indices().create(request);</span><br></pre></td></tr></table></figure>\n<p><code>search query</code></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// common</span></span><br><span class=\"line\">QueryBuilder qb = QueryBuilders.matchQuery(<span class=\"string\">\"text\"</span>, text);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// before</span></span><br><span class=\"line\">Client client;</span><br><span class=\"line\">SearchResponse response = client.prepareSearch(<span class=\"string\">\"index_name\"</span>).setTypes(<span class=\"string\">\"type_name\"</span>).setQuery(qb).get();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// after</span></span><br><span class=\"line\">RestHighLevelClient client;</span><br><span class=\"line\">SearchSourceBuilder searchSourceBuilder = <span class=\"keyword\">new</span> SearchSourceBuilder().query(qb);</span><br><span class=\"line\">SearchRequest searchRequest = <span class=\"keyword\">new</span> SearchRequest(<span class=\"string\">\"index_name\"</span>).types(<span class=\"string\">\"type_name\"</span>).source(searchSourceBuilder);</span><br><span class=\"line\">SearchResponse response = client.search(searchRequest);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// common</span></span><br><span class=\"line\">response.getHits().forEach(item -&gt; &#123;</span><br><span class=\"line\">\t<span class=\"comment\">// do something</span></span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>간단하게 index 를 만들고 검색하는 부분까지의 메소드들을 보았다. 나는 여기에 추가로 alias, exists, multi_search 등을 사용하고 있지만 아직까지 6.2.x 에는 해당 메소드가 없다. 어떻게든 해보려고 엔진소스를 들어가서 한참을 살펴보다가 혹시나 해서 master 브랜치를 받아보니 해당 메소드들이 있더라… (현재 master 브랜치의 버전은 7.0.0-alpha1 이다.)</p>\n<h2><span id=\"결론\">결론</span></h2>\n<p>미리 적용을 해놓을까 해서 버전별로 소스를 살펴 보았지만 아직까지 모든 메소드들이 구현되어 있지 않기도 하고 <a href=\"https://www.elastic.co/guide/en/elasticsearch/client/java-api/5.6/client.html\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">java client가 없어지려면 8.0 까지 올라가야 하니</a> 아직은 조금 여유가 있어보인다.<br>\n그래도 버전이 올라가는 속도를 보면 7.0 메이져 버전이 나오고 rest client가 완성이 되었을 때 슬슬 적용하면 될 것 같다. <s>세수하러 왔다가 물만 먹고 가는 느낌</s></p>\n","site":{"data":{}},"excerpt":"","more":"<h3>elasticsearch 버전을 올려야 한다.</h3>\n<p>검색 서비스를 개선하면서 사내에서 elasticsearch 를 사용하고 있다.<br>\n처음에 사용했던 버전은 개발 당시의 가장 최근 버전인 <a href=\"https://www.elastic.co/guide/en/elasticsearch/reference/5.1/index.html\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">elasticsearch 5.1.1</a> 버전이다.<br>\nspring boot 에 연동했는데 <a href=\"https://mvnrepository.com/artifact/org.springframework.boot/spring-boot-starter-data-elasticsearch\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">spring-boot-data-elasticsearch-starter</a> 는 (글을 작성하는) 아직까지도 2.x 버전만 지원하고 있어 직접 <a href=\"https://www.elastic.co/guide/en/elasticsearch/client/java-api/5.1/client.html\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">client</a> 를 붙이기로 했다.</p>\n<p>개인적인 생각으로는 나중에 개발이 되어질 spring-boot-data-elasticsearch-starter 로 재구현해도 되긴 하겠지만 elasticsearch를 사용하면서 느낀점은 굳이 starter를 사용할 필요는 없다고 생각한다.<br>\nrepository와 model로 나뉘어 orm처럼 사용하면 편하기야 할테지만 직접 쿼리를 만들면서 튜닝하는 부분이 재미있기도 하고 좀 더 세세하게 만질 수 있다고 생각하기 때문이다.</p>\n<p>elasticsearch 는 버전업이 빠른 편이다. 6.x 도 꾸준히 올라가는 추세고 곧있으면 7.x 이 나오고 9.x 까지 로드맵이 그려져 있다. 다행히 5.1.x 버전대에서 <a href=\"https://www.elastic.co/guide/en/elasticsearch/reference/5.6/rolling-upgrades.html\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">rolling upgrade</a> 가 가능하기 때문에 5.x 의 마지막 버전인 5.6.8 까지 따라 올라가야 겠다고 생각했다. 그러다가 문득 <a href=\"https://www.elastic.co/blog/state-of-the-official-elasticsearch-java-clients\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">State of the official Elasticsearch Java Clients</a> 라는 포스팅을 보게 되었다. 처음에 java client 를 붙이려면 공식 문서에서는 <a href=\"https://www.elastic.co/guide/en/elasticsearch/client/java-api/5.1/transport-client.html\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">transport client</a> 로 연동하도록 안내한다. 하지만 위의 포스팅의 여러 문제점으로 인해 앞으로는 <a href=\"https://www.elastic.co/guide/en/elasticsearch/client/java-api/6.2/client.html\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">Rest client 를 사용하도록 권장하고 있다.</a></p>\n<p>Java Rest Client 는 두가지 방식이 있다.</p>\n<ul>\n<li>Java Low Level REST Client</li>\n<li>Java High Level REST Client</li>\n</ul>\n<p>low level 에서는 요청을 직접 만들어서 호출하는 방식인데, 나는 high level로 작업하기로 했다.<br>\n(참고로 rest client는 5.6부터 제공되었다.)</p>\n<h3>서론이 조금 길었다.</h3>\n<p>내가 elasticsearch 버전을 올리기로 생각한 이유는 <a href=\"https://www.elastic.co/support/eol\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">elasticsearch 기술 지원</a> 때문이다.<br>\n내가 사용하고 있는 5.1.x 는 2018-06-08 까지만 공식지원을 하고 있다.<br>\n물론 공식 지원이 끊기더라도 검색 서비스를 구동함에는 큰 지장은 없지만, 메이져 버전이 두개 이상 차이가 나게 되었을 때 버전을 올려야 하는 상황이 오면 rolling upgrade도  사용할 수 없기 때문에 이참에 6.2 로 올라가기로 마음먹었다. 현재 버전에서 한번에 올라가는건 안되기 때문에 다음과 같이 버전올림 순서를 정하기로 했다.</p>\n<h2>업데이트 순서</h2>\n<ol>\n<li>elasticsearch 5.1.1 -&gt; 5.6.8 로 rolling upgrade</li>\n<li>spring-boot elasticsearch java client 5.1.1 -&gt; 5.6.8 로 업데이트 후 배포</li>\n<li>elasticsearch 5.6.8 -&gt; 6.2.2 로 <a href=\"https://www.elastic.co/guide/en/elasticsearch/reference/current/setup-upgrade.html\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">rolling upgrade</a></li>\n<li>spring-boot elasticsearch java client 5.6.8 -&gt; 6.2.2 로 업데이트 후 배포</li>\n</ol>\n<p><a href=\"https://www.elastic.co/guide/en/elasticsearch/client/java-rest/5.6/java-rest-high-compatibility.html\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">메이져 버전별로의 호환성</a>에 따라 5.x 버전끼리는 문제없이 통신을 할 수 있다. 물론 6.x 끼리의 버전도 문제가 없었는데, 테스트 결과 5.6.8 에서 6.2.2 도 호출이 가능했다.<br>\n클라이언트를 보니 모든 기능을 사용할 수 있지는 않고 부분적인 기능들만 사용가능할 것으로 보인다. 그리고 상위 버전 호환은 괜찮아도 하위 버전 호환은 기능이 구현되지 않을 가능성이 있어 문제의 여지가 있다.</p>\n<h3>rolling upgrade</h3>\n<p>현재 사용하고 있는 rolling upgrade 스크립트이다. 구글링 해보니 좀 더 유려한 스크립트 들이 많이 있는데 나는 간단한 동작들만 사용하는 중이다.</p>\n<p>일단 구동중인 es를 내린다.<br>\n<code>shut_down.sh</code></p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#!/usr/bin/env bash</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># disable shard allocation</span></span><br><span class=\"line\">curl -XPUT <span class=\"string\">'localhost:9200/_cluster/settings?pretty=true'</span> -d <span class=\"string\">'&#123;</span></span><br><span class=\"line\"><span class=\"string\">    \"transient\" : &#123;</span></span><br><span class=\"line\"><span class=\"string\">        \"cluster.routing.allocation.enable\" : \"none\"</span></span><br><span class=\"line\"><span class=\"string\">    &#125;</span></span><br><span class=\"line\"><span class=\"string\">&#125;'</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># shutdown</span></span><br><span class=\"line\">sudo service elasticsearch stop</span><br></pre></td></tr></table></figure>\n<p>정상적으로 내려간 것을 확인한 후 elasticsearch 버전을 올려 재설치하도록 한다. 그리고 다시 구동시켜 주자.</p>\n<p><code>start.sh</code></p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#!/usr/bin/env bash</span></span><br><span class=\"line\"></span><br><span class=\"line\">sudo service elasticsearch start</span><br><span class=\"line\"></span><br><span class=\"line\">STATUS=<span class=\"string\">\"\"</span></span><br><span class=\"line\"><span class=\"keyword\">while</span> ! [[ <span class=\"string\">\"<span class=\"variable\">$STATUS</span>\"</span> =~ (\\<span class=\"string\">\"tagline\\\" : \\\"You Know, for Search\\\") ]];</span></span><br><span class=\"line\"><span class=\"string\">do</span></span><br><span class=\"line\"><span class=\"string\">    echo \"</span>fetching http://localhost:9200<span class=\"string\">\"</span></span><br><span class=\"line\"><span class=\"string\">    STATUS=`curl -sS -XGET http://localhost:9200`</span></span><br><span class=\"line\"><span class=\"string\">    sleep 1</span></span><br><span class=\"line\"><span class=\"string\">done</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">curl -XPUT 'localhost:9200/_cluster/settings?pretty=true' -d '&#123;</span></span><br><span class=\"line\"><span class=\"string\">    \"</span>transient<span class=\"string\">\" : &#123;</span></span><br><span class=\"line\"><span class=\"string\">        \"</span>cluster.routing.allocation.enable<span class=\"string\">\" : \"</span>all<span class=\"string\">\"</span></span><br><span class=\"line\"><span class=\"string\">    &#125;</span></span><br><span class=\"line\"><span class=\"string\">&#125;'</span></span><br></pre></td></tr></table></figure>\n<p>자 이제 버전도 올렸으니 client 를 변경해보도록 하자.</p>\n<h2>client 에서 rest client</h2>\n<p>위에서 설명한 것과 같이 앞으로는 rest client 를 써야만 하는 시점이 온다.<br>\n지금 당장은 바꾸지 않아도 되지만 (완성이 되지 않아 할 수도 없지만) 어떻게 바뀌는지 느낌만 살펴보자.<br>\n기존에 transport layer로 붙는 client를 rest client로 변경하는 작업을 해보자. 일단 설정부터 변경해야 한다.</p>\n<h3>setting</h3>\n<p><code>build.gradle</code></p>\n<figure class=\"highlight gradle\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">dependencies</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">compile</span> <span class=\"string\">'org.elasticsearch:elasticsearch:6.2.2'</span></span><br><span class=\"line\">    <span class=\"keyword\">compile</span> <span class=\"string\">'org.elasticsearch.client:elasticsearch-rest-high-level-client:6.2.2'</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>그리고 기존에 붙었던 <code>9300</code>포트가 아닌 <code>9200</code>포트로 접속해야 한다.<br>\n<code>application.yml</code></p>\n<figure class=\"highlight yml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">elasticsearch:</span></span><br><span class=\"line\"><span class=\"attr\">  hosts:</span> <span class=\"string\">host1.com,</span> <span class=\"string\">host2.com</span></span><br><span class=\"line\"><span class=\"attr\">  port:</span> <span class=\"number\">9200</span></span><br></pre></td></tr></table></figure>\n<h3>configuration</h3>\n<p>설정파일을 고쳤으면 configuration쪽을 손봐주도록 하자.<br>\n기존의 config와 비교를 해보면 다음과 같다.</p>\n<p><code>기존 ElascitsearchConfig.java</code></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Configuration</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ElasticsearchConfig</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Value</span>(<span class=\"string\">\"#&#123;'$&#123;elasticsearch.hosts&#125;'.split(',')&#125;\"</span>)</span><br><span class=\"line\">    <span class=\"keyword\">private</span> List&lt;String&gt; hosts;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Value</span>(<span class=\"string\">\"$&#123;elasticsearch.port&#125;\"</span>)</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> port;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Bean</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Client <span class=\"title\">client</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">final</span> Settings settings = Settings.builder()</span><br><span class=\"line\">                .put(<span class=\"string\">\"client.transport.sniff\"</span>, <span class=\"keyword\">true</span>)</span><br><span class=\"line\">                .build();</span><br><span class=\"line\"></span><br><span class=\"line\">        PreBuiltTransportClient client = <span class=\"keyword\">new</span> PreBuiltTransportClient(settings);</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(String host : hosts) &#123;</span><br><span class=\"line\">            InetSocketTransportAddress item = <span class=\"keyword\">new</span> InetSocketTransportAddress(InetAddress.getByName(host), port);</span><br><span class=\"line\">            client.addTransportAddresses(item);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> client;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><code>변경된 ElascitsearchConfig.java</code></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Configuration</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ElasticsearchConfig</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Value</span>(<span class=\"string\">\"#&#123;'$&#123;elasticsearch.hosts&#125;'.split(',')&#125;\"</span>)</span><br><span class=\"line\">    <span class=\"keyword\">private</span> List&lt;String&gt; hosts;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"meta\">@Value</span>(<span class=\"string\">\"$&#123;elasticsearch.port&#125;\"</span>)</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> port;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Bean</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> RestHighLevelClient <span class=\"title\">getRestClient</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        List&lt;HttpHost&gt; hostList = <span class=\"keyword\">new</span> ArrayList&lt;&gt;();</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(String host : hosts) &#123;</span><br><span class=\"line\">            hostList.add(<span class=\"keyword\">new</span> HttpHost(host, port, <span class=\"string\">\"http\"</span>));</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        RestClientBuilder builder = RestClient.builder(hostList.toArray(<span class=\"keyword\">new</span> HttpHost[hostList.size()]));</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> RestHighLevelClient(builder);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3>service</h3>\n<p>약간씩 달라진 부분들을 살펴보자. 큰틀은 변경되진 않았고 호출하는 클래스나 메소드들이 조금씩 변경되었다.<br>\n개인 적인 느낌으로는 각 클래스별로 역할이 좀 더 충실해졌다고 생각이 들었다.</p>\n<p><code>create</code></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// before</span></span><br><span class=\"line\">Client client;</span><br><span class=\"line\">IndicesAdminClient adminClient = client.admin().indices();</span><br><span class=\"line\">CreateIndexResponse createIndexResponse = adminClient.prepareCreate(<span class=\"string\">\"index_name\"</span>)</span><br><span class=\"line\">            .setSettings(seriesSettings())</span><br><span class=\"line\">            .addMapping(<span class=\"string\">\"type name\"</span>, seriesIndex()).get();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// after</span></span><br><span class=\"line\">RestHighLevelClient client;</span><br><span class=\"line\">CreateIndexRequest request = <span class=\"keyword\">new</span> CreateIndexRequest(<span class=\"string\">\"index_name\"</span>);</span><br><span class=\"line\">request.settings(seriesSettings(), XContentType.JSON);</span><br><span class=\"line\">request.mapping(<span class=\"string\">\"type_name\"</span>, seriesIndex(), XContentType.JSON);</span><br><span class=\"line\">client.indices().create(request);</span><br></pre></td></tr></table></figure>\n<p><code>search query</code></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// common</span></span><br><span class=\"line\">QueryBuilder qb = QueryBuilders.matchQuery(<span class=\"string\">\"text\"</span>, text);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// before</span></span><br><span class=\"line\">Client client;</span><br><span class=\"line\">SearchResponse response = client.prepareSearch(<span class=\"string\">\"index_name\"</span>).setTypes(<span class=\"string\">\"type_name\"</span>).setQuery(qb).get();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// after</span></span><br><span class=\"line\">RestHighLevelClient client;</span><br><span class=\"line\">SearchSourceBuilder searchSourceBuilder = <span class=\"keyword\">new</span> SearchSourceBuilder().query(qb);</span><br><span class=\"line\">SearchRequest searchRequest = <span class=\"keyword\">new</span> SearchRequest(<span class=\"string\">\"index_name\"</span>).types(<span class=\"string\">\"type_name\"</span>).source(searchSourceBuilder);</span><br><span class=\"line\">SearchResponse response = client.search(searchRequest);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// common</span></span><br><span class=\"line\">response.getHits().forEach(item -&gt; &#123;</span><br><span class=\"line\">\t<span class=\"comment\">// do something</span></span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>간단하게 index 를 만들고 검색하는 부분까지의 메소드들을 보았다. 나는 여기에 추가로 alias, exists, multi_search 등을 사용하고 있지만 아직까지 6.2.x 에는 해당 메소드가 없다. 어떻게든 해보려고 엔진소스를 들어가서 한참을 살펴보다가 혹시나 해서 master 브랜치를 받아보니 해당 메소드들이 있더라… (현재 master 브랜치의 버전은 7.0.0-alpha1 이다.)</p>\n<h2>결론</h2>\n<p>미리 적용을 해놓을까 해서 버전별로 소스를 살펴 보았지만 아직까지 모든 메소드들이 구현되어 있지 않기도 하고 <a href=\"https://www.elastic.co/guide/en/elasticsearch/client/java-api/5.6/client.html\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">java client가 없어지려면 8.0 까지 올라가야 하니</a> 아직은 조금 여유가 있어보인다.<br>\n그래도 버전이 올라가는 속도를 보면 7.0 메이져 버전이 나오고 rest client가 완성이 되었을 때 슬슬 적용하면 될 것 같다. <s>세수하러 왔다가 물만 먹고 가는 느낌</s></p>\n"},{"title":"Elasticsearch Java Rest High Level Client 사용하기","catalog":true,"date":"2018-06-17T09:36:24.000Z","subtitle":null,"header-img":"/img/header_img/bg.png","_content":"\n## elasticsearch & spring boot & webflux\n\n### elasticsearch 6.3.0\nelasticsearch 가 [6.3.0](https://www.elastic.co/blog/elasticsearch-6-3-0-released)  으로 올라갔다. 여러가지 기능들이 추가되었는데, 흥미로운 부분은 내부 client 로 SQL 문법을 지원한다는것이다. 생각보다 놀랍게 동작한다! 메인 버전이 올라가면서 java client 버전도 함께 올라갔는데 드디어 java rest high level client 가 쓸만한 모듈이 되었다는 점이다. 예전까지는 java client 만 사용해왔었는데 이젠 슬슬 넘어갈 수 있을 것같아서 후딱 한번 사용해보았다.  \n\n### RestHighLevelClient\n[이전 포스트](https://nevercaution.github.io/2018/03/15/elasticsearch-rest-client/) 에서 살짝 훑어만 봤었는데 elasticsearch java client 가 6.3.0 으로 업데이트 되면서 대부분의 기능들을 사용할 수 있게 되었다. 언제나 릴리즈되나 눈빠지게 기다리고 있었는데 6.3.0 이 릴리즈 되자마자 한번 적용해보았다.  \n\n### async\nRestHighLevelClient 에서는 대부분의 메소드에 async 를 지원한다. spring webFlux 를 공부하면서 elasticsearch 가 async 를 지원하지 않아서 반쪽짜리로 사용하고 있었는데, 함께 사용해보니 궁합이 꽤나 잘맞았다.  \n\n### 오늘의 목표\n이번 포스팅은 webFlux 와 elasticsearch 가 짬뽕이 되었다. 두 꼭지에서 꼭 알고 가야하는 부분만 짚고 가보자. 사용할 제원(?)은 다음과 같다.     \n1. spring boot 2.0.3   \n2. spring boot webFlux  \n3. elasticsearch RestHighLevelClient (6.3.0) \n\n\n## shut up and code\n\n### setting\n\n`build.gradle`  \n  \n```gradle\nbuildscript {\n    ext {\n        springBootVersion = '2.0.3.RELEASE'\n    }\n    repositories {\n        mavenCentral()\n    }\n    dependencies {\n        classpath(\"org.springframework.boot:spring-boot-gradle-plugin:${springBootVersion}\")\n    }\n}\n\n...\n\ndependencies {\n    // for webFlux\n    compile('org.springframework.boot:spring-boot-starter')\n    compile('org.springframework.boot:spring-boot-starter-webflux') // 1\n    compileOnly(\"org.springframework.boot:spring-boot-configuration-processor\")\n    \n    // for elasticsearch\n    compile('org.elasticsearch.client:elasticsearch-rest-high-level-client:6.3.0')\n    compile('org.apache.logging.log4j:log4j-core:2.9.1')\n    compile('org.elasticsearch:elasticsearch:6.3.0') //2\n}\n```\n\n프로젝트는 gradle 로 구성했다. 개인적으로는 maven 보다 가독성이 좋고 문법이 간결하다고 생각한다. xml 을 그닥 좋아하지 않는 경향도 있고, 뎁스가 깊어지거나 설정자체가 길어지면 한눈에 어떤 dependency 가 걸려있는지 파악하기가 쉽지 않기 때문이다. 위의 설정에서 짚고 넘어갈 부분이 있다.   \n\n1. spring boot starter 에는 web 과 webflux 가 있다. web 은 `org.springframework.boot:spring-boot-starter-web` 이렇게 사용하는데 web 은 기본적으로 tomcat 으로 동작하고, webflux 는 netty 로 was 가 동작한다. 여기에서 주의할 점은 web과 wenflux 를 함께 넣으면 기본적으로 web 으로 동작하고 webflux 는 무시된다. 해당 내용은 [여기](https://docs.spring.io/spring-boot/docs/current-SNAPSHOT/reference/htmlsingle/#boot-features-webflux) 에서 확인할 수 있다.   \n\n2. `org.elasticsearch.client:elasticsearch-rest-high-level-client:6.3.0` 만 추가하면 기본적으로 elasticsearch 5.6.x 버전의 client 가 dependency 로 따라온다. 기본적으로 사용함에 있어서는 큰 문제는 없지만 일부 기능들이 호환이 잘 안되서 엉뚱하게 동작하는 경우가 있다. 이는 rest client 로 사용했을 때에도 비슷한 상황이 있었는데 명시적으로 elasticsearch client 버전을 명시해주면 원하는 버전의 client 를 사용할 수 있다. 되도록 rest high level client 와 동일한 버전을 사용하는걸 추천한다.  \n\n\n`ElasticsearchConfig.java`  \n\n```java\n@Configuration\npublic class ElasticsearchConfig {\n\n    @Bean\n    public RestHighLevelClient client(ElasticsearchProperties properties) {\n        return new RestHighLevelClient(\n                RestClient.builder(properties.hosts())\n        );\n    }\n}\n```\n\nconfiguration 의 기본 설정은 rest client 와 기본 골격은 비슷하게 생겼다. (설정이나 다른 부분들이 몇가지 있지만) 크게 다른 점을 하나 꼽자면 rest high level client 부터는 tcp connection 이 아닌 http connection 을 맺는다. 그래서 기본 (elasticsearch port 인) 9200 을 사용한다. rest client 에서는 `InetSocketTransportAddress` 를 생성해서 builder 에 전달을 했었지만 restHighLevelClient 부터는 `HttpHost` 를 전달해서 생성하는 부분도 눈여겨 볼만한 부분이다. elasticsearch 설정 관련 클래스는 ElasticsearchProperties 로 묶었다. `@Value` 나 `ConfigurationProperties` annotation 으로 configuration 에서 직접 설정도 가능하지만, 특정 설정값을 service 에서 사용하기 편하기 위해 클래스를 분리했다.    \n  \n  \n     \n`ElasticsearchProperties.java`  \n\n```java\n@Component\n@Setter\n@ConfigurationProperties(prefix = \"elasticsearch\")\npublic class ElasticsearchProperties {\n\n    private List<String> hosts;\n\n    public HttpHost[] hosts() {\n        return hosts.stream().map(HttpHost::create).toArray(HttpHost[]::new);\n    }\n}\n```\n\n`@Value` annotation 으로 설정해주어도 되지만, 이름이 완전히 같을 때만 설정값을 읽어들인다. `@ConfigurationProperties` annotation 은 [Relaxed Binding](https://docs.spring.io/spring-boot/docs/current/reference/html/boot-features-external-config.html#boot-features-external-config-relaxed-binding) 이라는 느슨한(?) 룰이 있어 각자 입맛에 맞는 포멧으로 써도 properties class 에서 찰떡같이 알아 먹는다. (자신만의 스타일을 고집하는 팀에서는 나름 유용하게 사용될지는 모르겠지만 남용은 하지 말자. 버그가 생길 수 있는 포인트이다.)  \n\n`application.yml`\n\n```yaml\nelasticsearch:\n  hosts: http://localhost:9200\n  \n```\n\n설정파일은 이전보다 심플해졌다. 심지어 cluster name 을 묻지도 따지지도 않는다. 연결을 맺을 때 굳이 너의 이름을 몰라도 상관없다는 뜻이였을까.  \n\n### service\n\ndocument 의 생성과 조회를 만들어 보자. (update 와 delete 는 index 와 get/match 와 비슷하기 때문에 생략한다.)  \n  \n* `index`\n\n```java\npublic Mono<Void> index(String index, String type, String userName, String message) {\n        Gson gson = GsonUtil.gson();\n\n        User user = new User();\n        user.setUser(userName);\n        user.setMessage(message);\n        user.setPostDate(new Date());\n\n        IndexRequest indexRequest = new IndexRequest(index, type);\n        indexRequest.source(gson.toJson(user), XContentType.JSON);\n\n\n        return Mono.create(sink -> {  //1\n            restHighLevelClient.indexAsync(indexRequest, new ActionListener<IndexResponse>() {  //2\n                @Override\n                public void onResponse(IndexResponse indexResponse) {\n                    log.info(\"index success : \"+indexResponse.toString());\n                    sink.success();\n                }\n\n                @Override\n                public void onFailure(Exception e) {\n                    log.error(\"index error \", e);\n                    sink.error(e);\n                }\n            });\n        });\n    }\n```\n\nindex 메소드는 특정한 반환값을 필요로 하지 않기 때문에 `Mono<Void>` 를 사용한다. client 에서는 기존의 index 메소드와 indexAsync 를 제공한다. (대부분의 메소드들이 동일하게 제공) 위의 동작은 공식문서의 [index](https://www.elastic.co/guide/en/elasticsearch/reference/current/docs-index_.html#docs-index_) 부분의 동작을 코드로 작성한 부분이다. url 로 풀어 쓰면 다음과 같다.  \n  \n```\n$ curl -X PUT \"localhost:9200/twitter/_doc/1\" -H 'Content-Type: application/json' -d'\n{\n    \"user\" : \"kimchy\",\n    \"post_date\" : \"2009-11-15T14:12:12\",\n    \"message\" : \"trying out Elasticsearch\"\n}\n'\n```\n\nindexAsync 메소드를 사용했고 이를 [MonoSink](https://projectreactor.io/docs/core/release/api/index.html?reactor/core/publisher/Mono.html) 로 감싸주었다. Mono 는 0..1 의 상태이므로 하나의 index 결과에 대한 성공여부를 publish 해준다. controller 에서는 다음과 같이 받아 처리해준다.  \n\n`controller.java`   \n\n```java\n@RequestMapping(value = \"/index/{index}/{type}\", method = {RequestMethod.POST})\n    public Mono<Void> index(@PathVariable(\"index\") String index,\n                            @PathVariable(\"type\") String type,\n                            @RequestParam(value = \"user_name\") String userName,\n                            @RequestParam(value = \"message\") String message) {\n        return elasticsearchService.index(index, type, userName, message)\n                .onErrorResume(error -> {\n                    log.error(\"index error \", error);\n            return Mono.empty();\n        });\n    }\n```\n\nindex 동작 이후 특정한 값을 반환하고자 한다면 Mono 안의 타입을 원하는 클래스를 정의해주자.  \n\n* `get`  \n\ndocument 를 넣었으면 값이 잘 들어갔는지 확인이 필요하겠다. [get api](https://www.elastic.co/guide/en/elasticsearch/reference/current/docs-get.html#docs-get) 를 추가해보자.  \n\n```\n$ curl -X GET \"localhost:9200/twitter/_doc/0\"\n```\n  \n이 api 를 rest high level client 로 작성하면 아래와 같다.  \n\n```java\npublic Mono<User> getUser(String index, String type, String id) {\n    final Gson gson = GsonUtil.gson();\n    GetRequest getRequest = new GetRequest(index, type, id);\n    return Mono.create(sink -> {\n        restHighLevelClient.getAsync(getRequest, new ActionListener<GetResponse>() {\n            @Override\n            public void onResponse(GetResponse documentFields) {\n                User user = gson.fromJson(documentFields.getSourceAsString(), User.class);\n                sink.success(user);\n            }\n\n            @Override\n            public void onFailure(Exception e) {\n                e.printStackTrace();\n                sink.error(e);\n            }\n        });\n    });\n}\n```\n\nindex 에서와 같이 Mono 로 감싸서 반환을 하였고 이번에는 필요한 값인 User 객체를 사용하였다.  \n\n```java\n@GetMapping(\"get/{index}/{type}/{id}\")\npublic Mono<User> getAsync(@PathVariable(\"index\") String index,\n                           @PathVariable(\"type\") String type,\n                           @PathVariable(\"id\") String id) {\n\n   return elasticsearchService.getUser(index, type, id)\n           .onErrorResume(error -> {\n               User defaultUser = new User();\n               defaultUser.setUser(\"default\");\n               defaultUser.setPostDate(new Date());\n               defaultUser.setMessage(\"default message\");\n               return Mono.just(defaultUser);\n           })\n           .defaultIfEmpty(new User());\n}\n\n```\n\nservice 에서 `Mono<User>` 를 받아 반환을 해준다. `onErrorResume` 이나 `defaultIfEmpty` 는 service 에서 정상동작을 하지 않았을 경우의 후처리 이다. 여기에서 짚고 넘어갈 부분이라면, 우리는 restful Api 를 만들고 있기 때문에 controller 가 `@RestController` 이거나 mapping method 에 `@ResponseBody` annotation 이 걸려있으면 위와 같이 바로 `Mono` 를 반환해도 된다.  \n하지만 `@Controller` annotation 을 사용하고 있다면 http status 값이 넘어가지 않기 때문에 mapping method 에 `@ResponseBody` 를 걸어주거나 `ResponseEntity` 객체로 한번 더 감싸서 반환해주어야 한다. 다음과 같이 감싸줄 수 있겠다.   \n\n```java\n@GetMapping(\"get/{index}/{type}/{id}\")\npublic Mono<ResponseEntity<User>> getAsync2(@PathVariable(\"index\") String index,\n                                           @PathVariable(\"type\") String type,\n                                           @PathVariable(\"id\") String id) {\n\n    return elasticsearchService.getUser(index, type, id)\n            .map(ResponseEntity::ok)\n            .onErrorResume(error -> Mono.just(ResponseEntity.badRequest().build()))\n            .defaultIfEmpty(ResponseEntity.status(HttpStatus.OK).body(new User()));\n}\n```\n\n취향과 상황에 맞게 선택하도록 하자.  \n\n* `match all`\n\n[match all api](https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-match-all-query.html#query-dsl-match-all-query) 도 추가해보자.   \n\n```\n$ curl -X GET \"localhost:9200/_search\" -H 'Content-Type: application/json' -d'\n{\n    \"query\": {\n        \"match_all\": {}\n    }\n}\n'\n```\n\n코드로 작성하면 다음과 같다.  \n\n```java\npublic Flux<User> matchAll(String index) {\n    final Gson gson = GsonUtil.gson();\n\n    SearchSourceBuilder searchSourceBuilder = new SearchSourceBuilder();\n    searchSourceBuilder.query(QueryBuilders.matchAllQuery());\n\n    SearchRequest searchRequest = new SearchRequest(index);\n    searchRequest.source(searchSourceBuilder);\n\n    return Flux.create((FluxSink<User> sink) -> {\n        restHighLevelClient.searchAsync(searchRequest, new ActionListener<SearchResponse>() {\n            @Override\n            public void onResponse(SearchResponse searchResponse) {\n                searchResponse.getHits().forEach(item -> {\n                    User user = gson.fromJson(item.getSourceAsString(), User.class);\n                    sink.next(user);\n                });\n                sink.complete();\n            }\n\n            @Override\n            public void onFailure(Exception e) {\n                log.error(\"matchAll error \", e);\n                sink.error(e);\n            }\n        });\n    });\n}\n```\n\n\n```java\n@GetMapping(\"/match_all/{index}\")\npublic Flux<User> matchAll(@PathVariable(\"index\") String index) {\n\n    return elasticsearchService.matchAll(index).onErrorResume((Throwable error) -> {\n        log.error(\"err\", error);\n        User user = new User();\n        user.setPostDate(new Date());\n        user.setUser(\"default User\");\n        user.setMessage(\"default message\");\n        return Flux.just(user);\n    });\n}\n```\n\n복수개의 값을 반환할 수 있으므로 Flux 로 반환해준다. 물론 List 로 묶어서 Mono 로 반환해야할 수도 있다. MonoSink 와의 차이점은 next 로 데이터를 넘기다가 모든 데이터가 넘어가면 complete 를 호출 해주는 부분이다. \n\n\n## 결론\nwebflux 와 restHighLevelClient 사용하여 비동기 api 를 제공해줄 수 있다. webflux 는 꽤나 멋지게 동작하지만 아직까지는 모든 서드파티들이 지원을 해주고 있지 않아 하드하게 사용하기에는 주저되는 부분이 있다. (jdbc 를 사용하지 않는다면 추천!)  \nrestHighLevelClient 로 넘어오면서 각 클래스들의 역할이 명확해진 느낌이고 선언과 사용도 좀 더 명확해져서 편하다는 인상을 많이 받았다. 위의 예제코드는 [여기](https://github.com/nevercaution/elasticsearch_java_client) 에서 확인할 수 있다. \n\n### 여담\nelasticsearch 에 kibana 를 얹으면 devtool 을 이용해서 (무려 자동완성이 제공되는) 쿼리를 날려볼 수 있다. 지금껏 sense 나 다른 툴들을 조금은 불편하게 사용해왔었는데, 반길만한 부분이다. 다만 개인적으로는 redis-cli 처럼 CLI tool 이 제공되면 좋았을 거라는 생각에 [elasticsearch-cli](https://github.com/nevercaution/elasticsearch-cli) 를 만들어 보는 중이다. 물론 elastic 진영에서는 [curator](https://www.elastic.co/guide/en/elasticsearch/client/curator/current/about-cli.html) 을 제공해주고 있긴 하지만 모니터링 툴이라 간단한 match query 나 analyze 등을 사용할 수는 없다. 나름 일하면서 편하게 사용하는중이다. ㅎㅎ","source":"_posts/elasticsearch-java-high-level-client.md","raw":"---\ntitle: Elasticsearch Java Rest High Level Client 사용하기  \ncatalog: true  \ndate: 2018-06-17 18:36:24  \nsubtitle:  \nheader-img: \"/img/header_img/bg.png\"  \ntags:  \n- elasticsearch  \n- resthighlevelclient  \n- sptingboot  \n- webflux  \n- gradle\n---\n\n## elasticsearch & spring boot & webflux\n\n### elasticsearch 6.3.0\nelasticsearch 가 [6.3.0](https://www.elastic.co/blog/elasticsearch-6-3-0-released)  으로 올라갔다. 여러가지 기능들이 추가되었는데, 흥미로운 부분은 내부 client 로 SQL 문법을 지원한다는것이다. 생각보다 놀랍게 동작한다! 메인 버전이 올라가면서 java client 버전도 함께 올라갔는데 드디어 java rest high level client 가 쓸만한 모듈이 되었다는 점이다. 예전까지는 java client 만 사용해왔었는데 이젠 슬슬 넘어갈 수 있을 것같아서 후딱 한번 사용해보았다.  \n\n### RestHighLevelClient\n[이전 포스트](https://nevercaution.github.io/2018/03/15/elasticsearch-rest-client/) 에서 살짝 훑어만 봤었는데 elasticsearch java client 가 6.3.0 으로 업데이트 되면서 대부분의 기능들을 사용할 수 있게 되었다. 언제나 릴리즈되나 눈빠지게 기다리고 있었는데 6.3.0 이 릴리즈 되자마자 한번 적용해보았다.  \n\n### async\nRestHighLevelClient 에서는 대부분의 메소드에 async 를 지원한다. spring webFlux 를 공부하면서 elasticsearch 가 async 를 지원하지 않아서 반쪽짜리로 사용하고 있었는데, 함께 사용해보니 궁합이 꽤나 잘맞았다.  \n\n### 오늘의 목표\n이번 포스팅은 webFlux 와 elasticsearch 가 짬뽕이 되었다. 두 꼭지에서 꼭 알고 가야하는 부분만 짚고 가보자. 사용할 제원(?)은 다음과 같다.     \n1. spring boot 2.0.3   \n2. spring boot webFlux  \n3. elasticsearch RestHighLevelClient (6.3.0) \n\n\n## shut up and code\n\n### setting\n\n`build.gradle`  \n  \n```gradle\nbuildscript {\n    ext {\n        springBootVersion = '2.0.3.RELEASE'\n    }\n    repositories {\n        mavenCentral()\n    }\n    dependencies {\n        classpath(\"org.springframework.boot:spring-boot-gradle-plugin:${springBootVersion}\")\n    }\n}\n\n...\n\ndependencies {\n    // for webFlux\n    compile('org.springframework.boot:spring-boot-starter')\n    compile('org.springframework.boot:spring-boot-starter-webflux') // 1\n    compileOnly(\"org.springframework.boot:spring-boot-configuration-processor\")\n    \n    // for elasticsearch\n    compile('org.elasticsearch.client:elasticsearch-rest-high-level-client:6.3.0')\n    compile('org.apache.logging.log4j:log4j-core:2.9.1')\n    compile('org.elasticsearch:elasticsearch:6.3.0') //2\n}\n```\n\n프로젝트는 gradle 로 구성했다. 개인적으로는 maven 보다 가독성이 좋고 문법이 간결하다고 생각한다. xml 을 그닥 좋아하지 않는 경향도 있고, 뎁스가 깊어지거나 설정자체가 길어지면 한눈에 어떤 dependency 가 걸려있는지 파악하기가 쉽지 않기 때문이다. 위의 설정에서 짚고 넘어갈 부분이 있다.   \n\n1. spring boot starter 에는 web 과 webflux 가 있다. web 은 `org.springframework.boot:spring-boot-starter-web` 이렇게 사용하는데 web 은 기본적으로 tomcat 으로 동작하고, webflux 는 netty 로 was 가 동작한다. 여기에서 주의할 점은 web과 wenflux 를 함께 넣으면 기본적으로 web 으로 동작하고 webflux 는 무시된다. 해당 내용은 [여기](https://docs.spring.io/spring-boot/docs/current-SNAPSHOT/reference/htmlsingle/#boot-features-webflux) 에서 확인할 수 있다.   \n\n2. `org.elasticsearch.client:elasticsearch-rest-high-level-client:6.3.0` 만 추가하면 기본적으로 elasticsearch 5.6.x 버전의 client 가 dependency 로 따라온다. 기본적으로 사용함에 있어서는 큰 문제는 없지만 일부 기능들이 호환이 잘 안되서 엉뚱하게 동작하는 경우가 있다. 이는 rest client 로 사용했을 때에도 비슷한 상황이 있었는데 명시적으로 elasticsearch client 버전을 명시해주면 원하는 버전의 client 를 사용할 수 있다. 되도록 rest high level client 와 동일한 버전을 사용하는걸 추천한다.  \n\n\n`ElasticsearchConfig.java`  \n\n```java\n@Configuration\npublic class ElasticsearchConfig {\n\n    @Bean\n    public RestHighLevelClient client(ElasticsearchProperties properties) {\n        return new RestHighLevelClient(\n                RestClient.builder(properties.hosts())\n        );\n    }\n}\n```\n\nconfiguration 의 기본 설정은 rest client 와 기본 골격은 비슷하게 생겼다. (설정이나 다른 부분들이 몇가지 있지만) 크게 다른 점을 하나 꼽자면 rest high level client 부터는 tcp connection 이 아닌 http connection 을 맺는다. 그래서 기본 (elasticsearch port 인) 9200 을 사용한다. rest client 에서는 `InetSocketTransportAddress` 를 생성해서 builder 에 전달을 했었지만 restHighLevelClient 부터는 `HttpHost` 를 전달해서 생성하는 부분도 눈여겨 볼만한 부분이다. elasticsearch 설정 관련 클래스는 ElasticsearchProperties 로 묶었다. `@Value` 나 `ConfigurationProperties` annotation 으로 configuration 에서 직접 설정도 가능하지만, 특정 설정값을 service 에서 사용하기 편하기 위해 클래스를 분리했다.    \n  \n  \n     \n`ElasticsearchProperties.java`  \n\n```java\n@Component\n@Setter\n@ConfigurationProperties(prefix = \"elasticsearch\")\npublic class ElasticsearchProperties {\n\n    private List<String> hosts;\n\n    public HttpHost[] hosts() {\n        return hosts.stream().map(HttpHost::create).toArray(HttpHost[]::new);\n    }\n}\n```\n\n`@Value` annotation 으로 설정해주어도 되지만, 이름이 완전히 같을 때만 설정값을 읽어들인다. `@ConfigurationProperties` annotation 은 [Relaxed Binding](https://docs.spring.io/spring-boot/docs/current/reference/html/boot-features-external-config.html#boot-features-external-config-relaxed-binding) 이라는 느슨한(?) 룰이 있어 각자 입맛에 맞는 포멧으로 써도 properties class 에서 찰떡같이 알아 먹는다. (자신만의 스타일을 고집하는 팀에서는 나름 유용하게 사용될지는 모르겠지만 남용은 하지 말자. 버그가 생길 수 있는 포인트이다.)  \n\n`application.yml`\n\n```yaml\nelasticsearch:\n  hosts: http://localhost:9200\n  \n```\n\n설정파일은 이전보다 심플해졌다. 심지어 cluster name 을 묻지도 따지지도 않는다. 연결을 맺을 때 굳이 너의 이름을 몰라도 상관없다는 뜻이였을까.  \n\n### service\n\ndocument 의 생성과 조회를 만들어 보자. (update 와 delete 는 index 와 get/match 와 비슷하기 때문에 생략한다.)  \n  \n* `index`\n\n```java\npublic Mono<Void> index(String index, String type, String userName, String message) {\n        Gson gson = GsonUtil.gson();\n\n        User user = new User();\n        user.setUser(userName);\n        user.setMessage(message);\n        user.setPostDate(new Date());\n\n        IndexRequest indexRequest = new IndexRequest(index, type);\n        indexRequest.source(gson.toJson(user), XContentType.JSON);\n\n\n        return Mono.create(sink -> {  //1\n            restHighLevelClient.indexAsync(indexRequest, new ActionListener<IndexResponse>() {  //2\n                @Override\n                public void onResponse(IndexResponse indexResponse) {\n                    log.info(\"index success : \"+indexResponse.toString());\n                    sink.success();\n                }\n\n                @Override\n                public void onFailure(Exception e) {\n                    log.error(\"index error \", e);\n                    sink.error(e);\n                }\n            });\n        });\n    }\n```\n\nindex 메소드는 특정한 반환값을 필요로 하지 않기 때문에 `Mono<Void>` 를 사용한다. client 에서는 기존의 index 메소드와 indexAsync 를 제공한다. (대부분의 메소드들이 동일하게 제공) 위의 동작은 공식문서의 [index](https://www.elastic.co/guide/en/elasticsearch/reference/current/docs-index_.html#docs-index_) 부분의 동작을 코드로 작성한 부분이다. url 로 풀어 쓰면 다음과 같다.  \n  \n```\n$ curl -X PUT \"localhost:9200/twitter/_doc/1\" -H 'Content-Type: application/json' -d'\n{\n    \"user\" : \"kimchy\",\n    \"post_date\" : \"2009-11-15T14:12:12\",\n    \"message\" : \"trying out Elasticsearch\"\n}\n'\n```\n\nindexAsync 메소드를 사용했고 이를 [MonoSink](https://projectreactor.io/docs/core/release/api/index.html?reactor/core/publisher/Mono.html) 로 감싸주었다. Mono 는 0..1 의 상태이므로 하나의 index 결과에 대한 성공여부를 publish 해준다. controller 에서는 다음과 같이 받아 처리해준다.  \n\n`controller.java`   \n\n```java\n@RequestMapping(value = \"/index/{index}/{type}\", method = {RequestMethod.POST})\n    public Mono<Void> index(@PathVariable(\"index\") String index,\n                            @PathVariable(\"type\") String type,\n                            @RequestParam(value = \"user_name\") String userName,\n                            @RequestParam(value = \"message\") String message) {\n        return elasticsearchService.index(index, type, userName, message)\n                .onErrorResume(error -> {\n                    log.error(\"index error \", error);\n            return Mono.empty();\n        });\n    }\n```\n\nindex 동작 이후 특정한 값을 반환하고자 한다면 Mono 안의 타입을 원하는 클래스를 정의해주자.  \n\n* `get`  \n\ndocument 를 넣었으면 값이 잘 들어갔는지 확인이 필요하겠다. [get api](https://www.elastic.co/guide/en/elasticsearch/reference/current/docs-get.html#docs-get) 를 추가해보자.  \n\n```\n$ curl -X GET \"localhost:9200/twitter/_doc/0\"\n```\n  \n이 api 를 rest high level client 로 작성하면 아래와 같다.  \n\n```java\npublic Mono<User> getUser(String index, String type, String id) {\n    final Gson gson = GsonUtil.gson();\n    GetRequest getRequest = new GetRequest(index, type, id);\n    return Mono.create(sink -> {\n        restHighLevelClient.getAsync(getRequest, new ActionListener<GetResponse>() {\n            @Override\n            public void onResponse(GetResponse documentFields) {\n                User user = gson.fromJson(documentFields.getSourceAsString(), User.class);\n                sink.success(user);\n            }\n\n            @Override\n            public void onFailure(Exception e) {\n                e.printStackTrace();\n                sink.error(e);\n            }\n        });\n    });\n}\n```\n\nindex 에서와 같이 Mono 로 감싸서 반환을 하였고 이번에는 필요한 값인 User 객체를 사용하였다.  \n\n```java\n@GetMapping(\"get/{index}/{type}/{id}\")\npublic Mono<User> getAsync(@PathVariable(\"index\") String index,\n                           @PathVariable(\"type\") String type,\n                           @PathVariable(\"id\") String id) {\n\n   return elasticsearchService.getUser(index, type, id)\n           .onErrorResume(error -> {\n               User defaultUser = new User();\n               defaultUser.setUser(\"default\");\n               defaultUser.setPostDate(new Date());\n               defaultUser.setMessage(\"default message\");\n               return Mono.just(defaultUser);\n           })\n           .defaultIfEmpty(new User());\n}\n\n```\n\nservice 에서 `Mono<User>` 를 받아 반환을 해준다. `onErrorResume` 이나 `defaultIfEmpty` 는 service 에서 정상동작을 하지 않았을 경우의 후처리 이다. 여기에서 짚고 넘어갈 부분이라면, 우리는 restful Api 를 만들고 있기 때문에 controller 가 `@RestController` 이거나 mapping method 에 `@ResponseBody` annotation 이 걸려있으면 위와 같이 바로 `Mono` 를 반환해도 된다.  \n하지만 `@Controller` annotation 을 사용하고 있다면 http status 값이 넘어가지 않기 때문에 mapping method 에 `@ResponseBody` 를 걸어주거나 `ResponseEntity` 객체로 한번 더 감싸서 반환해주어야 한다. 다음과 같이 감싸줄 수 있겠다.   \n\n```java\n@GetMapping(\"get/{index}/{type}/{id}\")\npublic Mono<ResponseEntity<User>> getAsync2(@PathVariable(\"index\") String index,\n                                           @PathVariable(\"type\") String type,\n                                           @PathVariable(\"id\") String id) {\n\n    return elasticsearchService.getUser(index, type, id)\n            .map(ResponseEntity::ok)\n            .onErrorResume(error -> Mono.just(ResponseEntity.badRequest().build()))\n            .defaultIfEmpty(ResponseEntity.status(HttpStatus.OK).body(new User()));\n}\n```\n\n취향과 상황에 맞게 선택하도록 하자.  \n\n* `match all`\n\n[match all api](https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-match-all-query.html#query-dsl-match-all-query) 도 추가해보자.   \n\n```\n$ curl -X GET \"localhost:9200/_search\" -H 'Content-Type: application/json' -d'\n{\n    \"query\": {\n        \"match_all\": {}\n    }\n}\n'\n```\n\n코드로 작성하면 다음과 같다.  \n\n```java\npublic Flux<User> matchAll(String index) {\n    final Gson gson = GsonUtil.gson();\n\n    SearchSourceBuilder searchSourceBuilder = new SearchSourceBuilder();\n    searchSourceBuilder.query(QueryBuilders.matchAllQuery());\n\n    SearchRequest searchRequest = new SearchRequest(index);\n    searchRequest.source(searchSourceBuilder);\n\n    return Flux.create((FluxSink<User> sink) -> {\n        restHighLevelClient.searchAsync(searchRequest, new ActionListener<SearchResponse>() {\n            @Override\n            public void onResponse(SearchResponse searchResponse) {\n                searchResponse.getHits().forEach(item -> {\n                    User user = gson.fromJson(item.getSourceAsString(), User.class);\n                    sink.next(user);\n                });\n                sink.complete();\n            }\n\n            @Override\n            public void onFailure(Exception e) {\n                log.error(\"matchAll error \", e);\n                sink.error(e);\n            }\n        });\n    });\n}\n```\n\n\n```java\n@GetMapping(\"/match_all/{index}\")\npublic Flux<User> matchAll(@PathVariable(\"index\") String index) {\n\n    return elasticsearchService.matchAll(index).onErrorResume((Throwable error) -> {\n        log.error(\"err\", error);\n        User user = new User();\n        user.setPostDate(new Date());\n        user.setUser(\"default User\");\n        user.setMessage(\"default message\");\n        return Flux.just(user);\n    });\n}\n```\n\n복수개의 값을 반환할 수 있으므로 Flux 로 반환해준다. 물론 List 로 묶어서 Mono 로 반환해야할 수도 있다. MonoSink 와의 차이점은 next 로 데이터를 넘기다가 모든 데이터가 넘어가면 complete 를 호출 해주는 부분이다. \n\n\n## 결론\nwebflux 와 restHighLevelClient 사용하여 비동기 api 를 제공해줄 수 있다. webflux 는 꽤나 멋지게 동작하지만 아직까지는 모든 서드파티들이 지원을 해주고 있지 않아 하드하게 사용하기에는 주저되는 부분이 있다. (jdbc 를 사용하지 않는다면 추천!)  \nrestHighLevelClient 로 넘어오면서 각 클래스들의 역할이 명확해진 느낌이고 선언과 사용도 좀 더 명확해져서 편하다는 인상을 많이 받았다. 위의 예제코드는 [여기](https://github.com/nevercaution/elasticsearch_java_client) 에서 확인할 수 있다. \n\n### 여담\nelasticsearch 에 kibana 를 얹으면 devtool 을 이용해서 (무려 자동완성이 제공되는) 쿼리를 날려볼 수 있다. 지금껏 sense 나 다른 툴들을 조금은 불편하게 사용해왔었는데, 반길만한 부분이다. 다만 개인적으로는 redis-cli 처럼 CLI tool 이 제공되면 좋았을 거라는 생각에 [elasticsearch-cli](https://github.com/nevercaution/elasticsearch-cli) 를 만들어 보는 중이다. 물론 elastic 진영에서는 [curator](https://www.elastic.co/guide/en/elasticsearch/client/curator/current/about-cli.html) 을 제공해주고 있긴 하지만 모니터링 툴이라 간단한 match query 나 analyze 등을 사용할 수는 없다. 나름 일하면서 편하게 사용하는중이다. ㅎㅎ","slug":"elasticsearch-java-high-level-client","published":1,"updated":"2018-06-28T12:38:42.678Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjq98sopo000a8ghhjpjxbn1g","content":"<h2><span id=\"elasticsearch-amp-spring-boot-amp-webflux\">elasticsearch &amp; spring boot &amp; webflux</span></h2>\n<h3><span id=\"elasticsearch-630\">elasticsearch 6.3.0</span></h3>\n<p>elasticsearch 가 <a href=\"https://www.elastic.co/blog/elasticsearch-6-3-0-released\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">6.3.0</a>  으로 올라갔다. 여러가지 기능들이 추가되었는데, 흥미로운 부분은 내부 client 로 SQL 문법을 지원한다는것이다. 생각보다 놀랍게 동작한다! 메인 버전이 올라가면서 java client 버전도 함께 올라갔는데 드디어 java rest high level client 가 쓸만한 모듈이 되었다는 점이다. 예전까지는 java client 만 사용해왔었는데 이젠 슬슬 넘어갈 수 있을 것같아서 후딱 한번 사용해보았다.</p>\n<h3><span id=\"resthighlevelclient\">RestHighLevelClient</span></h3>\n<p><a href=\"https://nevercaution.github.io/2018/03/15/elasticsearch-rest-client/\">이전 포스트</a> 에서 살짝 훑어만 봤었는데 elasticsearch java client 가 6.3.0 으로 업데이트 되면서 대부분의 기능들을 사용할 수 있게 되었다. 언제나 릴리즈되나 눈빠지게 기다리고 있었는데 6.3.0 이 릴리즈 되자마자 한번 적용해보았다.</p>\n<h3><span id=\"async\">async</span></h3>\n<p>RestHighLevelClient 에서는 대부분의 메소드에 async 를 지원한다. spring webFlux 를 공부하면서 elasticsearch 가 async 를 지원하지 않아서 반쪽짜리로 사용하고 있었는데, 함께 사용해보니 궁합이 꽤나 잘맞았다.</p>\n<h3><span id=\"오늘의-목표\">오늘의 목표</span></h3>\n<p>이번 포스팅은 webFlux 와 elasticsearch 가 짬뽕이 되었다. 두 꼭지에서 꼭 알고 가야하는 부분만 짚고 가보자. 사용할 제원(?)은 다음과 같다.</p>\n<ol>\n<li>spring boot 2.0.3</li>\n<li>spring boot webFlux</li>\n<li>elasticsearch RestHighLevelClient (6.3.0)</li>\n</ol>\n<h2><span id=\"shut-up-and-code\">shut up and code</span></h2>\n<h3><span id=\"setting\">setting</span></h3>\n<p><code>build.gradle</code></p>\n<figure class=\"highlight gradle\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">buildscript</span> &#123;</span><br><span class=\"line\">    ext &#123;</span><br><span class=\"line\">        springBootVersion = <span class=\"string\">'2.0.3.RELEASE'</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">repositories</span> &#123;</span><br><span class=\"line\">        mavenCentral()</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">dependencies</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">classpath</span>(<span class=\"string\">\"org.springframework.boot:spring-boot-gradle-plugin:$&#123;springBootVersion&#125;\"</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">...</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">dependencies</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// for webFlux</span></span><br><span class=\"line\">    <span class=\"keyword\">compile</span>(<span class=\"string\">'org.springframework.boot:spring-boot-starter'</span>)</span><br><span class=\"line\">    <span class=\"keyword\">compile</span>(<span class=\"string\">'org.springframework.boot:spring-boot-starter-webflux'</span>) <span class=\"comment\">// 1</span></span><br><span class=\"line\">    compileOnly(<span class=\"string\">\"org.springframework.boot:spring-boot-configuration-processor\"</span>)</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// for elasticsearch</span></span><br><span class=\"line\">    <span class=\"keyword\">compile</span>(<span class=\"string\">'org.elasticsearch.client:elasticsearch-rest-high-level-client:6.3.0'</span>)</span><br><span class=\"line\">    <span class=\"keyword\">compile</span>(<span class=\"string\">'org.apache.logging.log4j:log4j-core:2.9.1'</span>)</span><br><span class=\"line\">    <span class=\"keyword\">compile</span>(<span class=\"string\">'org.elasticsearch:elasticsearch:6.3.0'</span>) <span class=\"comment\">//2</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>프로젝트는 gradle 로 구성했다. 개인적으로는 maven 보다 가독성이 좋고 문법이 간결하다고 생각한다. xml 을 그닥 좋아하지 않는 경향도 있고, 뎁스가 깊어지거나 설정자체가 길어지면 한눈에 어떤 dependency 가 걸려있는지 파악하기가 쉽지 않기 때문이다. 위의 설정에서 짚고 넘어갈 부분이 있다.</p>\n<ol>\n<li>\n<p>spring boot starter 에는 web 과 webflux 가 있다. web 은 <code>org.springframework.boot:spring-boot-starter-web</code> 이렇게 사용하는데 web 은 기본적으로 tomcat 으로 동작하고, webflux 는 netty 로 was 가 동작한다. 여기에서 주의할 점은 web과 wenflux 를 함께 넣으면 기본적으로 web 으로 동작하고 webflux 는 무시된다. 해당 내용은 <a href=\"https://docs.spring.io/spring-boot/docs/current-SNAPSHOT/reference/htmlsingle/#boot-features-webflux\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">여기</a> 에서 확인할 수 있다.</p>\n</li>\n<li>\n<p><code>org.elasticsearch.client:elasticsearch-rest-high-level-client:6.3.0</code> 만 추가하면 기본적으로 elasticsearch 5.6.x 버전의 client 가 dependency 로 따라온다. 기본적으로 사용함에 있어서는 큰 문제는 없지만 일부 기능들이 호환이 잘 안되서 엉뚱하게 동작하는 경우가 있다. 이는 rest client 로 사용했을 때에도 비슷한 상황이 있었는데 명시적으로 elasticsearch client 버전을 명시해주면 원하는 버전의 client 를 사용할 수 있다. 되도록 rest high level client 와 동일한 버전을 사용하는걸 추천한다.</p>\n</li>\n</ol>\n<p><code>ElasticsearchConfig.java</code></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Configuration</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ElasticsearchConfig</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Bean</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> RestHighLevelClient <span class=\"title\">client</span><span class=\"params\">(ElasticsearchProperties properties)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> RestHighLevelClient(</span><br><span class=\"line\">                RestClient.builder(properties.hosts())</span><br><span class=\"line\">        );</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>configuration 의 기본 설정은 rest client 와 기본 골격은 비슷하게 생겼다. (설정이나 다른 부분들이 몇가지 있지만) 크게 다른 점을 하나 꼽자면 rest high level client 부터는 tcp connection 이 아닌 http connection 을 맺는다. 그래서 기본 (elasticsearch port 인) 9200 을 사용한다. rest client 에서는 <code>InetSocketTransportAddress</code> 를 생성해서 builder 에 전달을 했었지만 restHighLevelClient 부터는 <code>HttpHost</code> 를 전달해서 생성하는 부분도 눈여겨 볼만한 부분이다. elasticsearch 설정 관련 클래스는 ElasticsearchProperties 로 묶었다. <code>@Value</code> 나 <code>ConfigurationProperties</code> annotation 으로 configuration 에서 직접 설정도 가능하지만, 특정 설정값을 service 에서 사용하기 편하기 위해 클래스를 분리했다.</p>\n<p><code>ElasticsearchProperties.java</code></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Component</span></span><br><span class=\"line\"><span class=\"meta\">@Setter</span></span><br><span class=\"line\"><span class=\"meta\">@ConfigurationProperties</span>(prefix = <span class=\"string\">\"elasticsearch\"</span>)</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ElasticsearchProperties</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> List&lt;String&gt; hosts;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> HttpHost[] hosts() &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> hosts.stream().map(HttpHost::create).toArray(HttpHost[]::<span class=\"keyword\">new</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><code>@Value</code> annotation 으로 설정해주어도 되지만, 이름이 완전히 같을 때만 설정값을 읽어들인다. <code>@ConfigurationProperties</code> annotation 은 <a href=\"https://docs.spring.io/spring-boot/docs/current/reference/html/boot-features-external-config.html#boot-features-external-config-relaxed-binding\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">Relaxed Binding</a> 이라는 느슨한(?) 룰이 있어 각자 입맛에 맞는 포멧으로 써도 properties class 에서 찰떡같이 알아 먹는다. (자신만의 스타일을 고집하는 팀에서는 나름 유용하게 사용될지는 모르겠지만 남용은 하지 말자. 버그가 생길 수 있는 포인트이다.)</p>\n<p><code>application.yml</code></p>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">elasticsearch:</span></span><br><span class=\"line\"><span class=\"attr\">  hosts:</span> <span class=\"attr\">http://localhost:9200</span></span><br></pre></td></tr></table></figure>\n<p>설정파일은 이전보다 심플해졌다. 심지어 cluster name 을 묻지도 따지지도 않는다. 연결을 맺을 때 굳이 너의 이름을 몰라도 상관없다는 뜻이였을까.</p>\n<h3><span id=\"service\">service</span></h3>\n<p>document 의 생성과 조회를 만들어 보자. (update 와 delete 는 index 와 get/match 와 비슷하기 때문에 생략한다.)</p>\n<ul>\n<li><code>index</code></li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> Mono&lt;Void&gt; <span class=\"title\">index</span><span class=\"params\">(String index, String type, String userName, String message)</span> </span>&#123;</span><br><span class=\"line\">        Gson gson = GsonUtil.gson();</span><br><span class=\"line\"></span><br><span class=\"line\">        User user = <span class=\"keyword\">new</span> User();</span><br><span class=\"line\">        user.setUser(userName);</span><br><span class=\"line\">        user.setMessage(message);</span><br><span class=\"line\">        user.setPostDate(<span class=\"keyword\">new</span> Date());</span><br><span class=\"line\"></span><br><span class=\"line\">        IndexRequest indexRequest = <span class=\"keyword\">new</span> IndexRequest(index, type);</span><br><span class=\"line\">        indexRequest.source(gson.toJson(user), XContentType.JSON);</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> Mono.create(sink -&gt; &#123;  <span class=\"comment\">//1</span></span><br><span class=\"line\">            restHighLevelClient.indexAsync(indexRequest, <span class=\"keyword\">new</span> ActionListener&lt;IndexResponse&gt;() &#123;  <span class=\"comment\">//2</span></span><br><span class=\"line\">                <span class=\"meta\">@Override</span></span><br><span class=\"line\">                <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onResponse</span><span class=\"params\">(IndexResponse indexResponse)</span> </span>&#123;</span><br><span class=\"line\">                    log.info(<span class=\"string\">\"index success : \"</span>+indexResponse.toString());</span><br><span class=\"line\">                    sink.success();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">                <span class=\"meta\">@Override</span></span><br><span class=\"line\">                <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onFailure</span><span class=\"params\">(Exception e)</span> </span>&#123;</span><br><span class=\"line\">                    log.error(<span class=\"string\">\"index error \"</span>, e);</span><br><span class=\"line\">                    sink.error(e);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;);</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<p>index 메소드는 특정한 반환값을 필요로 하지 않기 때문에 <code>Mono&lt;Void&gt;</code> 를 사용한다. client 에서는 기존의 index 메소드와 indexAsync 를 제공한다. (대부분의 메소드들이 동일하게 제공) 위의 동작은 공식문서의 <a href=\"https://www.elastic.co/guide/en/elasticsearch/reference/current/docs-index_.html#docs-index_\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">index</a> 부분의 동작을 코드로 작성한 부분이다. url 로 풀어 쓰면 다음과 같다.</p>\n<figure class=\"highlight ada\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ curl -X PUT <span class=\"string\">\"localhost:9200/twitter/_doc/1\"</span> -H <span class=\"symbol\">'Content</span>-<span class=\"keyword\">Type</span>: application/json' -d'</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"string\">\"user\"</span> : \"<span class=\"type\">kimchy</span><span class=\"string\">\",</span></span><br><span class=\"line\"><span class=\"string\">    \"</span>post_date<span class=\"string\">\" : \"</span><span class=\"number\">2009</span>-<span class=\"number\">11</span>-<span class=\"number\">15</span>T14:<span class=\"number\">12</span>:<span class=\"number\">12</span><span class=\"string\">\",</span></span><br><span class=\"line\"><span class=\"string\">    \"</span>message<span class=\"string\">\" : \"</span>trying <span class=\"keyword\">out</span> Elasticsearch<span class=\"string\">\"</span></span><br><span class=\"line\"><span class=\"string\">&#125;</span></span><br><span class=\"line\"><span class=\"string\">'</span></span><br></pre></td></tr></table></figure>\n<p>indexAsync 메소드를 사용했고 이를 <a href=\"https://projectreactor.io/docs/core/release/api/index.html?reactor/core/publisher/Mono.html\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">MonoSink</a> 로 감싸주었다. Mono 는 0…1 의 상태이므로 하나의 index 결과에 대한 성공여부를 publish 해준다. controller 에서는 다음과 같이 받아 처리해준다.</p>\n<p><code>controller.java</code></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@RequestMapping</span>(value = <span class=\"string\">\"/index/&#123;index&#125;/&#123;type&#125;\"</span>, method = &#123;RequestMethod.POST&#125;)</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Mono&lt;Void&gt; <span class=\"title\">index</span><span class=\"params\">(@PathVariable(<span class=\"string\">\"index\"</span>)</span> String index,</span></span><br><span class=\"line\"><span class=\"function\">                            @<span class=\"title\">PathVariable</span><span class=\"params\">(<span class=\"string\">\"type\"</span>)</span> String type,</span></span><br><span class=\"line\"><span class=\"function\">                            @<span class=\"title\">RequestParam</span><span class=\"params\">(value = <span class=\"string\">\"user_name\"</span>)</span> String userName,</span></span><br><span class=\"line\"><span class=\"function\">                            @<span class=\"title\">RequestParam</span><span class=\"params\">(value = <span class=\"string\">\"message\"</span>)</span> String message) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> elasticsearchService.index(index, type, userName, message)</span><br><span class=\"line\">                .onErrorResume(error -&gt; &#123;</span><br><span class=\"line\">                    log.error(<span class=\"string\">\"index error \"</span>, error);</span><br><span class=\"line\">            <span class=\"keyword\">return</span> Mono.empty();</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<p>index 동작 이후 특정한 값을 반환하고자 한다면 Mono 안의 타입을 원하는 클래스를 정의해주자.</p>\n<ul>\n<li><code>get</code></li>\n</ul>\n<p>document 를 넣었으면 값이 잘 들어갔는지 확인이 필요하겠다. <a href=\"https://www.elastic.co/guide/en/elasticsearch/reference/current/docs-get.html#docs-get\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">get api</a> 를 추가해보자.</p>\n<figure class=\"highlight routeros\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ curl -X <span class=\"builtin-name\">GET</span> <span class=\"string\">\"localhost:9200/twitter/_doc/0\"</span></span><br></pre></td></tr></table></figure>\n<p>이 api 를 rest high level client 로 작성하면 아래와 같다.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> Mono&lt;User&gt; <span class=\"title\">getUser</span><span class=\"params\">(String index, String type, String id)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">final</span> Gson gson = GsonUtil.gson();</span><br><span class=\"line\">    GetRequest getRequest = <span class=\"keyword\">new</span> GetRequest(index, type, id);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> Mono.create(sink -&gt; &#123;</span><br><span class=\"line\">        restHighLevelClient.getAsync(getRequest, <span class=\"keyword\">new</span> ActionListener&lt;GetResponse&gt;() &#123;</span><br><span class=\"line\">            <span class=\"meta\">@Override</span></span><br><span class=\"line\">            <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onResponse</span><span class=\"params\">(GetResponse documentFields)</span> </span>&#123;</span><br><span class=\"line\">                User user = gson.fromJson(documentFields.getSourceAsString(), User.class);</span><br><span class=\"line\">                sink.success(user);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"meta\">@Override</span></span><br><span class=\"line\">            <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onFailure</span><span class=\"params\">(Exception e)</span> </span>&#123;</span><br><span class=\"line\">                e.printStackTrace();</span><br><span class=\"line\">                sink.error(e);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>index 에서와 같이 Mono 로 감싸서 반환을 하였고 이번에는 필요한 값인 User 객체를 사용하였다.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@GetMapping</span>(<span class=\"string\">\"get/&#123;index&#125;/&#123;type&#125;/&#123;id&#125;\"</span>)</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> Mono&lt;User&gt; <span class=\"title\">getAsync</span><span class=\"params\">(@PathVariable(<span class=\"string\">\"index\"</span>)</span> String index,</span></span><br><span class=\"line\"><span class=\"function\">                           @<span class=\"title\">PathVariable</span><span class=\"params\">(<span class=\"string\">\"type\"</span>)</span> String type,</span></span><br><span class=\"line\"><span class=\"function\">                           @<span class=\"title\">PathVariable</span><span class=\"params\">(<span class=\"string\">\"id\"</span>)</span> String id) </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"keyword\">return</span> elasticsearchService.getUser(index, type, id)</span><br><span class=\"line\">           .onErrorResume(error -&gt; &#123;</span><br><span class=\"line\">               User defaultUser = <span class=\"keyword\">new</span> User();</span><br><span class=\"line\">               defaultUser.setUser(<span class=\"string\">\"default\"</span>);</span><br><span class=\"line\">               defaultUser.setPostDate(<span class=\"keyword\">new</span> Date());</span><br><span class=\"line\">               defaultUser.setMessage(<span class=\"string\">\"default message\"</span>);</span><br><span class=\"line\">               <span class=\"keyword\">return</span> Mono.just(defaultUser);</span><br><span class=\"line\">           &#125;)</span><br><span class=\"line\">           .defaultIfEmpty(<span class=\"keyword\">new</span> User());</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>service 에서 <code>Mono&lt;User&gt;</code> 를 받아 반환을 해준다. <code>onErrorResume</code> 이나 <code>defaultIfEmpty</code> 는 service 에서 정상동작을 하지 않았을 경우의 후처리 이다. 여기에서 짚고 넘어갈 부분이라면, 우리는 restful Api 를 만들고 있기 때문에 controller 가 <code>@RestController</code> 이거나 mapping method 에 <code>@ResponseBody</code> annotation 이 걸려있으면 위와 같이 바로 <code>Mono</code> 를 반환해도 된다.<br>\n하지만 <code>@Controller</code> annotation 을 사용하고 있다면 http status 값이 넘어가지 않기 때문에 mapping method 에 <code>@ResponseBody</code> 를 걸어주거나 <code>ResponseEntity</code> 객체로 한번 더 감싸서 반환해주어야 한다. 다음과 같이 감싸줄 수 있겠다.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@GetMapping</span>(<span class=\"string\">\"get/&#123;index&#125;/&#123;type&#125;/&#123;id&#125;\"</span>)</span><br><span class=\"line\"><span class=\"keyword\">public</span> Mono&lt;ResponseEntity&lt;User&gt;&gt; getAsync2(<span class=\"meta\">@PathVariable</span>(<span class=\"string\">\"index\"</span>) String index,</span><br><span class=\"line\">                                           <span class=\"meta\">@PathVariable</span>(<span class=\"string\">\"type\"</span>) String type,</span><br><span class=\"line\">                                           <span class=\"meta\">@PathVariable</span>(<span class=\"string\">\"id\"</span>) String id) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> elasticsearchService.getUser(index, type, id)</span><br><span class=\"line\">            .map(ResponseEntity::ok)</span><br><span class=\"line\">            .onErrorResume(error -&gt; Mono.just(ResponseEntity.badRequest().build()))</span><br><span class=\"line\">            .defaultIfEmpty(ResponseEntity.status(HttpStatus.OK).body(<span class=\"keyword\">new</span> User()));</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>취향과 상황에 맞게 선택하도록 하자.</p>\n<ul>\n<li><code>match all</code></li>\n</ul>\n<p><a href=\"https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-match-all-query.html#query-dsl-match-all-query\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">match all api</a> 도 추가해보자.</p>\n<figure class=\"highlight sml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ curl -<span class=\"type\">X</span> <span class=\"type\">GET</span> <span class=\"string\">\"localhost:9200/_search\"</span> -<span class=\"type\">H</span> <span class=\"symbol\">'Content</span>-<span class=\"type\">Type</span>: application/json' -d'</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"string\">\"query\"</span>: &#123;</span><br><span class=\"line\">        <span class=\"string\">\"match_all\"</span>: &#123;&#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"string\">'</span></span><br></pre></td></tr></table></figure>\n<p>코드로 작성하면 다음과 같다.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> Flux&lt;User&gt; <span class=\"title\">matchAll</span><span class=\"params\">(String index)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">final</span> Gson gson = GsonUtil.gson();</span><br><span class=\"line\"></span><br><span class=\"line\">    SearchSourceBuilder searchSourceBuilder = <span class=\"keyword\">new</span> SearchSourceBuilder();</span><br><span class=\"line\">    searchSourceBuilder.query(QueryBuilders.matchAllQuery());</span><br><span class=\"line\"></span><br><span class=\"line\">    SearchRequest searchRequest = <span class=\"keyword\">new</span> SearchRequest(index);</span><br><span class=\"line\">    searchRequest.source(searchSourceBuilder);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> Flux.create((FluxSink&lt;User&gt; sink) -&gt; &#123;</span><br><span class=\"line\">        restHighLevelClient.searchAsync(searchRequest, <span class=\"keyword\">new</span> ActionListener&lt;SearchResponse&gt;() &#123;</span><br><span class=\"line\">            <span class=\"meta\">@Override</span></span><br><span class=\"line\">            <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onResponse</span><span class=\"params\">(SearchResponse searchResponse)</span> </span>&#123;</span><br><span class=\"line\">                searchResponse.getHits().forEach(item -&gt; &#123;</span><br><span class=\"line\">                    User user = gson.fromJson(item.getSourceAsString(), User.class);</span><br><span class=\"line\">                    sink.next(user);</span><br><span class=\"line\">                &#125;);</span><br><span class=\"line\">                sink.complete();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"meta\">@Override</span></span><br><span class=\"line\">            <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onFailure</span><span class=\"params\">(Exception e)</span> </span>&#123;</span><br><span class=\"line\">                log.error(<span class=\"string\">\"matchAll error \"</span>, e);</span><br><span class=\"line\">                sink.error(e);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@GetMapping</span>(<span class=\"string\">\"/match_all/&#123;index&#125;\"</span>)</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> Flux&lt;User&gt; <span class=\"title\">matchAll</span><span class=\"params\">(@PathVariable(<span class=\"string\">\"index\"</span>)</span> String index) </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> elasticsearchService.matchAll(index).onErrorResume((Throwable error) -&gt; &#123;</span><br><span class=\"line\">        log.error(<span class=\"string\">\"err\"</span>, error);</span><br><span class=\"line\">        User user = <span class=\"keyword\">new</span> User();</span><br><span class=\"line\">        user.setPostDate(<span class=\"keyword\">new</span> Date());</span><br><span class=\"line\">        user.setUser(<span class=\"string\">\"default User\"</span>);</span><br><span class=\"line\">        user.setMessage(<span class=\"string\">\"default message\"</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> Flux.just(user);</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>복수개의 값을 반환할 수 있으므로 Flux 로 반환해준다. 물론 List 로 묶어서 Mono 로 반환해야할 수도 있다. MonoSink 와의 차이점은 next 로 데이터를 넘기다가 모든 데이터가 넘어가면 complete 를 호출 해주는 부분이다.</p>\n<h2><span id=\"결론\">결론</span></h2>\n<p>webflux 와 restHighLevelClient 사용하여 비동기 api 를 제공해줄 수 있다. webflux 는 꽤나 멋지게 동작하지만 아직까지는 모든 서드파티들이 지원을 해주고 있지 않아 하드하게 사용하기에는 주저되는 부분이 있다. (jdbc 를 사용하지 않는다면 추천!)<br>\nrestHighLevelClient 로 넘어오면서 각 클래스들의 역할이 명확해진 느낌이고 선언과 사용도 좀 더 명확해져서 편하다는 인상을 많이 받았다. 위의 예제코드는 <a href=\"https://github.com/nevercaution/elasticsearch_java_client\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">여기</a> 에서 확인할 수 있다.</p>\n<h3><span id=\"여담\">여담</span></h3>\n<p>elasticsearch 에 kibana 를 얹으면 devtool 을 이용해서 (무려 자동완성이 제공되는) 쿼리를 날려볼 수 있다. 지금껏 sense 나 다른 툴들을 조금은 불편하게 사용해왔었는데, 반길만한 부분이다. 다만 개인적으로는 redis-cli 처럼 CLI tool 이 제공되면 좋았을 거라는 생각에 <a href=\"https://github.com/nevercaution/elasticsearch-cli\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">elasticsearch-cli</a> 를 만들어 보는 중이다. 물론 elastic 진영에서는 <a href=\"https://www.elastic.co/guide/en/elasticsearch/client/curator/current/about-cli.html\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">curator</a> 을 제공해주고 있긴 하지만 모니터링 툴이라 간단한 match query 나 analyze 등을 사용할 수는 없다. 나름 일하면서 편하게 사용하는중이다. ㅎㅎ</p>\n","site":{"data":{}},"excerpt":"","more":"<h2>elasticsearch &amp; spring boot &amp; webflux</h2>\n<h3>elasticsearch 6.3.0</h3>\n<p>elasticsearch 가 <a href=\"https://www.elastic.co/blog/elasticsearch-6-3-0-released\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">6.3.0</a>  으로 올라갔다. 여러가지 기능들이 추가되었는데, 흥미로운 부분은 내부 client 로 SQL 문법을 지원한다는것이다. 생각보다 놀랍게 동작한다! 메인 버전이 올라가면서 java client 버전도 함께 올라갔는데 드디어 java rest high level client 가 쓸만한 모듈이 되었다는 점이다. 예전까지는 java client 만 사용해왔었는데 이젠 슬슬 넘어갈 수 있을 것같아서 후딱 한번 사용해보았다.</p>\n<h3>RestHighLevelClient</h3>\n<p><a href=\"https://nevercaution.github.io/2018/03/15/elasticsearch-rest-client/\">이전 포스트</a> 에서 살짝 훑어만 봤었는데 elasticsearch java client 가 6.3.0 으로 업데이트 되면서 대부분의 기능들을 사용할 수 있게 되었다. 언제나 릴리즈되나 눈빠지게 기다리고 있었는데 6.3.0 이 릴리즈 되자마자 한번 적용해보았다.</p>\n<h3>async</h3>\n<p>RestHighLevelClient 에서는 대부분의 메소드에 async 를 지원한다. spring webFlux 를 공부하면서 elasticsearch 가 async 를 지원하지 않아서 반쪽짜리로 사용하고 있었는데, 함께 사용해보니 궁합이 꽤나 잘맞았다.</p>\n<h3>오늘의 목표</h3>\n<p>이번 포스팅은 webFlux 와 elasticsearch 가 짬뽕이 되었다. 두 꼭지에서 꼭 알고 가야하는 부분만 짚고 가보자. 사용할 제원(?)은 다음과 같다.</p>\n<ol>\n<li>spring boot 2.0.3</li>\n<li>spring boot webFlux</li>\n<li>elasticsearch RestHighLevelClient (6.3.0)</li>\n</ol>\n<h2>shut up and code</h2>\n<h3>setting</h3>\n<p><code>build.gradle</code></p>\n<figure class=\"highlight gradle\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">buildscript</span> &#123;</span><br><span class=\"line\">    ext &#123;</span><br><span class=\"line\">        springBootVersion = <span class=\"string\">'2.0.3.RELEASE'</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">repositories</span> &#123;</span><br><span class=\"line\">        mavenCentral()</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">dependencies</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">classpath</span>(<span class=\"string\">\"org.springframework.boot:spring-boot-gradle-plugin:$&#123;springBootVersion&#125;\"</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">...</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">dependencies</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// for webFlux</span></span><br><span class=\"line\">    <span class=\"keyword\">compile</span>(<span class=\"string\">'org.springframework.boot:spring-boot-starter'</span>)</span><br><span class=\"line\">    <span class=\"keyword\">compile</span>(<span class=\"string\">'org.springframework.boot:spring-boot-starter-webflux'</span>) <span class=\"comment\">// 1</span></span><br><span class=\"line\">    compileOnly(<span class=\"string\">\"org.springframework.boot:spring-boot-configuration-processor\"</span>)</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// for elasticsearch</span></span><br><span class=\"line\">    <span class=\"keyword\">compile</span>(<span class=\"string\">'org.elasticsearch.client:elasticsearch-rest-high-level-client:6.3.0'</span>)</span><br><span class=\"line\">    <span class=\"keyword\">compile</span>(<span class=\"string\">'org.apache.logging.log4j:log4j-core:2.9.1'</span>)</span><br><span class=\"line\">    <span class=\"keyword\">compile</span>(<span class=\"string\">'org.elasticsearch:elasticsearch:6.3.0'</span>) <span class=\"comment\">//2</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>프로젝트는 gradle 로 구성했다. 개인적으로는 maven 보다 가독성이 좋고 문법이 간결하다고 생각한다. xml 을 그닥 좋아하지 않는 경향도 있고, 뎁스가 깊어지거나 설정자체가 길어지면 한눈에 어떤 dependency 가 걸려있는지 파악하기가 쉽지 않기 때문이다. 위의 설정에서 짚고 넘어갈 부분이 있다.</p>\n<ol>\n<li>\n<p>spring boot starter 에는 web 과 webflux 가 있다. web 은 <code>org.springframework.boot:spring-boot-starter-web</code> 이렇게 사용하는데 web 은 기본적으로 tomcat 으로 동작하고, webflux 는 netty 로 was 가 동작한다. 여기에서 주의할 점은 web과 wenflux 를 함께 넣으면 기본적으로 web 으로 동작하고 webflux 는 무시된다. 해당 내용은 <a href=\"https://docs.spring.io/spring-boot/docs/current-SNAPSHOT/reference/htmlsingle/#boot-features-webflux\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">여기</a> 에서 확인할 수 있다.</p>\n</li>\n<li>\n<p><code>org.elasticsearch.client:elasticsearch-rest-high-level-client:6.3.0</code> 만 추가하면 기본적으로 elasticsearch 5.6.x 버전의 client 가 dependency 로 따라온다. 기본적으로 사용함에 있어서는 큰 문제는 없지만 일부 기능들이 호환이 잘 안되서 엉뚱하게 동작하는 경우가 있다. 이는 rest client 로 사용했을 때에도 비슷한 상황이 있었는데 명시적으로 elasticsearch client 버전을 명시해주면 원하는 버전의 client 를 사용할 수 있다. 되도록 rest high level client 와 동일한 버전을 사용하는걸 추천한다.</p>\n</li>\n</ol>\n<p><code>ElasticsearchConfig.java</code></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Configuration</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ElasticsearchConfig</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Bean</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> RestHighLevelClient <span class=\"title\">client</span><span class=\"params\">(ElasticsearchProperties properties)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> RestHighLevelClient(</span><br><span class=\"line\">                RestClient.builder(properties.hosts())</span><br><span class=\"line\">        );</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>configuration 의 기본 설정은 rest client 와 기본 골격은 비슷하게 생겼다. (설정이나 다른 부분들이 몇가지 있지만) 크게 다른 점을 하나 꼽자면 rest high level client 부터는 tcp connection 이 아닌 http connection 을 맺는다. 그래서 기본 (elasticsearch port 인) 9200 을 사용한다. rest client 에서는 <code>InetSocketTransportAddress</code> 를 생성해서 builder 에 전달을 했었지만 restHighLevelClient 부터는 <code>HttpHost</code> 를 전달해서 생성하는 부분도 눈여겨 볼만한 부분이다. elasticsearch 설정 관련 클래스는 ElasticsearchProperties 로 묶었다. <code>@Value</code> 나 <code>ConfigurationProperties</code> annotation 으로 configuration 에서 직접 설정도 가능하지만, 특정 설정값을 service 에서 사용하기 편하기 위해 클래스를 분리했다.</p>\n<p><code>ElasticsearchProperties.java</code></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Component</span></span><br><span class=\"line\"><span class=\"meta\">@Setter</span></span><br><span class=\"line\"><span class=\"meta\">@ConfigurationProperties</span>(prefix = <span class=\"string\">\"elasticsearch\"</span>)</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ElasticsearchProperties</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> List&lt;String&gt; hosts;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> HttpHost[] hosts() &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> hosts.stream().map(HttpHost::create).toArray(HttpHost[]::<span class=\"keyword\">new</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><code>@Value</code> annotation 으로 설정해주어도 되지만, 이름이 완전히 같을 때만 설정값을 읽어들인다. <code>@ConfigurationProperties</code> annotation 은 <a href=\"https://docs.spring.io/spring-boot/docs/current/reference/html/boot-features-external-config.html#boot-features-external-config-relaxed-binding\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">Relaxed Binding</a> 이라는 느슨한(?) 룰이 있어 각자 입맛에 맞는 포멧으로 써도 properties class 에서 찰떡같이 알아 먹는다. (자신만의 스타일을 고집하는 팀에서는 나름 유용하게 사용될지는 모르겠지만 남용은 하지 말자. 버그가 생길 수 있는 포인트이다.)</p>\n<p><code>application.yml</code></p>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">elasticsearch:</span></span><br><span class=\"line\"><span class=\"attr\">  hosts:</span> <span class=\"attr\">http://localhost:9200</span></span><br></pre></td></tr></table></figure>\n<p>설정파일은 이전보다 심플해졌다. 심지어 cluster name 을 묻지도 따지지도 않는다. 연결을 맺을 때 굳이 너의 이름을 몰라도 상관없다는 뜻이였을까.</p>\n<h3>service</h3>\n<p>document 의 생성과 조회를 만들어 보자. (update 와 delete 는 index 와 get/match 와 비슷하기 때문에 생략한다.)</p>\n<ul>\n<li><code>index</code></li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> Mono&lt;Void&gt; <span class=\"title\">index</span><span class=\"params\">(String index, String type, String userName, String message)</span> </span>&#123;</span><br><span class=\"line\">        Gson gson = GsonUtil.gson();</span><br><span class=\"line\"></span><br><span class=\"line\">        User user = <span class=\"keyword\">new</span> User();</span><br><span class=\"line\">        user.setUser(userName);</span><br><span class=\"line\">        user.setMessage(message);</span><br><span class=\"line\">        user.setPostDate(<span class=\"keyword\">new</span> Date());</span><br><span class=\"line\"></span><br><span class=\"line\">        IndexRequest indexRequest = <span class=\"keyword\">new</span> IndexRequest(index, type);</span><br><span class=\"line\">        indexRequest.source(gson.toJson(user), XContentType.JSON);</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> Mono.create(sink -&gt; &#123;  <span class=\"comment\">//1</span></span><br><span class=\"line\">            restHighLevelClient.indexAsync(indexRequest, <span class=\"keyword\">new</span> ActionListener&lt;IndexResponse&gt;() &#123;  <span class=\"comment\">//2</span></span><br><span class=\"line\">                <span class=\"meta\">@Override</span></span><br><span class=\"line\">                <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onResponse</span><span class=\"params\">(IndexResponse indexResponse)</span> </span>&#123;</span><br><span class=\"line\">                    log.info(<span class=\"string\">\"index success : \"</span>+indexResponse.toString());</span><br><span class=\"line\">                    sink.success();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">                <span class=\"meta\">@Override</span></span><br><span class=\"line\">                <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onFailure</span><span class=\"params\">(Exception e)</span> </span>&#123;</span><br><span class=\"line\">                    log.error(<span class=\"string\">\"index error \"</span>, e);</span><br><span class=\"line\">                    sink.error(e);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;);</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<p>index 메소드는 특정한 반환값을 필요로 하지 않기 때문에 <code>Mono&lt;Void&gt;</code> 를 사용한다. client 에서는 기존의 index 메소드와 indexAsync 를 제공한다. (대부분의 메소드들이 동일하게 제공) 위의 동작은 공식문서의 <a href=\"https://www.elastic.co/guide/en/elasticsearch/reference/current/docs-index_.html#docs-index_\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">index</a> 부분의 동작을 코드로 작성한 부분이다. url 로 풀어 쓰면 다음과 같다.</p>\n<figure class=\"highlight ada\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ curl -X PUT <span class=\"string\">\"localhost:9200/twitter/_doc/1\"</span> -H <span class=\"symbol\">'Content</span>-<span class=\"keyword\">Type</span>: application/json' -d'</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"string\">\"user\"</span> : \"<span class=\"type\">kimchy</span><span class=\"string\">\",</span></span><br><span class=\"line\"><span class=\"string\">    \"</span>post_date<span class=\"string\">\" : \"</span><span class=\"number\">2009</span>-<span class=\"number\">11</span>-<span class=\"number\">15</span>T14:<span class=\"number\">12</span>:<span class=\"number\">12</span><span class=\"string\">\",</span></span><br><span class=\"line\"><span class=\"string\">    \"</span>message<span class=\"string\">\" : \"</span>trying <span class=\"keyword\">out</span> Elasticsearch<span class=\"string\">\"</span></span><br><span class=\"line\"><span class=\"string\">&#125;</span></span><br><span class=\"line\"><span class=\"string\">'</span></span><br></pre></td></tr></table></figure>\n<p>indexAsync 메소드를 사용했고 이를 <a href=\"https://projectreactor.io/docs/core/release/api/index.html?reactor/core/publisher/Mono.html\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">MonoSink</a> 로 감싸주었다. Mono 는 0…1 의 상태이므로 하나의 index 결과에 대한 성공여부를 publish 해준다. controller 에서는 다음과 같이 받아 처리해준다.</p>\n<p><code>controller.java</code></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@RequestMapping</span>(value = <span class=\"string\">\"/index/&#123;index&#125;/&#123;type&#125;\"</span>, method = &#123;RequestMethod.POST&#125;)</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Mono&lt;Void&gt; <span class=\"title\">index</span><span class=\"params\">(@PathVariable(<span class=\"string\">\"index\"</span>)</span> String index,</span></span><br><span class=\"line\"><span class=\"function\">                            @<span class=\"title\">PathVariable</span><span class=\"params\">(<span class=\"string\">\"type\"</span>)</span> String type,</span></span><br><span class=\"line\"><span class=\"function\">                            @<span class=\"title\">RequestParam</span><span class=\"params\">(value = <span class=\"string\">\"user_name\"</span>)</span> String userName,</span></span><br><span class=\"line\"><span class=\"function\">                            @<span class=\"title\">RequestParam</span><span class=\"params\">(value = <span class=\"string\">\"message\"</span>)</span> String message) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> elasticsearchService.index(index, type, userName, message)</span><br><span class=\"line\">                .onErrorResume(error -&gt; &#123;</span><br><span class=\"line\">                    log.error(<span class=\"string\">\"index error \"</span>, error);</span><br><span class=\"line\">            <span class=\"keyword\">return</span> Mono.empty();</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<p>index 동작 이후 특정한 값을 반환하고자 한다면 Mono 안의 타입을 원하는 클래스를 정의해주자.</p>\n<ul>\n<li><code>get</code></li>\n</ul>\n<p>document 를 넣었으면 값이 잘 들어갔는지 확인이 필요하겠다. <a href=\"https://www.elastic.co/guide/en/elasticsearch/reference/current/docs-get.html#docs-get\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">get api</a> 를 추가해보자.</p>\n<figure class=\"highlight routeros\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ curl -X <span class=\"builtin-name\">GET</span> <span class=\"string\">\"localhost:9200/twitter/_doc/0\"</span></span><br></pre></td></tr></table></figure>\n<p>이 api 를 rest high level client 로 작성하면 아래와 같다.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> Mono&lt;User&gt; <span class=\"title\">getUser</span><span class=\"params\">(String index, String type, String id)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">final</span> Gson gson = GsonUtil.gson();</span><br><span class=\"line\">    GetRequest getRequest = <span class=\"keyword\">new</span> GetRequest(index, type, id);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> Mono.create(sink -&gt; &#123;</span><br><span class=\"line\">        restHighLevelClient.getAsync(getRequest, <span class=\"keyword\">new</span> ActionListener&lt;GetResponse&gt;() &#123;</span><br><span class=\"line\">            <span class=\"meta\">@Override</span></span><br><span class=\"line\">            <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onResponse</span><span class=\"params\">(GetResponse documentFields)</span> </span>&#123;</span><br><span class=\"line\">                User user = gson.fromJson(documentFields.getSourceAsString(), User.class);</span><br><span class=\"line\">                sink.success(user);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"meta\">@Override</span></span><br><span class=\"line\">            <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onFailure</span><span class=\"params\">(Exception e)</span> </span>&#123;</span><br><span class=\"line\">                e.printStackTrace();</span><br><span class=\"line\">                sink.error(e);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>index 에서와 같이 Mono 로 감싸서 반환을 하였고 이번에는 필요한 값인 User 객체를 사용하였다.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@GetMapping</span>(<span class=\"string\">\"get/&#123;index&#125;/&#123;type&#125;/&#123;id&#125;\"</span>)</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> Mono&lt;User&gt; <span class=\"title\">getAsync</span><span class=\"params\">(@PathVariable(<span class=\"string\">\"index\"</span>)</span> String index,</span></span><br><span class=\"line\"><span class=\"function\">                           @<span class=\"title\">PathVariable</span><span class=\"params\">(<span class=\"string\">\"type\"</span>)</span> String type,</span></span><br><span class=\"line\"><span class=\"function\">                           @<span class=\"title\">PathVariable</span><span class=\"params\">(<span class=\"string\">\"id\"</span>)</span> String id) </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"keyword\">return</span> elasticsearchService.getUser(index, type, id)</span><br><span class=\"line\">           .onErrorResume(error -&gt; &#123;</span><br><span class=\"line\">               User defaultUser = <span class=\"keyword\">new</span> User();</span><br><span class=\"line\">               defaultUser.setUser(<span class=\"string\">\"default\"</span>);</span><br><span class=\"line\">               defaultUser.setPostDate(<span class=\"keyword\">new</span> Date());</span><br><span class=\"line\">               defaultUser.setMessage(<span class=\"string\">\"default message\"</span>);</span><br><span class=\"line\">               <span class=\"keyword\">return</span> Mono.just(defaultUser);</span><br><span class=\"line\">           &#125;)</span><br><span class=\"line\">           .defaultIfEmpty(<span class=\"keyword\">new</span> User());</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>service 에서 <code>Mono&lt;User&gt;</code> 를 받아 반환을 해준다. <code>onErrorResume</code> 이나 <code>defaultIfEmpty</code> 는 service 에서 정상동작을 하지 않았을 경우의 후처리 이다. 여기에서 짚고 넘어갈 부분이라면, 우리는 restful Api 를 만들고 있기 때문에 controller 가 <code>@RestController</code> 이거나 mapping method 에 <code>@ResponseBody</code> annotation 이 걸려있으면 위와 같이 바로 <code>Mono</code> 를 반환해도 된다.<br>\n하지만 <code>@Controller</code> annotation 을 사용하고 있다면 http status 값이 넘어가지 않기 때문에 mapping method 에 <code>@ResponseBody</code> 를 걸어주거나 <code>ResponseEntity</code> 객체로 한번 더 감싸서 반환해주어야 한다. 다음과 같이 감싸줄 수 있겠다.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@GetMapping</span>(<span class=\"string\">\"get/&#123;index&#125;/&#123;type&#125;/&#123;id&#125;\"</span>)</span><br><span class=\"line\"><span class=\"keyword\">public</span> Mono&lt;ResponseEntity&lt;User&gt;&gt; getAsync2(<span class=\"meta\">@PathVariable</span>(<span class=\"string\">\"index\"</span>) String index,</span><br><span class=\"line\">                                           <span class=\"meta\">@PathVariable</span>(<span class=\"string\">\"type\"</span>) String type,</span><br><span class=\"line\">                                           <span class=\"meta\">@PathVariable</span>(<span class=\"string\">\"id\"</span>) String id) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> elasticsearchService.getUser(index, type, id)</span><br><span class=\"line\">            .map(ResponseEntity::ok)</span><br><span class=\"line\">            .onErrorResume(error -&gt; Mono.just(ResponseEntity.badRequest().build()))</span><br><span class=\"line\">            .defaultIfEmpty(ResponseEntity.status(HttpStatus.OK).body(<span class=\"keyword\">new</span> User()));</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>취향과 상황에 맞게 선택하도록 하자.</p>\n<ul>\n<li><code>match all</code></li>\n</ul>\n<p><a href=\"https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-match-all-query.html#query-dsl-match-all-query\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">match all api</a> 도 추가해보자.</p>\n<figure class=\"highlight sml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ curl -<span class=\"type\">X</span> <span class=\"type\">GET</span> <span class=\"string\">\"localhost:9200/_search\"</span> -<span class=\"type\">H</span> <span class=\"symbol\">'Content</span>-<span class=\"type\">Type</span>: application/json' -d'</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"string\">\"query\"</span>: &#123;</span><br><span class=\"line\">        <span class=\"string\">\"match_all\"</span>: &#123;&#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"string\">'</span></span><br></pre></td></tr></table></figure>\n<p>코드로 작성하면 다음과 같다.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> Flux&lt;User&gt; <span class=\"title\">matchAll</span><span class=\"params\">(String index)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">final</span> Gson gson = GsonUtil.gson();</span><br><span class=\"line\"></span><br><span class=\"line\">    SearchSourceBuilder searchSourceBuilder = <span class=\"keyword\">new</span> SearchSourceBuilder();</span><br><span class=\"line\">    searchSourceBuilder.query(QueryBuilders.matchAllQuery());</span><br><span class=\"line\"></span><br><span class=\"line\">    SearchRequest searchRequest = <span class=\"keyword\">new</span> SearchRequest(index);</span><br><span class=\"line\">    searchRequest.source(searchSourceBuilder);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> Flux.create((FluxSink&lt;User&gt; sink) -&gt; &#123;</span><br><span class=\"line\">        restHighLevelClient.searchAsync(searchRequest, <span class=\"keyword\">new</span> ActionListener&lt;SearchResponse&gt;() &#123;</span><br><span class=\"line\">            <span class=\"meta\">@Override</span></span><br><span class=\"line\">            <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onResponse</span><span class=\"params\">(SearchResponse searchResponse)</span> </span>&#123;</span><br><span class=\"line\">                searchResponse.getHits().forEach(item -&gt; &#123;</span><br><span class=\"line\">                    User user = gson.fromJson(item.getSourceAsString(), User.class);</span><br><span class=\"line\">                    sink.next(user);</span><br><span class=\"line\">                &#125;);</span><br><span class=\"line\">                sink.complete();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"meta\">@Override</span></span><br><span class=\"line\">            <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onFailure</span><span class=\"params\">(Exception e)</span> </span>&#123;</span><br><span class=\"line\">                log.error(<span class=\"string\">\"matchAll error \"</span>, e);</span><br><span class=\"line\">                sink.error(e);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@GetMapping</span>(<span class=\"string\">\"/match_all/&#123;index&#125;\"</span>)</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> Flux&lt;User&gt; <span class=\"title\">matchAll</span><span class=\"params\">(@PathVariable(<span class=\"string\">\"index\"</span>)</span> String index) </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> elasticsearchService.matchAll(index).onErrorResume((Throwable error) -&gt; &#123;</span><br><span class=\"line\">        log.error(<span class=\"string\">\"err\"</span>, error);</span><br><span class=\"line\">        User user = <span class=\"keyword\">new</span> User();</span><br><span class=\"line\">        user.setPostDate(<span class=\"keyword\">new</span> Date());</span><br><span class=\"line\">        user.setUser(<span class=\"string\">\"default User\"</span>);</span><br><span class=\"line\">        user.setMessage(<span class=\"string\">\"default message\"</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> Flux.just(user);</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>복수개의 값을 반환할 수 있으므로 Flux 로 반환해준다. 물론 List 로 묶어서 Mono 로 반환해야할 수도 있다. MonoSink 와의 차이점은 next 로 데이터를 넘기다가 모든 데이터가 넘어가면 complete 를 호출 해주는 부분이다.</p>\n<h2>결론</h2>\n<p>webflux 와 restHighLevelClient 사용하여 비동기 api 를 제공해줄 수 있다. webflux 는 꽤나 멋지게 동작하지만 아직까지는 모든 서드파티들이 지원을 해주고 있지 않아 하드하게 사용하기에는 주저되는 부분이 있다. (jdbc 를 사용하지 않는다면 추천!)<br>\nrestHighLevelClient 로 넘어오면서 각 클래스들의 역할이 명확해진 느낌이고 선언과 사용도 좀 더 명확해져서 편하다는 인상을 많이 받았다. 위의 예제코드는 <a href=\"https://github.com/nevercaution/elasticsearch_java_client\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">여기</a> 에서 확인할 수 있다.</p>\n<h3>여담</h3>\n<p>elasticsearch 에 kibana 를 얹으면 devtool 을 이용해서 (무려 자동완성이 제공되는) 쿼리를 날려볼 수 있다. 지금껏 sense 나 다른 툴들을 조금은 불편하게 사용해왔었는데, 반길만한 부분이다. 다만 개인적으로는 redis-cli 처럼 CLI tool 이 제공되면 좋았을 거라는 생각에 <a href=\"https://github.com/nevercaution/elasticsearch-cli\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">elasticsearch-cli</a> 를 만들어 보는 중이다. 물론 elastic 진영에서는 <a href=\"https://www.elastic.co/guide/en/elasticsearch/client/curator/current/about-cli.html\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">curator</a> 을 제공해주고 있긴 하지만 모니터링 툴이라 간단한 match query 나 analyze 등을 사용할 수는 없다. 나름 일하면서 편하게 사용하는중이다. ㅎㅎ</p>\n"},{"title":"spring boot 에서 Retrofit 사용해보기","catalog":true,"date":"2018-12-29T07:53:09.000Z","subtitle":null,"header-img":"/img/header_img/bg.png","_content":"\n### Retrofit 을 사용기 전에\nREST 호출을 해야할 때 보통 spring 에서 기본적으로 제공해주는 [RestTemplate](https://docs.spring.io/spring/docs/current/javadoc-api/org/springframework/web/client/RestTemplate.html) 을 사용했었다. 간단하게 사용할 수 있고 `spring-boot-starter-web` 내부에 포함되어 있어 다른 의존성이 없어도 된다. 제공되는 method 도 많은데, 워낙 사용이 자유로워서 프로젝트에서 여러 사람의 손을 타다보면 사용하는 방식이 제각각이다. 여기저기서 가이드 없이 사용하다 보니 어떤 api 를 호출하는지 정리가 잘 안되서 리팩토링을 하거나 api 정의가 바뀔 경우 불필요하게 손이 가게 된다. 그리고 호출객체와 응답 객체를 일일이 변환해서 써야 하기 때문에 요청 작업 외적으로 구현해 줘야 하는 부분이 있다.  \n\n## Retrofit\n요청은 sync 와 async 로 할 수 있다. 간단한 api 를 만들어서 양쪽 모두 호출을 하게 만들어 보자.  \n\n### 프로젝트 설정  \n `build.gradle`  \n \n ```gradle\ncompile('com.squareup.retrofit2:retrofit:2.3.0')\ncompile('com.squareup.retrofit2:converter-gson:2.3.0')\ncompile('com.squareup.okhttp3:logging-interceptor:3.9.0')\n ```\n gradle 에 retrofit 을 추가해준다.  \n \n### model\n\n```java\n@Data\n@AllArgsConstructor\npublic class Person {\n    private String name;\n    private Integer age;\n}\n```\n\n### interface\n\n```java\npublic interface PersonAPI {\n\n    @GET(\"/persons\")\n    Call<List<Person>> getPersonList();\n\n    @POST(\"/person\")\n    Call<Person> getPerson(@Query(value = \"name\") String name);\n}\n```\n\n사용해보면서 가장 마음에 들었던 부분인데 api 요청들을 한곳에 모아서 볼 수 있게 되어 있다.  \n파라미터들은 path, parameter, form 에 따라 제공되는 annotation 를 붙여주면 된다. 기본적인 사용법은 다음과 같다.     \n- `/person/{name}` 일 경우엔 `@Path` 를 사용한다.  \n- `/person?name={name}` 일 경우엔 `@Query` 를 사용한다.  \n- form 에 담아 요청을 할 경우엔 `@Field` 로 호출한다.  \n\n자세한 내용은 [공식 가이드](https://square.github.io/retrofit/) 에서 설명해준다.  \n\n### retrofit service\nretrofit 는 사용할 api 를 등록하고 사용한다. 사용하기 편하게 util 로 만들어줄 수 있다.   \n\n```java\npublic abstract class RequestUtil {\n    // 1. 호출할  도메인\n    private static final String BASE_URL = \"http://localhost:8080/\";\n    // 2. log interceptor\n    private static final HttpLoggingInterceptor loggingInterceptor = new HttpLoggingInterceptor().setLevel(HttpLoggingInterceptor.Level.BODY);\n    // 3. 사용할 http client\n    private static final OkHttpClient.Builder httpClient = new OkHttpClient.Builder()\n            .addInterceptor(loggingInterceptor);\n    private static final Retrofit retrofit = new Retrofit.Builder()\n            .baseUrl(BASE_URL)\n            .addConverterFactory(GsonConverterFactory.create())\n            .client(httpClient.build())\n            .build();\n\t\n    // 4. 서비스 등록\n    public static <T> T createService(Class<T> sClass) {\n        return retrofit.create(sClass);\n    }\n\t\n    // 5. 서비스 호출\n    public static <T> Optional<T> requestSync(Call<T> call) {\n        try {\n            Response<T> execute = call.execute();\n            System.out.println(\"execute = \" + execute);\n            if (execute.isSuccessful()) {\n                return Optional.ofNullable(execute.body());\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n        return Optional.empty();\n    }\n\n    public static <T> void requestAsync(Call<T> call, CustomCallback<T> callback) {\n        call.enqueue(callback);\n    }\n}\n```\n1. 호출할 도메인이다. 객체가 생성될 때 넣어준다. 만약 호출해야할 서비스가 여러개일 경우엔 추가로 받아서 등록해줄 수 있다.  \n2. 원하는 로그레벨을 걸어 필요한 값들을 모두 확인해볼 수 있다. default 값은 INFO 이다.  \n3. http client 로 okhttp 를 사용했다. 다른 client 를 사용할 수도 있지만 같은 회사에서 만들어서 서로의 궁합이 좋다.  \n4. interface 로 정의한 서비스를 등록하는 부분이다. \n5. 등록된 서비스에서 Call 객체가 나오는데, 이를 호출해준다. sync/async 모두 호출이 가능하다.  \n\n\n비동기 호출시에 기본적으로 `Calback<T>` 를 받아서 처리하는데 사용의 편의를 위해 `CustomCallback` 을 만들어서 사용할 수 있다. 추가적으로 로그를 남길 수 있고 코드가 좀 더 깔끔해진다.  \n\n```java\n\npublic abstract class CustomCallback<T> implements Callback<T> {\n\n    @Override\n    public void onResponse(Call<T> call, Response<T> response) {\n        System.out.println(\"response = \" + response);\n    }\n\n    @Override\n    public void onFailure(Call<T> call, Throwable t) {\n        t.printStackTrace();\n    }\n}\n```\n\n## service\n\n```java \nPersonAPI personAPI = RequestUtil.createService(PersonAPI.class);\n```\n\n위에서 정의해준 interface 를 retrofit 에 등록해주고 호출을 할 수 있다. personAPI 객체에서 정의된 api 를 호출하면 Call 객체가 반환되는데 이를 요청하면 된다.  \n\n#### sync 호출시   \n\n```java\nCall<List<Person>> personList = personAPI.getPersonList();\nRequestUtil.requestSync(personList);\n```\n\n호출하고 반환받을 객체를 Call 로 감싸서 반환된다. \n\n#### async 호출시 \n\n```java\nRequestUtil.requestAsync(personAPI.getPersonList(), new CustomCallback<List<Person>>() {\n    @Override\n    public void onResponse(Call<List<Person>> call, Response<List<Person>> response) {\n        super.onResponse(call, response);\n    }\n\n    @Override\n    public void onFailure(Call<List<Person>> call, Throwable t) {\n        super.onFailure(call, t);\n    }\n});\n```\n비동기 호출시엔 enqueue 로 호출하고 응답받을 callback 을 등록해주면 된다. callback 내부에서는 성공과 실패시 메소드를 제공한다. 각자 응답에 따라 필요한 처리를 해주면 된다. 비동기 호출에 대해 응답을 받아주기 위해 `Mono` 로 감싸서 사용할 수 있다.  \n\n```java\nMono<List<Person>> mono = Mono.create(sink -> {\n    RequestUtil.requestAsync(personAPI.getPersonList(), new CustomCallback<List<Person>>() {\n        @Override\n        public void onResponse(Call<List<Person>> call, Response<List<Person>> response) {\n            if (!response.isSuccessful()) {\n                sink.error(new Exception(\"response is empty\"));\n                return;\n            }\n\n            sink.success(Objects.requireNonNull(response.body()));\n        }\n    });\n});\nreturn mono;\n```\n\n## 결론\n사용하고 있는 api 들을 한곳에 정리할 수 있고 필요한 파라미터 값들이 코드로 작성되기 때문에 api 문서를 확인하지 않아도 편하게 확인할 수 있다. 스타일이 어느정도 강제가 되어 있긴 하지만 보다 명확하게 명세를 정의할 수 있어 마음에 들었다. 조만간 retrofit 으로 모든 요청들을 정리해 볼 생각이다. [예제코드](https://github.com/nevercaution/retrofitDemo) 에서 위의 코드들을 확인해볼 수 있다.  ","source":"_posts/retrofit-with-spring-boot.md","raw":"---\ntitle: spring boot 에서 Retrofit 사용해보기\ncatalog: true\ndate: 2018-12-29 16:53:09\nsubtitle:\nheader-img: \"/img/header_img/bg.png\"\ntags:\n- springboot\n- retrofit2\n- okhttp3\n- async\n---\n\n### Retrofit 을 사용기 전에\nREST 호출을 해야할 때 보통 spring 에서 기본적으로 제공해주는 [RestTemplate](https://docs.spring.io/spring/docs/current/javadoc-api/org/springframework/web/client/RestTemplate.html) 을 사용했었다. 간단하게 사용할 수 있고 `spring-boot-starter-web` 내부에 포함되어 있어 다른 의존성이 없어도 된다. 제공되는 method 도 많은데, 워낙 사용이 자유로워서 프로젝트에서 여러 사람의 손을 타다보면 사용하는 방식이 제각각이다. 여기저기서 가이드 없이 사용하다 보니 어떤 api 를 호출하는지 정리가 잘 안되서 리팩토링을 하거나 api 정의가 바뀔 경우 불필요하게 손이 가게 된다. 그리고 호출객체와 응답 객체를 일일이 변환해서 써야 하기 때문에 요청 작업 외적으로 구현해 줘야 하는 부분이 있다.  \n\n## Retrofit\n요청은 sync 와 async 로 할 수 있다. 간단한 api 를 만들어서 양쪽 모두 호출을 하게 만들어 보자.  \n\n### 프로젝트 설정  \n `build.gradle`  \n \n ```gradle\ncompile('com.squareup.retrofit2:retrofit:2.3.0')\ncompile('com.squareup.retrofit2:converter-gson:2.3.0')\ncompile('com.squareup.okhttp3:logging-interceptor:3.9.0')\n ```\n gradle 에 retrofit 을 추가해준다.  \n \n### model\n\n```java\n@Data\n@AllArgsConstructor\npublic class Person {\n    private String name;\n    private Integer age;\n}\n```\n\n### interface\n\n```java\npublic interface PersonAPI {\n\n    @GET(\"/persons\")\n    Call<List<Person>> getPersonList();\n\n    @POST(\"/person\")\n    Call<Person> getPerson(@Query(value = \"name\") String name);\n}\n```\n\n사용해보면서 가장 마음에 들었던 부분인데 api 요청들을 한곳에 모아서 볼 수 있게 되어 있다.  \n파라미터들은 path, parameter, form 에 따라 제공되는 annotation 를 붙여주면 된다. 기본적인 사용법은 다음과 같다.     \n- `/person/{name}` 일 경우엔 `@Path` 를 사용한다.  \n- `/person?name={name}` 일 경우엔 `@Query` 를 사용한다.  \n- form 에 담아 요청을 할 경우엔 `@Field` 로 호출한다.  \n\n자세한 내용은 [공식 가이드](https://square.github.io/retrofit/) 에서 설명해준다.  \n\n### retrofit service\nretrofit 는 사용할 api 를 등록하고 사용한다. 사용하기 편하게 util 로 만들어줄 수 있다.   \n\n```java\npublic abstract class RequestUtil {\n    // 1. 호출할  도메인\n    private static final String BASE_URL = \"http://localhost:8080/\";\n    // 2. log interceptor\n    private static final HttpLoggingInterceptor loggingInterceptor = new HttpLoggingInterceptor().setLevel(HttpLoggingInterceptor.Level.BODY);\n    // 3. 사용할 http client\n    private static final OkHttpClient.Builder httpClient = new OkHttpClient.Builder()\n            .addInterceptor(loggingInterceptor);\n    private static final Retrofit retrofit = new Retrofit.Builder()\n            .baseUrl(BASE_URL)\n            .addConverterFactory(GsonConverterFactory.create())\n            .client(httpClient.build())\n            .build();\n\t\n    // 4. 서비스 등록\n    public static <T> T createService(Class<T> sClass) {\n        return retrofit.create(sClass);\n    }\n\t\n    // 5. 서비스 호출\n    public static <T> Optional<T> requestSync(Call<T> call) {\n        try {\n            Response<T> execute = call.execute();\n            System.out.println(\"execute = \" + execute);\n            if (execute.isSuccessful()) {\n                return Optional.ofNullable(execute.body());\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n        return Optional.empty();\n    }\n\n    public static <T> void requestAsync(Call<T> call, CustomCallback<T> callback) {\n        call.enqueue(callback);\n    }\n}\n```\n1. 호출할 도메인이다. 객체가 생성될 때 넣어준다. 만약 호출해야할 서비스가 여러개일 경우엔 추가로 받아서 등록해줄 수 있다.  \n2. 원하는 로그레벨을 걸어 필요한 값들을 모두 확인해볼 수 있다. default 값은 INFO 이다.  \n3. http client 로 okhttp 를 사용했다. 다른 client 를 사용할 수도 있지만 같은 회사에서 만들어서 서로의 궁합이 좋다.  \n4. interface 로 정의한 서비스를 등록하는 부분이다. \n5. 등록된 서비스에서 Call 객체가 나오는데, 이를 호출해준다. sync/async 모두 호출이 가능하다.  \n\n\n비동기 호출시에 기본적으로 `Calback<T>` 를 받아서 처리하는데 사용의 편의를 위해 `CustomCallback` 을 만들어서 사용할 수 있다. 추가적으로 로그를 남길 수 있고 코드가 좀 더 깔끔해진다.  \n\n```java\n\npublic abstract class CustomCallback<T> implements Callback<T> {\n\n    @Override\n    public void onResponse(Call<T> call, Response<T> response) {\n        System.out.println(\"response = \" + response);\n    }\n\n    @Override\n    public void onFailure(Call<T> call, Throwable t) {\n        t.printStackTrace();\n    }\n}\n```\n\n## service\n\n```java \nPersonAPI personAPI = RequestUtil.createService(PersonAPI.class);\n```\n\n위에서 정의해준 interface 를 retrofit 에 등록해주고 호출을 할 수 있다. personAPI 객체에서 정의된 api 를 호출하면 Call 객체가 반환되는데 이를 요청하면 된다.  \n\n#### sync 호출시   \n\n```java\nCall<List<Person>> personList = personAPI.getPersonList();\nRequestUtil.requestSync(personList);\n```\n\n호출하고 반환받을 객체를 Call 로 감싸서 반환된다. \n\n#### async 호출시 \n\n```java\nRequestUtil.requestAsync(personAPI.getPersonList(), new CustomCallback<List<Person>>() {\n    @Override\n    public void onResponse(Call<List<Person>> call, Response<List<Person>> response) {\n        super.onResponse(call, response);\n    }\n\n    @Override\n    public void onFailure(Call<List<Person>> call, Throwable t) {\n        super.onFailure(call, t);\n    }\n});\n```\n비동기 호출시엔 enqueue 로 호출하고 응답받을 callback 을 등록해주면 된다. callback 내부에서는 성공과 실패시 메소드를 제공한다. 각자 응답에 따라 필요한 처리를 해주면 된다. 비동기 호출에 대해 응답을 받아주기 위해 `Mono` 로 감싸서 사용할 수 있다.  \n\n```java\nMono<List<Person>> mono = Mono.create(sink -> {\n    RequestUtil.requestAsync(personAPI.getPersonList(), new CustomCallback<List<Person>>() {\n        @Override\n        public void onResponse(Call<List<Person>> call, Response<List<Person>> response) {\n            if (!response.isSuccessful()) {\n                sink.error(new Exception(\"response is empty\"));\n                return;\n            }\n\n            sink.success(Objects.requireNonNull(response.body()));\n        }\n    });\n});\nreturn mono;\n```\n\n## 결론\n사용하고 있는 api 들을 한곳에 정리할 수 있고 필요한 파라미터 값들이 코드로 작성되기 때문에 api 문서를 확인하지 않아도 편하게 확인할 수 있다. 스타일이 어느정도 강제가 되어 있긴 하지만 보다 명확하게 명세를 정의할 수 있어 마음에 들었다. 조만간 retrofit 으로 모든 요청들을 정리해 볼 생각이다. [예제코드](https://github.com/nevercaution/retrofitDemo) 에서 위의 코드들을 확인해볼 수 있다.  ","slug":"retrofit-with-spring-boot","published":1,"updated":"2018-12-29T09:19:38.509Z","_id":"cjq98sopr000b8ghhhl71adgs","comments":1,"layout":"post","photos":[],"link":"","content":"<h3><span id=\"retrofit-을-사용기-전에\">Retrofit 을 사용기 전에</span></h3>\n<p>REST 호출을 해야할 때 보통 spring 에서 기본적으로 제공해주는 <a href=\"https://docs.spring.io/spring/docs/current/javadoc-api/org/springframework/web/client/RestTemplate.html\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">RestTemplate</a> 을 사용했었다. 간단하게 사용할 수 있고 <code>spring-boot-starter-web</code> 내부에 포함되어 있어 다른 의존성이 없어도 된다. 제공되는 method 도 많은데, 워낙 사용이 자유로워서 프로젝트에서 여러 사람의 손을 타다보면 사용하는 방식이 제각각이다. 여기저기서 가이드 없이 사용하다 보니 어떤 api 를 호출하는지 정리가 잘 안되서 리팩토링을 하거나 api 정의가 바뀔 경우 불필요하게 손이 가게 된다. 그리고 호출객체와 응답 객체를 일일이 변환해서 써야 하기 때문에 요청 작업 외적으로 구현해 줘야 하는 부분이 있다.</p>\n<h2><span id=\"retrofit\">Retrofit</span></h2>\n<p>요청은 sync 와 async 로 할 수 있다. 간단한 api 를 만들어서 양쪽 모두 호출을 하게 만들어 보자.</p>\n<h3><span id=\"프로젝트-설정\">프로젝트 설정</span></h3>\n<p><code>build.gradle</code></p>\n <figure class=\"highlight gradle\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">compile</span>(<span class=\"string\">'com.squareup.retrofit2:retrofit:2.3.0'</span>)</span><br><span class=\"line\"><span class=\"keyword\">compile</span>(<span class=\"string\">'com.squareup.retrofit2:converter-gson:2.3.0'</span>)</span><br><span class=\"line\"><span class=\"keyword\">compile</span>(<span class=\"string\">'com.squareup.okhttp3:logging-interceptor:3.9.0'</span>)</span><br></pre></td></tr></table></figure>\n<p>gradle 에 retrofit 을 추가해준다.</p>\n<h3><span id=\"model\">model</span></h3>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Data</span></span><br><span class=\"line\"><span class=\"meta\">@AllArgsConstructor</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Person</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> String name;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> Integer age;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3><span id=\"interface\">interface</span></h3>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">PersonAPI</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@GET</span>(<span class=\"string\">\"/persons\"</span>)</span><br><span class=\"line\">    Call&lt;List&lt;Person&gt;&gt; getPersonList();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@POST</span>(<span class=\"string\">\"/person\"</span>)</span><br><span class=\"line\">    <span class=\"function\">Call&lt;Person&gt; <span class=\"title\">getPerson</span><span class=\"params\">(@Query(value = <span class=\"string\">\"name\"</span>)</span> String name)</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>사용해보면서 가장 마음에 들었던 부분인데 api 요청들을 한곳에 모아서 볼 수 있게 되어 있다.<br>\n파라미터들은 path, parameter, form 에 따라 제공되는 annotation 를 붙여주면 된다. 기본적인 사용법은 다음과 같다.</p>\n<ul>\n<li><code>/person/{name}</code> 일 경우엔 <code>@Path</code> 를 사용한다.</li>\n<li><code>/person?name={name}</code> 일 경우엔 <code>@Query</code> 를 사용한다.</li>\n<li>form 에 담아 요청을 할 경우엔 <code>@Field</code> 로 호출한다.</li>\n</ul>\n<p>자세한 내용은 <a href=\"https://square.github.io/retrofit/\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">공식 가이드</a> 에서 설명해준다.</p>\n<h3><span id=\"retrofit-service\">retrofit service</span></h3>\n<p>retrofit 는 사용할 api 를 등록하고 사용한다. 사용하기 편하게 util 로 만들어줄 수 있다.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">RequestUtil</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 1. 호출할  도메인</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> String BASE_URL = <span class=\"string\">\"http://localhost:8080/\"</span>;</span><br><span class=\"line\">    <span class=\"comment\">// 2. log interceptor</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> HttpLoggingInterceptor loggingInterceptor = <span class=\"keyword\">new</span> HttpLoggingInterceptor().setLevel(HttpLoggingInterceptor.Level.BODY);</span><br><span class=\"line\">    <span class=\"comment\">// 3. 사용할 http client</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> OkHttpClient.Builder httpClient = <span class=\"keyword\">new</span> OkHttpClient.Builder()</span><br><span class=\"line\">            .addInterceptor(loggingInterceptor);</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> Retrofit retrofit = <span class=\"keyword\">new</span> Retrofit.Builder()</span><br><span class=\"line\">            .baseUrl(BASE_URL)</span><br><span class=\"line\">            .addConverterFactory(GsonConverterFactory.create())</span><br><span class=\"line\">            .client(httpClient.build())</span><br><span class=\"line\">            .build();</span><br><span class=\"line\">\t</span><br><span class=\"line\">    <span class=\"comment\">// 4. 서비스 등록</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> &lt;T&gt; <span class=\"function\">T <span class=\"title\">createService</span><span class=\"params\">(Class&lt;T&gt; sClass)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> retrofit.create(sClass);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">\t</span><br><span class=\"line\">    <span class=\"comment\">// 5. 서비스 호출</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> &lt;T&gt; <span class=\"function\">Optional&lt;T&gt; <span class=\"title\">requestSync</span><span class=\"params\">(Call&lt;T&gt; call)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            Response&lt;T&gt; execute = call.execute();</span><br><span class=\"line\">            System.out.println(<span class=\"string\">\"execute = \"</span> + execute);</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (execute.isSuccessful()) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> Optional.ofNullable(execute.body());</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (IOException e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> Optional.empty();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> &lt;T&gt; <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">requestAsync</span><span class=\"params\">(Call&lt;T&gt; call, CustomCallback&lt;T&gt; callback)</span> </span>&#123;</span><br><span class=\"line\">        call.enqueue(callback);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ol>\n<li>호출할 도메인이다. 객체가 생성될 때 넣어준다. 만약 호출해야할 서비스가 여러개일 경우엔 추가로 받아서 등록해줄 수 있다.</li>\n<li>원하는 로그레벨을 걸어 필요한 값들을 모두 확인해볼 수 있다. default 값은 INFO 이다.</li>\n<li>http client 로 okhttp 를 사용했다. 다른 client 를 사용할 수도 있지만 같은 회사에서 만들어서 서로의 궁합이 좋다.</li>\n<li>interface 로 정의한 서비스를 등록하는 부분이다.</li>\n<li>등록된 서비스에서 Call 객체가 나오는데, 이를 호출해준다. sync/async 모두 호출이 가능하다.</li>\n</ol>\n<p>비동기 호출시에 기본적으로 <code>Calback&lt;T&gt;</code> 를 받아서 처리하는데 사용의 편의를 위해 <code>CustomCallback</code> 을 만들어서 사용할 수 있다. 추가적으로 로그를 남길 수 있고 코드가 좀 더 깔끔해진다.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">CustomCallback</span>&lt;<span class=\"title\">T</span>&gt; <span class=\"keyword\">implements</span> <span class=\"title\">Callback</span>&lt;<span class=\"title\">T</span>&gt; </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onResponse</span><span class=\"params\">(Call&lt;T&gt; call, Response&lt;T&gt; response)</span> </span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"response = \"</span> + response);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onFailure</span><span class=\"params\">(Call&lt;T&gt; call, Throwable t)</span> </span>&#123;</span><br><span class=\"line\">        t.printStackTrace();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2><span id=\"service\">service</span></h2>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">PersonAPI personAPI = RequestUtil.createService(PersonAPI.class);</span><br></pre></td></tr></table></figure>\n<p>위에서 정의해준 interface 를 retrofit 에 등록해주고 호출을 할 수 있다. personAPI 객체에서 정의된 api 를 호출하면 Call 객체가 반환되는데 이를 요청하면 된다.</p>\n<h4><span id=\"sync-호출시\">sync 호출시</span></h4>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Call&lt;List&lt;Person&gt;&gt; personList = personAPI.getPersonList();</span><br><span class=\"line\">RequestUtil.requestSync(personList);</span><br></pre></td></tr></table></figure>\n<p>호출하고 반환받을 객체를 Call 로 감싸서 반환된다.</p>\n<h4><span id=\"async-호출시\">async 호출시</span></h4>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">RequestUtil.requestAsync(personAPI.getPersonList(), <span class=\"keyword\">new</span> CustomCallback&lt;List&lt;Person&gt;&gt;() &#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onResponse</span><span class=\"params\">(Call&lt;List&lt;Person&gt;&gt; call, Response&lt;List&lt;Person&gt;&gt; response)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>.onResponse(call, response);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onFailure</span><span class=\"params\">(Call&lt;List&lt;Person&gt;&gt; call, Throwable t)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>.onFailure(call, t);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>비동기 호출시엔 enqueue 로 호출하고 응답받을 callback 을 등록해주면 된다. callback 내부에서는 성공과 실패시 메소드를 제공한다. 각자 응답에 따라 필요한 처리를 해주면 된다. 비동기 호출에 대해 응답을 받아주기 위해 <code>Mono</code> 로 감싸서 사용할 수 있다.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Mono&lt;List&lt;Person&gt;&gt; mono = Mono.create(sink -&gt; &#123;</span><br><span class=\"line\">    RequestUtil.requestAsync(personAPI.getPersonList(), <span class=\"keyword\">new</span> CustomCallback&lt;List&lt;Person&gt;&gt;() &#123;</span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onResponse</span><span class=\"params\">(Call&lt;List&lt;Person&gt;&gt; call, Response&lt;List&lt;Person&gt;&gt; response)</span> </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (!response.isSuccessful()) &#123;</span><br><span class=\"line\">                sink.error(<span class=\"keyword\">new</span> Exception(<span class=\"string\">\"response is empty\"</span>));</span><br><span class=\"line\">                <span class=\"keyword\">return</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            sink.success(Objects.requireNonNull(response.body()));</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"><span class=\"keyword\">return</span> mono;</span><br></pre></td></tr></table></figure>\n<h2><span id=\"결론\">결론</span></h2>\n<p>사용하고 있는 api 들을 한곳에 정리할 수 있고 필요한 파라미터 값들이 코드로 작성되기 때문에 api 문서를 확인하지 않아도 편하게 확인할 수 있다. 스타일이 어느정도 강제가 되어 있긴 하지만 보다 명확하게 명세를 정의할 수 있어 마음에 들었다. 조만간 retrofit 으로 모든 요청들을 정리해 볼 생각이다. <a href=\"https://github.com/nevercaution/retrofitDemo\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">예제코드</a> 에서 위의 코드들을 확인해볼 수 있다.</p>\n","site":{"data":{}},"excerpt":"","more":"<h3>Retrofit 을 사용기 전에</h3>\n<p>REST 호출을 해야할 때 보통 spring 에서 기본적으로 제공해주는 <a href=\"https://docs.spring.io/spring/docs/current/javadoc-api/org/springframework/web/client/RestTemplate.html\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">RestTemplate</a> 을 사용했었다. 간단하게 사용할 수 있고 <code>spring-boot-starter-web</code> 내부에 포함되어 있어 다른 의존성이 없어도 된다. 제공되는 method 도 많은데, 워낙 사용이 자유로워서 프로젝트에서 여러 사람의 손을 타다보면 사용하는 방식이 제각각이다. 여기저기서 가이드 없이 사용하다 보니 어떤 api 를 호출하는지 정리가 잘 안되서 리팩토링을 하거나 api 정의가 바뀔 경우 불필요하게 손이 가게 된다. 그리고 호출객체와 응답 객체를 일일이 변환해서 써야 하기 때문에 요청 작업 외적으로 구현해 줘야 하는 부분이 있다.</p>\n<h2>Retrofit</h2>\n<p>요청은 sync 와 async 로 할 수 있다. 간단한 api 를 만들어서 양쪽 모두 호출을 하게 만들어 보자.</p>\n<h3>프로젝트 설정</h3>\n<p><code>build.gradle</code></p>\n <figure class=\"highlight gradle\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">compile</span>(<span class=\"string\">'com.squareup.retrofit2:retrofit:2.3.0'</span>)</span><br><span class=\"line\"><span class=\"keyword\">compile</span>(<span class=\"string\">'com.squareup.retrofit2:converter-gson:2.3.0'</span>)</span><br><span class=\"line\"><span class=\"keyword\">compile</span>(<span class=\"string\">'com.squareup.okhttp3:logging-interceptor:3.9.0'</span>)</span><br></pre></td></tr></table></figure>\n<p>gradle 에 retrofit 을 추가해준다.</p>\n<h3>model</h3>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Data</span></span><br><span class=\"line\"><span class=\"meta\">@AllArgsConstructor</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Person</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> String name;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> Integer age;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3>interface</h3>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">PersonAPI</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@GET</span>(<span class=\"string\">\"/persons\"</span>)</span><br><span class=\"line\">    Call&lt;List&lt;Person&gt;&gt; getPersonList();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@POST</span>(<span class=\"string\">\"/person\"</span>)</span><br><span class=\"line\">    <span class=\"function\">Call&lt;Person&gt; <span class=\"title\">getPerson</span><span class=\"params\">(@Query(value = <span class=\"string\">\"name\"</span>)</span> String name)</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>사용해보면서 가장 마음에 들었던 부분인데 api 요청들을 한곳에 모아서 볼 수 있게 되어 있다.<br>\n파라미터들은 path, parameter, form 에 따라 제공되는 annotation 를 붙여주면 된다. 기본적인 사용법은 다음과 같다.</p>\n<ul>\n<li><code>/person/{name}</code> 일 경우엔 <code>@Path</code> 를 사용한다.</li>\n<li><code>/person?name={name}</code> 일 경우엔 <code>@Query</code> 를 사용한다.</li>\n<li>form 에 담아 요청을 할 경우엔 <code>@Field</code> 로 호출한다.</li>\n</ul>\n<p>자세한 내용은 <a href=\"https://square.github.io/retrofit/\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">공식 가이드</a> 에서 설명해준다.</p>\n<h3>retrofit service</h3>\n<p>retrofit 는 사용할 api 를 등록하고 사용한다. 사용하기 편하게 util 로 만들어줄 수 있다.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">RequestUtil</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 1. 호출할  도메인</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> String BASE_URL = <span class=\"string\">\"http://localhost:8080/\"</span>;</span><br><span class=\"line\">    <span class=\"comment\">// 2. log interceptor</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> HttpLoggingInterceptor loggingInterceptor = <span class=\"keyword\">new</span> HttpLoggingInterceptor().setLevel(HttpLoggingInterceptor.Level.BODY);</span><br><span class=\"line\">    <span class=\"comment\">// 3. 사용할 http client</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> OkHttpClient.Builder httpClient = <span class=\"keyword\">new</span> OkHttpClient.Builder()</span><br><span class=\"line\">            .addInterceptor(loggingInterceptor);</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> Retrofit retrofit = <span class=\"keyword\">new</span> Retrofit.Builder()</span><br><span class=\"line\">            .baseUrl(BASE_URL)</span><br><span class=\"line\">            .addConverterFactory(GsonConverterFactory.create())</span><br><span class=\"line\">            .client(httpClient.build())</span><br><span class=\"line\">            .build();</span><br><span class=\"line\">\t</span><br><span class=\"line\">    <span class=\"comment\">// 4. 서비스 등록</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> &lt;T&gt; <span class=\"function\">T <span class=\"title\">createService</span><span class=\"params\">(Class&lt;T&gt; sClass)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> retrofit.create(sClass);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">\t</span><br><span class=\"line\">    <span class=\"comment\">// 5. 서비스 호출</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> &lt;T&gt; <span class=\"function\">Optional&lt;T&gt; <span class=\"title\">requestSync</span><span class=\"params\">(Call&lt;T&gt; call)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            Response&lt;T&gt; execute = call.execute();</span><br><span class=\"line\">            System.out.println(<span class=\"string\">\"execute = \"</span> + execute);</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (execute.isSuccessful()) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> Optional.ofNullable(execute.body());</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (IOException e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> Optional.empty();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> &lt;T&gt; <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">requestAsync</span><span class=\"params\">(Call&lt;T&gt; call, CustomCallback&lt;T&gt; callback)</span> </span>&#123;</span><br><span class=\"line\">        call.enqueue(callback);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ol>\n<li>호출할 도메인이다. 객체가 생성될 때 넣어준다. 만약 호출해야할 서비스가 여러개일 경우엔 추가로 받아서 등록해줄 수 있다.</li>\n<li>원하는 로그레벨을 걸어 필요한 값들을 모두 확인해볼 수 있다. default 값은 INFO 이다.</li>\n<li>http client 로 okhttp 를 사용했다. 다른 client 를 사용할 수도 있지만 같은 회사에서 만들어서 서로의 궁합이 좋다.</li>\n<li>interface 로 정의한 서비스를 등록하는 부분이다.</li>\n<li>등록된 서비스에서 Call 객체가 나오는데, 이를 호출해준다. sync/async 모두 호출이 가능하다.</li>\n</ol>\n<p>비동기 호출시에 기본적으로 <code>Calback&lt;T&gt;</code> 를 받아서 처리하는데 사용의 편의를 위해 <code>CustomCallback</code> 을 만들어서 사용할 수 있다. 추가적으로 로그를 남길 수 있고 코드가 좀 더 깔끔해진다.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">CustomCallback</span>&lt;<span class=\"title\">T</span>&gt; <span class=\"keyword\">implements</span> <span class=\"title\">Callback</span>&lt;<span class=\"title\">T</span>&gt; </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onResponse</span><span class=\"params\">(Call&lt;T&gt; call, Response&lt;T&gt; response)</span> </span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"response = \"</span> + response);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onFailure</span><span class=\"params\">(Call&lt;T&gt; call, Throwable t)</span> </span>&#123;</span><br><span class=\"line\">        t.printStackTrace();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2>service</h2>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">PersonAPI personAPI = RequestUtil.createService(PersonAPI.class);</span><br></pre></td></tr></table></figure>\n<p>위에서 정의해준 interface 를 retrofit 에 등록해주고 호출을 할 수 있다. personAPI 객체에서 정의된 api 를 호출하면 Call 객체가 반환되는데 이를 요청하면 된다.</p>\n<h4>sync 호출시</h4>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Call&lt;List&lt;Person&gt;&gt; personList = personAPI.getPersonList();</span><br><span class=\"line\">RequestUtil.requestSync(personList);</span><br></pre></td></tr></table></figure>\n<p>호출하고 반환받을 객체를 Call 로 감싸서 반환된다.</p>\n<h4>async 호출시</h4>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">RequestUtil.requestAsync(personAPI.getPersonList(), <span class=\"keyword\">new</span> CustomCallback&lt;List&lt;Person&gt;&gt;() &#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onResponse</span><span class=\"params\">(Call&lt;List&lt;Person&gt;&gt; call, Response&lt;List&lt;Person&gt;&gt; response)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>.onResponse(call, response);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onFailure</span><span class=\"params\">(Call&lt;List&lt;Person&gt;&gt; call, Throwable t)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>.onFailure(call, t);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>비동기 호출시엔 enqueue 로 호출하고 응답받을 callback 을 등록해주면 된다. callback 내부에서는 성공과 실패시 메소드를 제공한다. 각자 응답에 따라 필요한 처리를 해주면 된다. 비동기 호출에 대해 응답을 받아주기 위해 <code>Mono</code> 로 감싸서 사용할 수 있다.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Mono&lt;List&lt;Person&gt;&gt; mono = Mono.create(sink -&gt; &#123;</span><br><span class=\"line\">    RequestUtil.requestAsync(personAPI.getPersonList(), <span class=\"keyword\">new</span> CustomCallback&lt;List&lt;Person&gt;&gt;() &#123;</span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onResponse</span><span class=\"params\">(Call&lt;List&lt;Person&gt;&gt; call, Response&lt;List&lt;Person&gt;&gt; response)</span> </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (!response.isSuccessful()) &#123;</span><br><span class=\"line\">                sink.error(<span class=\"keyword\">new</span> Exception(<span class=\"string\">\"response is empty\"</span>));</span><br><span class=\"line\">                <span class=\"keyword\">return</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            sink.success(Objects.requireNonNull(response.body()));</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"><span class=\"keyword\">return</span> mono;</span><br></pre></td></tr></table></figure>\n<h2>결론</h2>\n<p>사용하고 있는 api 들을 한곳에 정리할 수 있고 필요한 파라미터 값들이 코드로 작성되기 때문에 api 문서를 확인하지 않아도 편하게 확인할 수 있다. 스타일이 어느정도 강제가 되어 있긴 하지만 보다 명확하게 명세를 정의할 수 있어 마음에 들었다. 조만간 retrofit 으로 모든 요청들을 정리해 볼 생각이다. <a href=\"https://github.com/nevercaution/retrofitDemo\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">예제코드</a> 에서 위의 코드들을 확인해볼 수 있다.</p>\n"},{"title":"카카오페이지 검색 개발 후기","catalog":true,"date":"2018-04-29T06:27:25.000Z","subtitle":null,"header-img":"/img/header_img/bg.png","_content":"\n### elasticsearch 의 검색을 사용하기 까지\n사내에서 elasticsearch 를 처음 사용하면서 로그 수집정도에만 사용하고 있었다. 워낙에 [elk](https://www.elastic.co/kr/elk-stack) 가 서로 잘 작동하기도 했고 데이터 수집부터 분석까지 너무나도 유려한 기능들을 갖추고 있었다. 서비스에서의 검색을 처음 도입해본 경험은 사내 정산 시스템을 만들면서 였는데, 작품이름 검색이나 작가등의 이름으로 검색을 하게 해달라는 요청이 있어서 였다.  \n데이터가 db 에 있어 단순하게 like 검색으로 구현할까 했었는데, 생각보다 결과에 대한 품질이 너무 낮았다. 결과에 대한 점수 부여 방법도 딱히 없고 애초에 조건이 하나만 걸리니 내가 원하는 결과를 얻을 수 없었다.  \n그래서 안되겠다 싶어 elasticsearch 와 은전한닢을 이용해 구현했고,  거기서 자신감이 생겨 서비스의 검색도 과감하게 elasticsearch 로 구현하자고 주장했다. 처음에 회사에서는 반기는 분위기는 아니였다.  \n기존에 (나름 잘) 동작하는 검색이 구현되어 있었고 한번도 도전해보지 않은 검색이라는 서비스를 잘 구현할 수 있을까에 대한 걱정이 있었다. 그리고 이미 카카오에서 제공하는 검색엔진이 있고 이를 이용하면 우리쪽에서 굳이 만들 이유가 없어서 였다. 카카오에서 제공하는 기능들을 이용하기만 해도 되었지만 앞으로 우리가 우리만의 기술을 갖게 된다면 그 자체로 의미가 있다 생각했고, 결과로 보여드려야겠다고 생각해서 나는 카카오페이지의 검색을 만들어 보기로 했다.  \n\n### 기존 구성\n나는 일단 기존의 검색이 어떻게 동작하고 있는지 부터 분석을 해보기로 했다. 지정된 시간마다 단어들을 수집해서 잘게 쪼갠 뒤 테이블에 데이터를 저장해놓고, 실제 서비스에서는 나름의 공식을 이용해 점수를 부여해서 검색 결과를 내어주는 방식이었다. mysql 의 fts 를 이용한 방식이었는데 나름 속도도 괜찮고 완벽하진 않았지만 검색의 결과도 그리 나쁘지는 않았다.  \n처음에는 이 검색 서비스부터 이겨보자는 생각으로 다른 검색 서비스들이 검색을 어떻게 서비스 하고 있는지 부터 관찰했다. 개발 초기에는 [리디북스](https://ridibooks.com/)나 [레진코믹스](https://www.lezhin.com/ko) 같은 사이트들의 검색을 많이 참고했다. \n\n### 은전한닢\n한글 형태소 분석기는 크게 3가지가 있다. [elasticsearch 에서 제공하는 형태소분석기 분석](https://www.elastic.co/kr/blog/using-korean-analyzers)에서 보면 arirang, 은전한닢 그리고 open-korean-text(구 twitter-korean-text) 등이 있는데 각 장단점들이 명확해서 아직까지는 형태소 분석기의 절대적인 강자는 없는듯 하다.  \n각자 자신에게 맞는 형태소 분석기를 사용하면 되는듯 한데, [리디북스에서 은전한닢을 사용하다는 기술 블로그](https://www.ridicorp.com/blog/2016/04/18/ridibooks-stack/)를 보고 생각의 결과가 많이 굳기도 했지만 음절 분석결과가 가장 자세하고 속도도 괜찮은 은전한닢을 사용하기로 했다.  \n\n### 클러스터 구성\n2대의 노드로 클러스터를 구성해서 검색 색인을 하고 있고, 주기적으로 추가/변경되는 정보들을 인덱스에 반영하고 있다. 추가적으로 실제 서버 데이터와 개발에서의 구성도 elasticsearch 로 구성했는데, 테스트 서버군은 하나의 노드로 구성했고 각 테스트군별로 색인을 따로 구성했다. \n\n### 데이터 수집및 정제\n검색 쿼리만큼이나 중요한 부분이 데이터 수집이다. 어찌보면 색인이 얼마나 잘 되어 있느냐에 따라 검색 결과의 품질이 좌우된다. 색인과 검색의 비율을 따져 생각해본다면 6:4 정도라고 생각한다. 아무리 많은 데이터를 사용한다 하더라도 데이터가 잘 저장되어 있지 않으면 아무런 소용이 없기 때문이다.  \n일단 데이터를 주기적으로 수집하기로 했고, 카카오 검색팀의 조언을 받아 단어에 대한 점수에 대한 결과도 함께 수집을 한다. logstash 로 처음에는 데이터를 수집하려고 했는데 점수부여에 대한 로직이나 데이터 정제의 편의성을 위해 배치작업을 데이터를 수집했다. 간략하게 수집되는 정보들을 보면 다음과 같다.  \n\n* 열람수, 구매자수, 인기도, 기다리면 무료의 대한 점수 계산  \n* 랭킹데이터 수집  \n* (정산 시스템 구축의 경험으로) 계약 주체에 따른 점수 부여  \n* 운영자가 등록한 태그 수집 \n* 작품명, 작가명, 발행자명, 출연진등의 정보 수집  \n\n가능한 모든 정보를 수집하고자 했고, 은전한닢으로 기분석된 단어와 순수한 단어를 따로 인덱싱을 했다. 이유는 나중에 검색부분에도 언급하겠지만 한글 형태소 분석기로 분석된 단어와 그렇지 않은 단어를 함께 검색 쿼리에 넣어 검색의 결과를 높이기 위함이다. 형태소 분석기를 통해 토크나이징을 하게 되면 자체적으로 단어를 쪼개게 되는데, 이 때 원치 않게 단어가 나뉠수도 있기 때문이다.  \n예를 들어 `김비서` 이라는 단어를 형태소 분석기에 넣고 돌리면 엉뚱한 결과가 나온다.  \n\n```\n김비서\n김비\tNNP,인명,F,김비,*,*,*,*\n서\tJKB,*,F,서,*,*,*,*\nEOS\n```\n일반적으로 생각했을 때 `김`, `비서` 로 나올거라 예상했지만 결과는 이와는 달리 `김비`, `서` 로 나뉘게 되버린다. 원인은 제공되는 정보가 부족해서인데, 모든 문장을 써주면 정상적으로 표시 된다.  \n\n```\n김비서가왜그럴까\n김\tNNP,인명,T,김,*,*,*,*\n비서\tNNG,*,F,비서,*,*,*,*\n가\tJKS,*,F,가,*,*,*,*\n왜\tMAG,문장부사/양상부사,F,왜,*,*,*,*\n그럴까\tVA+EC,*,F,그럴까,Inflect,VA,EC,그렇/VA/*+ᆯ까/EC/*\n```\n\n이런식의 토크나이징은 검색에서도 문제가 된다. elastisearch 에서 검색을 태우면 색인되어 있는 타입에 따라 기분석해서 나온 토큰들로 검색을 하게 되는데 사용자가 `김비서` 라고 검색을 하게 되면 `서` 라는 토큰이 나오게 되기 때문에 엉뚱한 검색 결과가 나오게 된다.  \n추가적으로 난감했던 단어는 `하라간` 과 같이 사전에 등록되지 않은 고유명사들의 경우였다. 은전한닢은 세종 말뭉치를 사용하고 있는데, 비교적 최근에 추가되는 신조어들이나 작품에서 의도적으로 사용되는 고유명사들에 대한 데이터는 존재 하지 않는다. `하라간` 의 경우엔 형태소 분석기에서는 아예 알아들을 수 없는 단어가 되어버린다.  \n\n```\n하라간\n하\tVV,*,F,하,*,*,*,*\n라\tEC,*,F,라,*,*,*,*\n간\tNNG,*,T,간,*,*,*,*\nEOS\n```\n(...여기서 멘붕이 왔었다.)  \n임시방편으로 사용했던 방법은 mecab 에서 제공하는 사용자 사전이었는데, 인명이나 지명등의 단어를 넣으면 형태소 분석기에서 의도적으로 단어를 쪼개지 않고 단어 그자체로서 인식을 가능하게 한다.  \n하지만 4만개가 넘는 모든 작품들을 모니터링하고 일일히 결과를 들여다보면서 사용자 사전에 필요한 단어들을 넣는건 나 혼자 작업으로는 불가능했었고, 처음에는 사용자 cs 나 내부적으로 결과가 이상한 단어들에 대해서만 사전에 등록했었다. (사용자 사전은 나중에 좀 더 자세하게 이야기 해보자.)  \n\n### 데이터 색인\n데이터는 항상 추가된다. 하지만 판매중이었다가 여러 이유로 판매가 중지되는 작품도 있고 운영자에 의해 작품의 정보가 변경되는 일도 꽤나 잦았다. 이미 존재하는 필드에 값을 갱신하려고 했더니 경우의 수가 너무 많았다. 모든 상황에 대해 신시간으로 대응하기 위해서 [다른 곳에서 아이디어](https://www.elastic.co/kr/blog/changing-mapping-with-zero-downtime)를 얻었는데 elasticsearch 에서 제공하는 [alias](https://www.elastic.co/guide/en/elasticsearch/reference/6.2/indices-aliases.html) 와 일반적인 [blue-green deploy](http://en.dwhwiki.info/concepts/blue-green-development) 방법을 이용해서 모든 데이터를 주기적으로 새로 갱신하는 방법을 이용했다. `index-blue`, `index-green` 를 하나씩 생성하고 `index` 라는 `alias` 를 걸어 실제 검색 쿼리는 `index alias` 를 바라보게 했다. 데이터 수집 배치는 독립적으로 동작하고 있기에 실시간으로 필드를 추가하는 장점도 함께 가져갈 수 있다.\n\n### 검색 쿼리\n초기의 버전에서는 사용자 사전을 최대한 사용하지 않는 방향으로 진행했었다. 위에서 언급한 바와 같이 모든 고유명사들을 수동으로 쪼개는 작업이 물리적으로 불가능했었기 때문인데, 이런 제한을 극복하고자 최대한 검색 쿼리를 세부적으로 쪼개서 검색의 결과를 높이고자 했다.  \nmapping 에서 title 에 관련된 정보는 다음과 같이 구성했다.  \n\n```\n\"title\": {\n    \"type\": \"text\",\n    \"analyzer\": \"seunjeon_analyzer\"\n},\n\"titleBigram\": {\n    \"type\": \"text\",\n    \"analyzer\": \"han_bigrams\"\n}\n\"titleStandard\": {\n    \"type\": \"text\",\n    \"analyzer\": \"exact\"\n}\n```\n* [은전한닢](http://eunjeon.blogspot.kr/)\n* [bigram](https://www.elastic.co/guide/en/elasticsearch/reference/current/analysis-cjk-bigram-tokenfilter.html)  \n* 띄어쓰기등을 제거한 [standard analyzer](https://www.elastic.co/guide/en/elasticsearch/reference/current/analysis-standard-analyzer.html)  \n\n검색 쿼리를 수행시 3개의 필드에 대해 각기 다른 boost 를 줘서 가장 근접한 결과에 대해 점수를 높게 부여해서 결과를 만들었다. bigram 을 사용한 이유는 앞서 언급한 형태소 분석기의 한계를 대체하기 위해 색인되는 단어들을 ngram 으로 조개어 저장해서 엉뚱한 결과가 나오는 것에 대한 대처였다. (나중에 다시 언급하겠지만 결과적으로는 `bigram` 을 사용하지 않게 되었다.)  \n `MatchQuery` 로 검색을 하는데 위에서 언급한 대로 기분석된 색인이 엉뚱하게 저장되는 경우들이 꽤나 빈번했기 때문에 초기 검색결과는 가히 충격적이었다. 왜 이 단어가 검색이 되었지? 하는 결과들이 포함되어 있었기 때문이었다. 이후에 카카오 검색셀의 조언을 받아 쿼리는 대대적으로 튜닝하게 되었다.  \n\n### elasticsearch 버전 관리\n개발 초기에는 elasticsearch 최신 버전이 5.1.1 이었다. 검색 서비스를 라이브에 반영하게 되고 보니 버전은 6.x 까지 올라가버렸다. 요즘 추세인지는 모르겠지만 어째 버전업이 너무나도 빠르게 진행되고 있었다. 이전 포스트에서도 얘기 했었던 [elasticsearch 기술 지원](https://www.elastic.co/support/eol) 때문에라도 elasticsearch 버전을 주기적으로 (꽤나 빈번하게) 올리기도 했다. rolling upgrade 에 대한 내용은 [여기](https://nevercaution.github.io/2018/03/15/elasticsearch-rest-client/)에서 자세하게 다루었다.  \n\n### 쿼리 튜닝\n사용자 사전 없이 `title`, `titleBigram`, `titleStandard` 만들어 검색쿼리를 날리면 정말 검색 결과가 엉뚱하게 나오는 경우가 있다. 위에서도 언급한 토크나이징 때문인데 이는 사용자 사전 없이는 사실상 불가능 하다. 사용자 사전을 추가하고 난 후에는 bigram 은 사용하지 않고 `title`, `titleStandard` 두 필드를 사용해서 `MatchQuery` 를 날린다. `bigram` 도 결국에는 단어를 ngram으로 추출하는 방식인데 근본적인 해결책이 되진 못하기 때문이다.  \n그리고 `FunctionScoreQuery`, `FilterFunction` 를 이용해서 결과에 대한 점수 부여를 추가했다. 점수 부여에 관한 로직은 카카오 검색셀(hao) 의 도움을 받아 구현했는데, 위에서 데이터 수집당시에 점수를 부여할 수 있는 판매량이나 열람수와 같은 정보를 이용해서 내부적인 공식을 적용해서 점수를 부여했다.  \n쿼리 튜닝이라고는 했지만 결과적으로는 인덱싱할 때부터 데이터를 잘 만드는게 큰 도움이 되었다. 잘 만들어진 데이터가 있어야 좋은 검색이 나올 수 있기 때문이다.  \n\n### 사용자 사전 관리\n내가 의도한대로 토크나이징이 되기 위해 결국엔 사용자 사전을 추가하게 되었다. 또한 신조어들의 대한 대응을 하기 위함이었는데, 예를 들어 `레벨업` 이라는 단어가 포함된 작품을을 검색할 때 기존에는 `레벨` 과 `업` 으로 쪼개버린다.  \n\n```\n레벨업\n레벨\tNNG,*,T,레벨,*,*,*,*\n업\tNNG,*,T,업,*,*,*,*\nEOS\n```\n이 경우에는 `업` 이라는 단어가 포함된 작품들도 함께 결과에 포함되기 때문에 전혀 엉뚱한 작품들이 포함되기도 한다. `레벨업` 이라는 단어를 사전에 고유명사로 등록해서 최대한 엉뚱한 결과가 없게끔 했다.  \n그렇다면 전체 작품에 대해 어떻게 원하는 고유명사를 추출할 수 있을까?  \n이 고민에 대한 해결책은 기존의 검색용 수집 데이터를 사용했다. 운영자가 작품을 등록할 때 `태그` 를 함께 등록하는데 이는 기존에 검색에서 사용되었던 검색 태그들이다. `김비서가 왜그럴까` 같은 경우엔 `김비서` 나 `김명미` 등의 태그들을 걸어두어서 기존의 검색에서 사용할 수 있는 데이터를 제공했었다. 이 데이터를 약간 손봐서 사용가능한 단어들에 대해 사용자 사전에 등록해서 완벽하진 않지만 신조어나 고유명사들에 대한 대응을 했다.  \n데이터가 없는 경우에 뉴스기사나 다른 데이터를 학습해서 토크나이징을 할 수 있는 [soynlp](https://github.com/lovit/soynlp) 같은 훌륭한 오픈소스도 참고할까 싶었지만 개발 시간에 대한 한계도 있었고(핑계지만), 검색 결과에 대해 스스로 보장하기 어렵다는 이유로 도입을 하진 않았다. 나중에 여유가 되면 학습을 통한 토크나이져를 추가해볼까도 고민중인 부분이다.   \n추가적으로 구글에서는 [자연어분석](https://cloud.google.com/natural-language/?hl=ko) 서비스를 내놓았다. 어쩌면 가까운 미래에는 한글 형태소 분석기가 없어도 한글 검색이 가능해질지도 모르겠다.  \n\n### 결론\n기술적인 이야기를 거의 하지 않았더니 개발일기 처럼 되어 버렸다. 이제 곧 웹에서도 검색기능이 들어갈 예정이니 앞으로는 검색을 좀 더 편하게 할 수 있을것이다. 아직은 좀 더 가다듬고 완성도를 높히는데 목표를 두어야 할 것이다. 약 1년동안 개발했던 내용을 몇문장으로 압축해서 쓰려고 하니 하고 싶은 말은 많은데 모두 다 담지 못한 부분도 있다. 나중에 더 생각 나는 부분들에 대해서 좀 더 내용을 써봐야 겠다.","source":"_posts/elasticsearch-with-kakaopage.md","raw":"---\ntitle: 카카오페이지 검색 개발 후기  \ncatalog: true\ndate: 2018-04-29 15:27:25\nsubtitle:\nheader-img: \"/img/header_img/bg.png\"\ntags:\n- kakaopage\n- elasticsearch\n- 은전한닢\n---\n\n### elasticsearch 의 검색을 사용하기 까지\n사내에서 elasticsearch 를 처음 사용하면서 로그 수집정도에만 사용하고 있었다. 워낙에 [elk](https://www.elastic.co/kr/elk-stack) 가 서로 잘 작동하기도 했고 데이터 수집부터 분석까지 너무나도 유려한 기능들을 갖추고 있었다. 서비스에서의 검색을 처음 도입해본 경험은 사내 정산 시스템을 만들면서 였는데, 작품이름 검색이나 작가등의 이름으로 검색을 하게 해달라는 요청이 있어서 였다.  \n데이터가 db 에 있어 단순하게 like 검색으로 구현할까 했었는데, 생각보다 결과에 대한 품질이 너무 낮았다. 결과에 대한 점수 부여 방법도 딱히 없고 애초에 조건이 하나만 걸리니 내가 원하는 결과를 얻을 수 없었다.  \n그래서 안되겠다 싶어 elasticsearch 와 은전한닢을 이용해 구현했고,  거기서 자신감이 생겨 서비스의 검색도 과감하게 elasticsearch 로 구현하자고 주장했다. 처음에 회사에서는 반기는 분위기는 아니였다.  \n기존에 (나름 잘) 동작하는 검색이 구현되어 있었고 한번도 도전해보지 않은 검색이라는 서비스를 잘 구현할 수 있을까에 대한 걱정이 있었다. 그리고 이미 카카오에서 제공하는 검색엔진이 있고 이를 이용하면 우리쪽에서 굳이 만들 이유가 없어서 였다. 카카오에서 제공하는 기능들을 이용하기만 해도 되었지만 앞으로 우리가 우리만의 기술을 갖게 된다면 그 자체로 의미가 있다 생각했고, 결과로 보여드려야겠다고 생각해서 나는 카카오페이지의 검색을 만들어 보기로 했다.  \n\n### 기존 구성\n나는 일단 기존의 검색이 어떻게 동작하고 있는지 부터 분석을 해보기로 했다. 지정된 시간마다 단어들을 수집해서 잘게 쪼갠 뒤 테이블에 데이터를 저장해놓고, 실제 서비스에서는 나름의 공식을 이용해 점수를 부여해서 검색 결과를 내어주는 방식이었다. mysql 의 fts 를 이용한 방식이었는데 나름 속도도 괜찮고 완벽하진 않았지만 검색의 결과도 그리 나쁘지는 않았다.  \n처음에는 이 검색 서비스부터 이겨보자는 생각으로 다른 검색 서비스들이 검색을 어떻게 서비스 하고 있는지 부터 관찰했다. 개발 초기에는 [리디북스](https://ridibooks.com/)나 [레진코믹스](https://www.lezhin.com/ko) 같은 사이트들의 검색을 많이 참고했다. \n\n### 은전한닢\n한글 형태소 분석기는 크게 3가지가 있다. [elasticsearch 에서 제공하는 형태소분석기 분석](https://www.elastic.co/kr/blog/using-korean-analyzers)에서 보면 arirang, 은전한닢 그리고 open-korean-text(구 twitter-korean-text) 등이 있는데 각 장단점들이 명확해서 아직까지는 형태소 분석기의 절대적인 강자는 없는듯 하다.  \n각자 자신에게 맞는 형태소 분석기를 사용하면 되는듯 한데, [리디북스에서 은전한닢을 사용하다는 기술 블로그](https://www.ridicorp.com/blog/2016/04/18/ridibooks-stack/)를 보고 생각의 결과가 많이 굳기도 했지만 음절 분석결과가 가장 자세하고 속도도 괜찮은 은전한닢을 사용하기로 했다.  \n\n### 클러스터 구성\n2대의 노드로 클러스터를 구성해서 검색 색인을 하고 있고, 주기적으로 추가/변경되는 정보들을 인덱스에 반영하고 있다. 추가적으로 실제 서버 데이터와 개발에서의 구성도 elasticsearch 로 구성했는데, 테스트 서버군은 하나의 노드로 구성했고 각 테스트군별로 색인을 따로 구성했다. \n\n### 데이터 수집및 정제\n검색 쿼리만큼이나 중요한 부분이 데이터 수집이다. 어찌보면 색인이 얼마나 잘 되어 있느냐에 따라 검색 결과의 품질이 좌우된다. 색인과 검색의 비율을 따져 생각해본다면 6:4 정도라고 생각한다. 아무리 많은 데이터를 사용한다 하더라도 데이터가 잘 저장되어 있지 않으면 아무런 소용이 없기 때문이다.  \n일단 데이터를 주기적으로 수집하기로 했고, 카카오 검색팀의 조언을 받아 단어에 대한 점수에 대한 결과도 함께 수집을 한다. logstash 로 처음에는 데이터를 수집하려고 했는데 점수부여에 대한 로직이나 데이터 정제의 편의성을 위해 배치작업을 데이터를 수집했다. 간략하게 수집되는 정보들을 보면 다음과 같다.  \n\n* 열람수, 구매자수, 인기도, 기다리면 무료의 대한 점수 계산  \n* 랭킹데이터 수집  \n* (정산 시스템 구축의 경험으로) 계약 주체에 따른 점수 부여  \n* 운영자가 등록한 태그 수집 \n* 작품명, 작가명, 발행자명, 출연진등의 정보 수집  \n\n가능한 모든 정보를 수집하고자 했고, 은전한닢으로 기분석된 단어와 순수한 단어를 따로 인덱싱을 했다. 이유는 나중에 검색부분에도 언급하겠지만 한글 형태소 분석기로 분석된 단어와 그렇지 않은 단어를 함께 검색 쿼리에 넣어 검색의 결과를 높이기 위함이다. 형태소 분석기를 통해 토크나이징을 하게 되면 자체적으로 단어를 쪼개게 되는데, 이 때 원치 않게 단어가 나뉠수도 있기 때문이다.  \n예를 들어 `김비서` 이라는 단어를 형태소 분석기에 넣고 돌리면 엉뚱한 결과가 나온다.  \n\n```\n김비서\n김비\tNNP,인명,F,김비,*,*,*,*\n서\tJKB,*,F,서,*,*,*,*\nEOS\n```\n일반적으로 생각했을 때 `김`, `비서` 로 나올거라 예상했지만 결과는 이와는 달리 `김비`, `서` 로 나뉘게 되버린다. 원인은 제공되는 정보가 부족해서인데, 모든 문장을 써주면 정상적으로 표시 된다.  \n\n```\n김비서가왜그럴까\n김\tNNP,인명,T,김,*,*,*,*\n비서\tNNG,*,F,비서,*,*,*,*\n가\tJKS,*,F,가,*,*,*,*\n왜\tMAG,문장부사/양상부사,F,왜,*,*,*,*\n그럴까\tVA+EC,*,F,그럴까,Inflect,VA,EC,그렇/VA/*+ᆯ까/EC/*\n```\n\n이런식의 토크나이징은 검색에서도 문제가 된다. elastisearch 에서 검색을 태우면 색인되어 있는 타입에 따라 기분석해서 나온 토큰들로 검색을 하게 되는데 사용자가 `김비서` 라고 검색을 하게 되면 `서` 라는 토큰이 나오게 되기 때문에 엉뚱한 검색 결과가 나오게 된다.  \n추가적으로 난감했던 단어는 `하라간` 과 같이 사전에 등록되지 않은 고유명사들의 경우였다. 은전한닢은 세종 말뭉치를 사용하고 있는데, 비교적 최근에 추가되는 신조어들이나 작품에서 의도적으로 사용되는 고유명사들에 대한 데이터는 존재 하지 않는다. `하라간` 의 경우엔 형태소 분석기에서는 아예 알아들을 수 없는 단어가 되어버린다.  \n\n```\n하라간\n하\tVV,*,F,하,*,*,*,*\n라\tEC,*,F,라,*,*,*,*\n간\tNNG,*,T,간,*,*,*,*\nEOS\n```\n(...여기서 멘붕이 왔었다.)  \n임시방편으로 사용했던 방법은 mecab 에서 제공하는 사용자 사전이었는데, 인명이나 지명등의 단어를 넣으면 형태소 분석기에서 의도적으로 단어를 쪼개지 않고 단어 그자체로서 인식을 가능하게 한다.  \n하지만 4만개가 넘는 모든 작품들을 모니터링하고 일일히 결과를 들여다보면서 사용자 사전에 필요한 단어들을 넣는건 나 혼자 작업으로는 불가능했었고, 처음에는 사용자 cs 나 내부적으로 결과가 이상한 단어들에 대해서만 사전에 등록했었다. (사용자 사전은 나중에 좀 더 자세하게 이야기 해보자.)  \n\n### 데이터 색인\n데이터는 항상 추가된다. 하지만 판매중이었다가 여러 이유로 판매가 중지되는 작품도 있고 운영자에 의해 작품의 정보가 변경되는 일도 꽤나 잦았다. 이미 존재하는 필드에 값을 갱신하려고 했더니 경우의 수가 너무 많았다. 모든 상황에 대해 신시간으로 대응하기 위해서 [다른 곳에서 아이디어](https://www.elastic.co/kr/blog/changing-mapping-with-zero-downtime)를 얻었는데 elasticsearch 에서 제공하는 [alias](https://www.elastic.co/guide/en/elasticsearch/reference/6.2/indices-aliases.html) 와 일반적인 [blue-green deploy](http://en.dwhwiki.info/concepts/blue-green-development) 방법을 이용해서 모든 데이터를 주기적으로 새로 갱신하는 방법을 이용했다. `index-blue`, `index-green` 를 하나씩 생성하고 `index` 라는 `alias` 를 걸어 실제 검색 쿼리는 `index alias` 를 바라보게 했다. 데이터 수집 배치는 독립적으로 동작하고 있기에 실시간으로 필드를 추가하는 장점도 함께 가져갈 수 있다.\n\n### 검색 쿼리\n초기의 버전에서는 사용자 사전을 최대한 사용하지 않는 방향으로 진행했었다. 위에서 언급한 바와 같이 모든 고유명사들을 수동으로 쪼개는 작업이 물리적으로 불가능했었기 때문인데, 이런 제한을 극복하고자 최대한 검색 쿼리를 세부적으로 쪼개서 검색의 결과를 높이고자 했다.  \nmapping 에서 title 에 관련된 정보는 다음과 같이 구성했다.  \n\n```\n\"title\": {\n    \"type\": \"text\",\n    \"analyzer\": \"seunjeon_analyzer\"\n},\n\"titleBigram\": {\n    \"type\": \"text\",\n    \"analyzer\": \"han_bigrams\"\n}\n\"titleStandard\": {\n    \"type\": \"text\",\n    \"analyzer\": \"exact\"\n}\n```\n* [은전한닢](http://eunjeon.blogspot.kr/)\n* [bigram](https://www.elastic.co/guide/en/elasticsearch/reference/current/analysis-cjk-bigram-tokenfilter.html)  \n* 띄어쓰기등을 제거한 [standard analyzer](https://www.elastic.co/guide/en/elasticsearch/reference/current/analysis-standard-analyzer.html)  \n\n검색 쿼리를 수행시 3개의 필드에 대해 각기 다른 boost 를 줘서 가장 근접한 결과에 대해 점수를 높게 부여해서 결과를 만들었다. bigram 을 사용한 이유는 앞서 언급한 형태소 분석기의 한계를 대체하기 위해 색인되는 단어들을 ngram 으로 조개어 저장해서 엉뚱한 결과가 나오는 것에 대한 대처였다. (나중에 다시 언급하겠지만 결과적으로는 `bigram` 을 사용하지 않게 되었다.)  \n `MatchQuery` 로 검색을 하는데 위에서 언급한 대로 기분석된 색인이 엉뚱하게 저장되는 경우들이 꽤나 빈번했기 때문에 초기 검색결과는 가히 충격적이었다. 왜 이 단어가 검색이 되었지? 하는 결과들이 포함되어 있었기 때문이었다. 이후에 카카오 검색셀의 조언을 받아 쿼리는 대대적으로 튜닝하게 되었다.  \n\n### elasticsearch 버전 관리\n개발 초기에는 elasticsearch 최신 버전이 5.1.1 이었다. 검색 서비스를 라이브에 반영하게 되고 보니 버전은 6.x 까지 올라가버렸다. 요즘 추세인지는 모르겠지만 어째 버전업이 너무나도 빠르게 진행되고 있었다. 이전 포스트에서도 얘기 했었던 [elasticsearch 기술 지원](https://www.elastic.co/support/eol) 때문에라도 elasticsearch 버전을 주기적으로 (꽤나 빈번하게) 올리기도 했다. rolling upgrade 에 대한 내용은 [여기](https://nevercaution.github.io/2018/03/15/elasticsearch-rest-client/)에서 자세하게 다루었다.  \n\n### 쿼리 튜닝\n사용자 사전 없이 `title`, `titleBigram`, `titleStandard` 만들어 검색쿼리를 날리면 정말 검색 결과가 엉뚱하게 나오는 경우가 있다. 위에서도 언급한 토크나이징 때문인데 이는 사용자 사전 없이는 사실상 불가능 하다. 사용자 사전을 추가하고 난 후에는 bigram 은 사용하지 않고 `title`, `titleStandard` 두 필드를 사용해서 `MatchQuery` 를 날린다. `bigram` 도 결국에는 단어를 ngram으로 추출하는 방식인데 근본적인 해결책이 되진 못하기 때문이다.  \n그리고 `FunctionScoreQuery`, `FilterFunction` 를 이용해서 결과에 대한 점수 부여를 추가했다. 점수 부여에 관한 로직은 카카오 검색셀(hao) 의 도움을 받아 구현했는데, 위에서 데이터 수집당시에 점수를 부여할 수 있는 판매량이나 열람수와 같은 정보를 이용해서 내부적인 공식을 적용해서 점수를 부여했다.  \n쿼리 튜닝이라고는 했지만 결과적으로는 인덱싱할 때부터 데이터를 잘 만드는게 큰 도움이 되었다. 잘 만들어진 데이터가 있어야 좋은 검색이 나올 수 있기 때문이다.  \n\n### 사용자 사전 관리\n내가 의도한대로 토크나이징이 되기 위해 결국엔 사용자 사전을 추가하게 되었다. 또한 신조어들의 대한 대응을 하기 위함이었는데, 예를 들어 `레벨업` 이라는 단어가 포함된 작품을을 검색할 때 기존에는 `레벨` 과 `업` 으로 쪼개버린다.  \n\n```\n레벨업\n레벨\tNNG,*,T,레벨,*,*,*,*\n업\tNNG,*,T,업,*,*,*,*\nEOS\n```\n이 경우에는 `업` 이라는 단어가 포함된 작품들도 함께 결과에 포함되기 때문에 전혀 엉뚱한 작품들이 포함되기도 한다. `레벨업` 이라는 단어를 사전에 고유명사로 등록해서 최대한 엉뚱한 결과가 없게끔 했다.  \n그렇다면 전체 작품에 대해 어떻게 원하는 고유명사를 추출할 수 있을까?  \n이 고민에 대한 해결책은 기존의 검색용 수집 데이터를 사용했다. 운영자가 작품을 등록할 때 `태그` 를 함께 등록하는데 이는 기존에 검색에서 사용되었던 검색 태그들이다. `김비서가 왜그럴까` 같은 경우엔 `김비서` 나 `김명미` 등의 태그들을 걸어두어서 기존의 검색에서 사용할 수 있는 데이터를 제공했었다. 이 데이터를 약간 손봐서 사용가능한 단어들에 대해 사용자 사전에 등록해서 완벽하진 않지만 신조어나 고유명사들에 대한 대응을 했다.  \n데이터가 없는 경우에 뉴스기사나 다른 데이터를 학습해서 토크나이징을 할 수 있는 [soynlp](https://github.com/lovit/soynlp) 같은 훌륭한 오픈소스도 참고할까 싶었지만 개발 시간에 대한 한계도 있었고(핑계지만), 검색 결과에 대해 스스로 보장하기 어렵다는 이유로 도입을 하진 않았다. 나중에 여유가 되면 학습을 통한 토크나이져를 추가해볼까도 고민중인 부분이다.   \n추가적으로 구글에서는 [자연어분석](https://cloud.google.com/natural-language/?hl=ko) 서비스를 내놓았다. 어쩌면 가까운 미래에는 한글 형태소 분석기가 없어도 한글 검색이 가능해질지도 모르겠다.  \n\n### 결론\n기술적인 이야기를 거의 하지 않았더니 개발일기 처럼 되어 버렸다. 이제 곧 웹에서도 검색기능이 들어갈 예정이니 앞으로는 검색을 좀 더 편하게 할 수 있을것이다. 아직은 좀 더 가다듬고 완성도를 높히는데 목표를 두어야 할 것이다. 약 1년동안 개발했던 내용을 몇문장으로 압축해서 쓰려고 하니 하고 싶은 말은 많은데 모두 다 담지 못한 부분도 있다. 나중에 더 생각 나는 부분들에 대해서 좀 더 내용을 써봐야 겠다.","slug":"elasticsearch-with-kakaopage","published":1,"updated":"2018-05-20T09:15:59.470Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjq98sopt000d8ghh3hn5kl9t","content":"<h3><span id=\"elasticsearch-의-검색을-사용하기-까지\">elasticsearch 의 검색을 사용하기 까지</span></h3>\n<p>사내에서 elasticsearch 를 처음 사용하면서 로그 수집정도에만 사용하고 있었다. 워낙에 <a href=\"https://www.elastic.co/kr/elk-stack\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">elk</a> 가 서로 잘 작동하기도 했고 데이터 수집부터 분석까지 너무나도 유려한 기능들을 갖추고 있었다. 서비스에서의 검색을 처음 도입해본 경험은 사내 정산 시스템을 만들면서 였는데, 작품이름 검색이나 작가등의 이름으로 검색을 하게 해달라는 요청이 있어서 였다.<br>\n데이터가 db 에 있어 단순하게 like 검색으로 구현할까 했었는데, 생각보다 결과에 대한 품질이 너무 낮았다. 결과에 대한 점수 부여 방법도 딱히 없고 애초에 조건이 하나만 걸리니 내가 원하는 결과를 얻을 수 없었다.<br>\n그래서 안되겠다 싶어 elasticsearch 와 은전한닢을 이용해 구현했고,  거기서 자신감이 생겨 서비스의 검색도 과감하게 elasticsearch 로 구현하자고 주장했다. 처음에 회사에서는 반기는 분위기는 아니였다.<br>\n기존에 (나름 잘) 동작하는 검색이 구현되어 있었고 한번도 도전해보지 않은 검색이라는 서비스를 잘 구현할 수 있을까에 대한 걱정이 있었다. 그리고 이미 카카오에서 제공하는 검색엔진이 있고 이를 이용하면 우리쪽에서 굳이 만들 이유가 없어서 였다. 카카오에서 제공하는 기능들을 이용하기만 해도 되었지만 앞으로 우리가 우리만의 기술을 갖게 된다면 그 자체로 의미가 있다 생각했고, 결과로 보여드려야겠다고 생각해서 나는 카카오페이지의 검색을 만들어 보기로 했다.</p>\n<h3><span id=\"기존-구성\">기존 구성</span></h3>\n<p>나는 일단 기존의 검색이 어떻게 동작하고 있는지 부터 분석을 해보기로 했다. 지정된 시간마다 단어들을 수집해서 잘게 쪼갠 뒤 테이블에 데이터를 저장해놓고, 실제 서비스에서는 나름의 공식을 이용해 점수를 부여해서 검색 결과를 내어주는 방식이었다. mysql 의 fts 를 이용한 방식이었는데 나름 속도도 괜찮고 완벽하진 않았지만 검색의 결과도 그리 나쁘지는 않았다.<br>\n처음에는 이 검색 서비스부터 이겨보자는 생각으로 다른 검색 서비스들이 검색을 어떻게 서비스 하고 있는지 부터 관찰했다. 개발 초기에는 <a href=\"https://ridibooks.com/\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">리디북스</a>나 <a href=\"https://www.lezhin.com/ko\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">레진코믹스</a> 같은 사이트들의 검색을 많이 참고했다.</p>\n<h3><span id=\"은전한닢\">은전한닢</span></h3>\n<p>한글 형태소 분석기는 크게 3가지가 있다. <a href=\"https://www.elastic.co/kr/blog/using-korean-analyzers\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">elasticsearch 에서 제공하는 형태소분석기 분석</a>에서 보면 arirang, 은전한닢 그리고 open-korean-text(구 twitter-korean-text) 등이 있는데 각 장단점들이 명확해서 아직까지는 형태소 분석기의 절대적인 강자는 없는듯 하다.<br>\n각자 자신에게 맞는 형태소 분석기를 사용하면 되는듯 한데, <a href=\"https://www.ridicorp.com/blog/2016/04/18/ridibooks-stack/\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">리디북스에서 은전한닢을 사용하다는 기술 블로그</a>를 보고 생각의 결과가 많이 굳기도 했지만 음절 분석결과가 가장 자세하고 속도도 괜찮은 은전한닢을 사용하기로 했다.</p>\n<h3><span id=\"클러스터-구성\">클러스터 구성</span></h3>\n<p>2대의 노드로 클러스터를 구성해서 검색 색인을 하고 있고, 주기적으로 추가/변경되는 정보들을 인덱스에 반영하고 있다. 추가적으로 실제 서버 데이터와 개발에서의 구성도 elasticsearch 로 구성했는데, 테스트 서버군은 하나의 노드로 구성했고 각 테스트군별로 색인을 따로 구성했다.</p>\n<h3><span id=\"데이터-수집및-정제\">데이터 수집및 정제</span></h3>\n<p>검색 쿼리만큼이나 중요한 부분이 데이터 수집이다. 어찌보면 색인이 얼마나 잘 되어 있느냐에 따라 검색 결과의 품질이 좌우된다. 색인과 검색의 비율을 따져 생각해본다면 6:4 정도라고 생각한다. 아무리 많은 데이터를 사용한다 하더라도 데이터가 잘 저장되어 있지 않으면 아무런 소용이 없기 때문이다.<br>\n일단 데이터를 주기적으로 수집하기로 했고, 카카오 검색팀의 조언을 받아 단어에 대한 점수에 대한 결과도 함께 수집을 한다. logstash 로 처음에는 데이터를 수집하려고 했는데 점수부여에 대한 로직이나 데이터 정제의 편의성을 위해 배치작업을 데이터를 수집했다. 간략하게 수집되는 정보들을 보면 다음과 같다.</p>\n<ul>\n<li>열람수, 구매자수, 인기도, 기다리면 무료의 대한 점수 계산</li>\n<li>랭킹데이터 수집</li>\n<li>(정산 시스템 구축의 경험으로) 계약 주체에 따른 점수 부여</li>\n<li>운영자가 등록한 태그 수집</li>\n<li>작품명, 작가명, 발행자명, 출연진등의 정보 수집</li>\n</ul>\n<p>가능한 모든 정보를 수집하고자 했고, 은전한닢으로 기분석된 단어와 순수한 단어를 따로 인덱싱을 했다. 이유는 나중에 검색부분에도 언급하겠지만 한글 형태소 분석기로 분석된 단어와 그렇지 않은 단어를 함께 검색 쿼리에 넣어 검색의 결과를 높이기 위함이다. 형태소 분석기를 통해 토크나이징을 하게 되면 자체적으로 단어를 쪼개게 되는데, 이 때 원치 않게 단어가 나뉠수도 있기 때문이다.<br>\n예를 들어 <code>김비서</code> 이라는 단어를 형태소 분석기에 넣고 돌리면 엉뚱한 결과가 나온다.</p>\n<figure class=\"highlight asciidoc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">김비서</span><br><span class=\"line\">김비\tNNP,인명,F,김비,<span class=\"strong\">*,*</span>,<span class=\"strong\">*,*</span></span><br><span class=\"line\">서\tJKB,<span class=\"strong\">*,F,서,*</span>,<span class=\"strong\">*,*</span>,<span class=\"strong\">*</span></span><br><span class=\"line\"><span class=\"strong\">EOS</span></span><br></pre></td></tr></table></figure>\n<p>일반적으로 생각했을 때 <code>김</code>, <code>비서</code> 로 나올거라 예상했지만 결과는 이와는 달리 <code>김비</code>, <code>서</code> 로 나뉘게 되버린다. 원인은 제공되는 정보가 부족해서인데, 모든 문장을 써주면 정상적으로 표시 된다.</p>\n<figure class=\"highlight markdown\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">김비서가왜그럴까</span><br><span class=\"line\">김\tNNP,인명,T,김,<span class=\"emphasis\">*,*</span>,<span class=\"emphasis\">*,*</span></span><br><span class=\"line\">비서\tNNG,<span class=\"emphasis\">*,F,비서,*</span>,<span class=\"emphasis\">*,*</span>,*</span><br><span class=\"line\">가\tJKS,<span class=\"emphasis\">*,F,가,*</span>,<span class=\"emphasis\">*,*</span>,*</span><br><span class=\"line\">왜\tMAG,문장부사/양상부사,F,왜,<span class=\"emphasis\">*,*</span>,<span class=\"emphasis\">*,*</span></span><br><span class=\"line\">그럴까\tVA+EC,<span class=\"emphasis\">*,F,그럴까,Inflect,VA,EC,그렇/VA/*</span>+ᆯ까/EC/*</span><br></pre></td></tr></table></figure>\n<p>이런식의 토크나이징은 검색에서도 문제가 된다. elastisearch 에서 검색을 태우면 색인되어 있는 타입에 따라 기분석해서 나온 토큰들로 검색을 하게 되는데 사용자가 <code>김비서</code> 라고 검색을 하게 되면 <code>서</code> 라는 토큰이 나오게 되기 때문에 엉뚱한 검색 결과가 나오게 된다.<br>\n추가적으로 난감했던 단어는 <code>하라간</code> 과 같이 사전에 등록되지 않은 고유명사들의 경우였다. 은전한닢은 세종 말뭉치를 사용하고 있는데, 비교적 최근에 추가되는 신조어들이나 작품에서 의도적으로 사용되는 고유명사들에 대한 데이터는 존재 하지 않는다. <code>하라간</code> 의 경우엔 형태소 분석기에서는 아예 알아들을 수 없는 단어가 되어버린다.</p>\n<figure class=\"highlight asciidoc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">하라간</span><br><span class=\"line\">하\tVV,<span class=\"strong\">*,F,하,*</span>,<span class=\"strong\">*,*</span>,<span class=\"strong\">*</span></span><br><span class=\"line\"><span class=\"strong\">라\tEC,*</span>,F,라,<span class=\"strong\">*,*</span>,<span class=\"strong\">*,*</span></span><br><span class=\"line\">간\tNNG,<span class=\"strong\">*,T,간,*</span>,<span class=\"strong\">*,*</span>,<span class=\"strong\">*</span></span><br><span class=\"line\"><span class=\"strong\">EOS</span></span><br></pre></td></tr></table></figure>\n<p>(…여기서 멘붕이 왔었다.)<br>\n임시방편으로 사용했던 방법은 mecab 에서 제공하는 사용자 사전이었는데, 인명이나 지명등의 단어를 넣으면 형태소 분석기에서 의도적으로 단어를 쪼개지 않고 단어 그자체로서 인식을 가능하게 한다.<br>\n하지만 4만개가 넘는 모든 작품들을 모니터링하고 일일히 결과를 들여다보면서 사용자 사전에 필요한 단어들을 넣는건 나 혼자 작업으로는 불가능했었고, 처음에는 사용자 cs 나 내부적으로 결과가 이상한 단어들에 대해서만 사전에 등록했었다. (사용자 사전은 나중에 좀 더 자세하게 이야기 해보자.)</p>\n<h3><span id=\"데이터-색인\">데이터 색인</span></h3>\n<p>데이터는 항상 추가된다. 하지만 판매중이었다가 여러 이유로 판매가 중지되는 작품도 있고 운영자에 의해 작품의 정보가 변경되는 일도 꽤나 잦았다. 이미 존재하는 필드에 값을 갱신하려고 했더니 경우의 수가 너무 많았다. 모든 상황에 대해 신시간으로 대응하기 위해서 <a href=\"https://www.elastic.co/kr/blog/changing-mapping-with-zero-downtime\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">다른 곳에서 아이디어</a>를 얻었는데 elasticsearch 에서 제공하는 <a href=\"https://www.elastic.co/guide/en/elasticsearch/reference/6.2/indices-aliases.html\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">alias</a> 와 일반적인 <a href=\"http://en.dwhwiki.info/concepts/blue-green-development\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">blue-green deploy</a> 방법을 이용해서 모든 데이터를 주기적으로 새로 갱신하는 방법을 이용했다. <code>index-blue</code>, <code>index-green</code> 를 하나씩 생성하고 <code>index</code> 라는 <code>alias</code> 를 걸어 실제 검색 쿼리는 <code>index alias</code> 를 바라보게 했다. 데이터 수집 배치는 독립적으로 동작하고 있기에 실시간으로 필드를 추가하는 장점도 함께 가져갈 수 있다.</p>\n<h3><span id=\"검색-쿼리\">검색 쿼리</span></h3>\n<p>초기의 버전에서는 사용자 사전을 최대한 사용하지 않는 방향으로 진행했었다. 위에서 언급한 바와 같이 모든 고유명사들을 수동으로 쪼개는 작업이 물리적으로 불가능했었기 때문인데, 이런 제한을 극복하고자 최대한 검색 쿼리를 세부적으로 쪼개서 검색의 결과를 높이고자 했다.<br>\nmapping 에서 title 에 관련된 정보는 다음과 같이 구성했다.</p>\n<figure class=\"highlight xquery\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">\"title\"</span>: &#123;</span><br><span class=\"line\">    <span class=\"string\">\"type\"</span>: <span class=\"string\">\"text\"</span>,</span><br><span class=\"line\">    <span class=\"string\">\"analyzer\"</span>: <span class=\"string\">\"seunjeon_analyzer\"</span></span><br><span class=\"line\">&#125;,</span><br><span class=\"line\"><span class=\"string\">\"titleBigram\"</span>: &#123;</span><br><span class=\"line\">    <span class=\"string\">\"type\"</span>: <span class=\"string\">\"text\"</span>,</span><br><span class=\"line\">    <span class=\"string\">\"analyzer\"</span>: <span class=\"string\">\"han_bigrams\"</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"string\">\"titleStandard\"</span>: &#123;</span><br><span class=\"line\">    <span class=\"string\">\"type\"</span>: <span class=\"string\">\"text\"</span>,</span><br><span class=\"line\">    <span class=\"string\">\"analyzer\"</span>: <span class=\"string\">\"exact\"</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li><a href=\"http://eunjeon.blogspot.kr/\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">은전한닢</a></li>\n<li><a href=\"https://www.elastic.co/guide/en/elasticsearch/reference/current/analysis-cjk-bigram-tokenfilter.html\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">bigram</a></li>\n<li>띄어쓰기등을 제거한 <a href=\"https://www.elastic.co/guide/en/elasticsearch/reference/current/analysis-standard-analyzer.html\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">standard analyzer</a></li>\n</ul>\n<p>검색 쿼리를 수행시 3개의 필드에 대해 각기 다른 boost 를 줘서 가장 근접한 결과에 대해 점수를 높게 부여해서 결과를 만들었다. bigram 을 사용한 이유는 앞서 언급한 형태소 분석기의 한계를 대체하기 위해 색인되는 단어들을 ngram 으로 조개어 저장해서 엉뚱한 결과가 나오는 것에 대한 대처였다. (나중에 다시 언급하겠지만 결과적으로는 <code>bigram</code> 을 사용하지 않게 되었다.)<br>\n<code>MatchQuery</code> 로 검색을 하는데 위에서 언급한 대로 기분석된 색인이 엉뚱하게 저장되는 경우들이 꽤나 빈번했기 때문에 초기 검색결과는 가히 충격적이었다. 왜 이 단어가 검색이 되었지? 하는 결과들이 포함되어 있었기 때문이었다. 이후에 카카오 검색셀의 조언을 받아 쿼리는 대대적으로 튜닝하게 되었다.</p>\n<h3><span id=\"elasticsearch-버전-관리\">elasticsearch 버전 관리</span></h3>\n<p>개발 초기에는 elasticsearch 최신 버전이 5.1.1 이었다. 검색 서비스를 라이브에 반영하게 되고 보니 버전은 6.x 까지 올라가버렸다. 요즘 추세인지는 모르겠지만 어째 버전업이 너무나도 빠르게 진행되고 있었다. 이전 포스트에서도 얘기 했었던 <a href=\"https://www.elastic.co/support/eol\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">elasticsearch 기술 지원</a> 때문에라도 elasticsearch 버전을 주기적으로 (꽤나 빈번하게) 올리기도 했다. rolling upgrade 에 대한 내용은 <a href=\"https://nevercaution.github.io/2018/03/15/elasticsearch-rest-client/\">여기</a>에서 자세하게 다루었다.</p>\n<h3><span id=\"쿼리-튜닝\">쿼리 튜닝</span></h3>\n<p>사용자 사전 없이 <code>title</code>, <code>titleBigram</code>, <code>titleStandard</code> 만들어 검색쿼리를 날리면 정말 검색 결과가 엉뚱하게 나오는 경우가 있다. 위에서도 언급한 토크나이징 때문인데 이는 사용자 사전 없이는 사실상 불가능 하다. 사용자 사전을 추가하고 난 후에는 bigram 은 사용하지 않고 <code>title</code>, <code>titleStandard</code> 두 필드를 사용해서 <code>MatchQuery</code> 를 날린다. <code>bigram</code> 도 결국에는 단어를 ngram으로 추출하는 방식인데 근본적인 해결책이 되진 못하기 때문이다.<br>\n그리고 <code>FunctionScoreQuery</code>, <code>FilterFunction</code> 를 이용해서 결과에 대한 점수 부여를 추가했다. 점수 부여에 관한 로직은 카카오 검색셀(hao) 의 도움을 받아 구현했는데, 위에서 데이터 수집당시에 점수를 부여할 수 있는 판매량이나 열람수와 같은 정보를 이용해서 내부적인 공식을 적용해서 점수를 부여했다.<br>\n쿼리 튜닝이라고는 했지만 결과적으로는 인덱싱할 때부터 데이터를 잘 만드는게 큰 도움이 되었다. 잘 만들어진 데이터가 있어야 좋은 검색이 나올 수 있기 때문이다.</p>\n<h3><span id=\"사용자-사전-관리\">사용자 사전 관리</span></h3>\n<p>내가 의도한대로 토크나이징이 되기 위해 결국엔 사용자 사전을 추가하게 되었다. 또한 신조어들의 대한 대응을 하기 위함이었는데, 예를 들어 <code>레벨업</code> 이라는 단어가 포함된 작품을을 검색할 때 기존에는 <code>레벨</code> 과 <code>업</code> 으로 쪼개버린다.</p>\n<figure class=\"highlight asciidoc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">레벨업</span><br><span class=\"line\">레벨\tNNG,<span class=\"strong\">*,T,레벨,*</span>,<span class=\"strong\">*,*</span>,<span class=\"strong\">*</span></span><br><span class=\"line\"><span class=\"strong\">업\tNNG,*</span>,T,업,<span class=\"strong\">*,*</span>,<span class=\"strong\">*,*</span></span><br><span class=\"line\">EOS</span><br></pre></td></tr></table></figure>\n<p>이 경우에는 <code>업</code> 이라는 단어가 포함된 작품들도 함께 결과에 포함되기 때문에 전혀 엉뚱한 작품들이 포함되기도 한다. <code>레벨업</code> 이라는 단어를 사전에 고유명사로 등록해서 최대한 엉뚱한 결과가 없게끔 했다.<br>\n그렇다면 전체 작품에 대해 어떻게 원하는 고유명사를 추출할 수 있을까?<br>\n이 고민에 대한 해결책은 기존의 검색용 수집 데이터를 사용했다. 운영자가 작품을 등록할 때 <code>태그</code> 를 함께 등록하는데 이는 기존에 검색에서 사용되었던 검색 태그들이다. <code>김비서가 왜그럴까</code> 같은 경우엔 <code>김비서</code> 나 <code>김명미</code> 등의 태그들을 걸어두어서 기존의 검색에서 사용할 수 있는 데이터를 제공했었다. 이 데이터를 약간 손봐서 사용가능한 단어들에 대해 사용자 사전에 등록해서 완벽하진 않지만 신조어나 고유명사들에 대한 대응을 했다.<br>\n데이터가 없는 경우에 뉴스기사나 다른 데이터를 학습해서 토크나이징을 할 수 있는 <a href=\"https://github.com/lovit/soynlp\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">soynlp</a> 같은 훌륭한 오픈소스도 참고할까 싶었지만 개발 시간에 대한 한계도 있었고(핑계지만), 검색 결과에 대해 스스로 보장하기 어렵다는 이유로 도입을 하진 않았다. 나중에 여유가 되면 학습을 통한 토크나이져를 추가해볼까도 고민중인 부분이다.<br>\n추가적으로 구글에서는 <a href=\"https://cloud.google.com/natural-language/?hl=ko\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">자연어분석</a> 서비스를 내놓았다. 어쩌면 가까운 미래에는 한글 형태소 분석기가 없어도 한글 검색이 가능해질지도 모르겠다.</p>\n<h3><span id=\"결론\">결론</span></h3>\n<p>기술적인 이야기를 거의 하지 않았더니 개발일기 처럼 되어 버렸다. 이제 곧 웹에서도 검색기능이 들어갈 예정이니 앞으로는 검색을 좀 더 편하게 할 수 있을것이다. 아직은 좀 더 가다듬고 완성도를 높히는데 목표를 두어야 할 것이다. 약 1년동안 개발했던 내용을 몇문장으로 압축해서 쓰려고 하니 하고 싶은 말은 많은데 모두 다 담지 못한 부분도 있다. 나중에 더 생각 나는 부분들에 대해서 좀 더 내용을 써봐야 겠다.</p>\n","site":{"data":{}},"excerpt":"","more":"<h3>elasticsearch 의 검색을 사용하기 까지</h3>\n<p>사내에서 elasticsearch 를 처음 사용하면서 로그 수집정도에만 사용하고 있었다. 워낙에 <a href=\"https://www.elastic.co/kr/elk-stack\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">elk</a> 가 서로 잘 작동하기도 했고 데이터 수집부터 분석까지 너무나도 유려한 기능들을 갖추고 있었다. 서비스에서의 검색을 처음 도입해본 경험은 사내 정산 시스템을 만들면서 였는데, 작품이름 검색이나 작가등의 이름으로 검색을 하게 해달라는 요청이 있어서 였다.<br>\n데이터가 db 에 있어 단순하게 like 검색으로 구현할까 했었는데, 생각보다 결과에 대한 품질이 너무 낮았다. 결과에 대한 점수 부여 방법도 딱히 없고 애초에 조건이 하나만 걸리니 내가 원하는 결과를 얻을 수 없었다.<br>\n그래서 안되겠다 싶어 elasticsearch 와 은전한닢을 이용해 구현했고,  거기서 자신감이 생겨 서비스의 검색도 과감하게 elasticsearch 로 구현하자고 주장했다. 처음에 회사에서는 반기는 분위기는 아니였다.<br>\n기존에 (나름 잘) 동작하는 검색이 구현되어 있었고 한번도 도전해보지 않은 검색이라는 서비스를 잘 구현할 수 있을까에 대한 걱정이 있었다. 그리고 이미 카카오에서 제공하는 검색엔진이 있고 이를 이용하면 우리쪽에서 굳이 만들 이유가 없어서 였다. 카카오에서 제공하는 기능들을 이용하기만 해도 되었지만 앞으로 우리가 우리만의 기술을 갖게 된다면 그 자체로 의미가 있다 생각했고, 결과로 보여드려야겠다고 생각해서 나는 카카오페이지의 검색을 만들어 보기로 했다.</p>\n<h3>기존 구성</h3>\n<p>나는 일단 기존의 검색이 어떻게 동작하고 있는지 부터 분석을 해보기로 했다. 지정된 시간마다 단어들을 수집해서 잘게 쪼갠 뒤 테이블에 데이터를 저장해놓고, 실제 서비스에서는 나름의 공식을 이용해 점수를 부여해서 검색 결과를 내어주는 방식이었다. mysql 의 fts 를 이용한 방식이었는데 나름 속도도 괜찮고 완벽하진 않았지만 검색의 결과도 그리 나쁘지는 않았다.<br>\n처음에는 이 검색 서비스부터 이겨보자는 생각으로 다른 검색 서비스들이 검색을 어떻게 서비스 하고 있는지 부터 관찰했다. 개발 초기에는 <a href=\"https://ridibooks.com/\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">리디북스</a>나 <a href=\"https://www.lezhin.com/ko\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">레진코믹스</a> 같은 사이트들의 검색을 많이 참고했다.</p>\n<h3>은전한닢</h3>\n<p>한글 형태소 분석기는 크게 3가지가 있다. <a href=\"https://www.elastic.co/kr/blog/using-korean-analyzers\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">elasticsearch 에서 제공하는 형태소분석기 분석</a>에서 보면 arirang, 은전한닢 그리고 open-korean-text(구 twitter-korean-text) 등이 있는데 각 장단점들이 명확해서 아직까지는 형태소 분석기의 절대적인 강자는 없는듯 하다.<br>\n각자 자신에게 맞는 형태소 분석기를 사용하면 되는듯 한데, <a href=\"https://www.ridicorp.com/blog/2016/04/18/ridibooks-stack/\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">리디북스에서 은전한닢을 사용하다는 기술 블로그</a>를 보고 생각의 결과가 많이 굳기도 했지만 음절 분석결과가 가장 자세하고 속도도 괜찮은 은전한닢을 사용하기로 했다.</p>\n<h3>클러스터 구성</h3>\n<p>2대의 노드로 클러스터를 구성해서 검색 색인을 하고 있고, 주기적으로 추가/변경되는 정보들을 인덱스에 반영하고 있다. 추가적으로 실제 서버 데이터와 개발에서의 구성도 elasticsearch 로 구성했는데, 테스트 서버군은 하나의 노드로 구성했고 각 테스트군별로 색인을 따로 구성했다.</p>\n<h3>데이터 수집및 정제</h3>\n<p>검색 쿼리만큼이나 중요한 부분이 데이터 수집이다. 어찌보면 색인이 얼마나 잘 되어 있느냐에 따라 검색 결과의 품질이 좌우된다. 색인과 검색의 비율을 따져 생각해본다면 6:4 정도라고 생각한다. 아무리 많은 데이터를 사용한다 하더라도 데이터가 잘 저장되어 있지 않으면 아무런 소용이 없기 때문이다.<br>\n일단 데이터를 주기적으로 수집하기로 했고, 카카오 검색팀의 조언을 받아 단어에 대한 점수에 대한 결과도 함께 수집을 한다. logstash 로 처음에는 데이터를 수집하려고 했는데 점수부여에 대한 로직이나 데이터 정제의 편의성을 위해 배치작업을 데이터를 수집했다. 간략하게 수집되는 정보들을 보면 다음과 같다.</p>\n<ul>\n<li>열람수, 구매자수, 인기도, 기다리면 무료의 대한 점수 계산</li>\n<li>랭킹데이터 수집</li>\n<li>(정산 시스템 구축의 경험으로) 계약 주체에 따른 점수 부여</li>\n<li>운영자가 등록한 태그 수집</li>\n<li>작품명, 작가명, 발행자명, 출연진등의 정보 수집</li>\n</ul>\n<p>가능한 모든 정보를 수집하고자 했고, 은전한닢으로 기분석된 단어와 순수한 단어를 따로 인덱싱을 했다. 이유는 나중에 검색부분에도 언급하겠지만 한글 형태소 분석기로 분석된 단어와 그렇지 않은 단어를 함께 검색 쿼리에 넣어 검색의 결과를 높이기 위함이다. 형태소 분석기를 통해 토크나이징을 하게 되면 자체적으로 단어를 쪼개게 되는데, 이 때 원치 않게 단어가 나뉠수도 있기 때문이다.<br>\n예를 들어 <code>김비서</code> 이라는 단어를 형태소 분석기에 넣고 돌리면 엉뚱한 결과가 나온다.</p>\n<figure class=\"highlight asciidoc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">김비서</span><br><span class=\"line\">김비\tNNP,인명,F,김비,<span class=\"strong\">*,*</span>,<span class=\"strong\">*,*</span></span><br><span class=\"line\">서\tJKB,<span class=\"strong\">*,F,서,*</span>,<span class=\"strong\">*,*</span>,<span class=\"strong\">*</span></span><br><span class=\"line\"><span class=\"strong\">EOS</span></span><br></pre></td></tr></table></figure>\n<p>일반적으로 생각했을 때 <code>김</code>, <code>비서</code> 로 나올거라 예상했지만 결과는 이와는 달리 <code>김비</code>, <code>서</code> 로 나뉘게 되버린다. 원인은 제공되는 정보가 부족해서인데, 모든 문장을 써주면 정상적으로 표시 된다.</p>\n<figure class=\"highlight markdown\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">김비서가왜그럴까</span><br><span class=\"line\">김\tNNP,인명,T,김,<span class=\"emphasis\">*,*</span>,<span class=\"emphasis\">*,*</span></span><br><span class=\"line\">비서\tNNG,<span class=\"emphasis\">*,F,비서,*</span>,<span class=\"emphasis\">*,*</span>,*</span><br><span class=\"line\">가\tJKS,<span class=\"emphasis\">*,F,가,*</span>,<span class=\"emphasis\">*,*</span>,*</span><br><span class=\"line\">왜\tMAG,문장부사/양상부사,F,왜,<span class=\"emphasis\">*,*</span>,<span class=\"emphasis\">*,*</span></span><br><span class=\"line\">그럴까\tVA+EC,<span class=\"emphasis\">*,F,그럴까,Inflect,VA,EC,그렇/VA/*</span>+ᆯ까/EC/*</span><br></pre></td></tr></table></figure>\n<p>이런식의 토크나이징은 검색에서도 문제가 된다. elastisearch 에서 검색을 태우면 색인되어 있는 타입에 따라 기분석해서 나온 토큰들로 검색을 하게 되는데 사용자가 <code>김비서</code> 라고 검색을 하게 되면 <code>서</code> 라는 토큰이 나오게 되기 때문에 엉뚱한 검색 결과가 나오게 된다.<br>\n추가적으로 난감했던 단어는 <code>하라간</code> 과 같이 사전에 등록되지 않은 고유명사들의 경우였다. 은전한닢은 세종 말뭉치를 사용하고 있는데, 비교적 최근에 추가되는 신조어들이나 작품에서 의도적으로 사용되는 고유명사들에 대한 데이터는 존재 하지 않는다. <code>하라간</code> 의 경우엔 형태소 분석기에서는 아예 알아들을 수 없는 단어가 되어버린다.</p>\n<figure class=\"highlight asciidoc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">하라간</span><br><span class=\"line\">하\tVV,<span class=\"strong\">*,F,하,*</span>,<span class=\"strong\">*,*</span>,<span class=\"strong\">*</span></span><br><span class=\"line\"><span class=\"strong\">라\tEC,*</span>,F,라,<span class=\"strong\">*,*</span>,<span class=\"strong\">*,*</span></span><br><span class=\"line\">간\tNNG,<span class=\"strong\">*,T,간,*</span>,<span class=\"strong\">*,*</span>,<span class=\"strong\">*</span></span><br><span class=\"line\"><span class=\"strong\">EOS</span></span><br></pre></td></tr></table></figure>\n<p>(…여기서 멘붕이 왔었다.)<br>\n임시방편으로 사용했던 방법은 mecab 에서 제공하는 사용자 사전이었는데, 인명이나 지명등의 단어를 넣으면 형태소 분석기에서 의도적으로 단어를 쪼개지 않고 단어 그자체로서 인식을 가능하게 한다.<br>\n하지만 4만개가 넘는 모든 작품들을 모니터링하고 일일히 결과를 들여다보면서 사용자 사전에 필요한 단어들을 넣는건 나 혼자 작업으로는 불가능했었고, 처음에는 사용자 cs 나 내부적으로 결과가 이상한 단어들에 대해서만 사전에 등록했었다. (사용자 사전은 나중에 좀 더 자세하게 이야기 해보자.)</p>\n<h3>데이터 색인</h3>\n<p>데이터는 항상 추가된다. 하지만 판매중이었다가 여러 이유로 판매가 중지되는 작품도 있고 운영자에 의해 작품의 정보가 변경되는 일도 꽤나 잦았다. 이미 존재하는 필드에 값을 갱신하려고 했더니 경우의 수가 너무 많았다. 모든 상황에 대해 신시간으로 대응하기 위해서 <a href=\"https://www.elastic.co/kr/blog/changing-mapping-with-zero-downtime\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">다른 곳에서 아이디어</a>를 얻었는데 elasticsearch 에서 제공하는 <a href=\"https://www.elastic.co/guide/en/elasticsearch/reference/6.2/indices-aliases.html\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">alias</a> 와 일반적인 <a href=\"http://en.dwhwiki.info/concepts/blue-green-development\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">blue-green deploy</a> 방법을 이용해서 모든 데이터를 주기적으로 새로 갱신하는 방법을 이용했다. <code>index-blue</code>, <code>index-green</code> 를 하나씩 생성하고 <code>index</code> 라는 <code>alias</code> 를 걸어 실제 검색 쿼리는 <code>index alias</code> 를 바라보게 했다. 데이터 수집 배치는 독립적으로 동작하고 있기에 실시간으로 필드를 추가하는 장점도 함께 가져갈 수 있다.</p>\n<h3>검색 쿼리</h3>\n<p>초기의 버전에서는 사용자 사전을 최대한 사용하지 않는 방향으로 진행했었다. 위에서 언급한 바와 같이 모든 고유명사들을 수동으로 쪼개는 작업이 물리적으로 불가능했었기 때문인데, 이런 제한을 극복하고자 최대한 검색 쿼리를 세부적으로 쪼개서 검색의 결과를 높이고자 했다.<br>\nmapping 에서 title 에 관련된 정보는 다음과 같이 구성했다.</p>\n<figure class=\"highlight xquery\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">\"title\"</span>: &#123;</span><br><span class=\"line\">    <span class=\"string\">\"type\"</span>: <span class=\"string\">\"text\"</span>,</span><br><span class=\"line\">    <span class=\"string\">\"analyzer\"</span>: <span class=\"string\">\"seunjeon_analyzer\"</span></span><br><span class=\"line\">&#125;,</span><br><span class=\"line\"><span class=\"string\">\"titleBigram\"</span>: &#123;</span><br><span class=\"line\">    <span class=\"string\">\"type\"</span>: <span class=\"string\">\"text\"</span>,</span><br><span class=\"line\">    <span class=\"string\">\"analyzer\"</span>: <span class=\"string\">\"han_bigrams\"</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"string\">\"titleStandard\"</span>: &#123;</span><br><span class=\"line\">    <span class=\"string\">\"type\"</span>: <span class=\"string\">\"text\"</span>,</span><br><span class=\"line\">    <span class=\"string\">\"analyzer\"</span>: <span class=\"string\">\"exact\"</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li><a href=\"http://eunjeon.blogspot.kr/\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">은전한닢</a></li>\n<li><a href=\"https://www.elastic.co/guide/en/elasticsearch/reference/current/analysis-cjk-bigram-tokenfilter.html\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">bigram</a></li>\n<li>띄어쓰기등을 제거한 <a href=\"https://www.elastic.co/guide/en/elasticsearch/reference/current/analysis-standard-analyzer.html\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">standard analyzer</a></li>\n</ul>\n<p>검색 쿼리를 수행시 3개의 필드에 대해 각기 다른 boost 를 줘서 가장 근접한 결과에 대해 점수를 높게 부여해서 결과를 만들었다. bigram 을 사용한 이유는 앞서 언급한 형태소 분석기의 한계를 대체하기 위해 색인되는 단어들을 ngram 으로 조개어 저장해서 엉뚱한 결과가 나오는 것에 대한 대처였다. (나중에 다시 언급하겠지만 결과적으로는 <code>bigram</code> 을 사용하지 않게 되었다.)<br>\n<code>MatchQuery</code> 로 검색을 하는데 위에서 언급한 대로 기분석된 색인이 엉뚱하게 저장되는 경우들이 꽤나 빈번했기 때문에 초기 검색결과는 가히 충격적이었다. 왜 이 단어가 검색이 되었지? 하는 결과들이 포함되어 있었기 때문이었다. 이후에 카카오 검색셀의 조언을 받아 쿼리는 대대적으로 튜닝하게 되었다.</p>\n<h3>elasticsearch 버전 관리</h3>\n<p>개발 초기에는 elasticsearch 최신 버전이 5.1.1 이었다. 검색 서비스를 라이브에 반영하게 되고 보니 버전은 6.x 까지 올라가버렸다. 요즘 추세인지는 모르겠지만 어째 버전업이 너무나도 빠르게 진행되고 있었다. 이전 포스트에서도 얘기 했었던 <a href=\"https://www.elastic.co/support/eol\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">elasticsearch 기술 지원</a> 때문에라도 elasticsearch 버전을 주기적으로 (꽤나 빈번하게) 올리기도 했다. rolling upgrade 에 대한 내용은 <a href=\"https://nevercaution.github.io/2018/03/15/elasticsearch-rest-client/\">여기</a>에서 자세하게 다루었다.</p>\n<h3>쿼리 튜닝</h3>\n<p>사용자 사전 없이 <code>title</code>, <code>titleBigram</code>, <code>titleStandard</code> 만들어 검색쿼리를 날리면 정말 검색 결과가 엉뚱하게 나오는 경우가 있다. 위에서도 언급한 토크나이징 때문인데 이는 사용자 사전 없이는 사실상 불가능 하다. 사용자 사전을 추가하고 난 후에는 bigram 은 사용하지 않고 <code>title</code>, <code>titleStandard</code> 두 필드를 사용해서 <code>MatchQuery</code> 를 날린다. <code>bigram</code> 도 결국에는 단어를 ngram으로 추출하는 방식인데 근본적인 해결책이 되진 못하기 때문이다.<br>\n그리고 <code>FunctionScoreQuery</code>, <code>FilterFunction</code> 를 이용해서 결과에 대한 점수 부여를 추가했다. 점수 부여에 관한 로직은 카카오 검색셀(hao) 의 도움을 받아 구현했는데, 위에서 데이터 수집당시에 점수를 부여할 수 있는 판매량이나 열람수와 같은 정보를 이용해서 내부적인 공식을 적용해서 점수를 부여했다.<br>\n쿼리 튜닝이라고는 했지만 결과적으로는 인덱싱할 때부터 데이터를 잘 만드는게 큰 도움이 되었다. 잘 만들어진 데이터가 있어야 좋은 검색이 나올 수 있기 때문이다.</p>\n<h3>사용자 사전 관리</h3>\n<p>내가 의도한대로 토크나이징이 되기 위해 결국엔 사용자 사전을 추가하게 되었다. 또한 신조어들의 대한 대응을 하기 위함이었는데, 예를 들어 <code>레벨업</code> 이라는 단어가 포함된 작품을을 검색할 때 기존에는 <code>레벨</code> 과 <code>업</code> 으로 쪼개버린다.</p>\n<figure class=\"highlight asciidoc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">레벨업</span><br><span class=\"line\">레벨\tNNG,<span class=\"strong\">*,T,레벨,*</span>,<span class=\"strong\">*,*</span>,<span class=\"strong\">*</span></span><br><span class=\"line\"><span class=\"strong\">업\tNNG,*</span>,T,업,<span class=\"strong\">*,*</span>,<span class=\"strong\">*,*</span></span><br><span class=\"line\">EOS</span><br></pre></td></tr></table></figure>\n<p>이 경우에는 <code>업</code> 이라는 단어가 포함된 작품들도 함께 결과에 포함되기 때문에 전혀 엉뚱한 작품들이 포함되기도 한다. <code>레벨업</code> 이라는 단어를 사전에 고유명사로 등록해서 최대한 엉뚱한 결과가 없게끔 했다.<br>\n그렇다면 전체 작품에 대해 어떻게 원하는 고유명사를 추출할 수 있을까?<br>\n이 고민에 대한 해결책은 기존의 검색용 수집 데이터를 사용했다. 운영자가 작품을 등록할 때 <code>태그</code> 를 함께 등록하는데 이는 기존에 검색에서 사용되었던 검색 태그들이다. <code>김비서가 왜그럴까</code> 같은 경우엔 <code>김비서</code> 나 <code>김명미</code> 등의 태그들을 걸어두어서 기존의 검색에서 사용할 수 있는 데이터를 제공했었다. 이 데이터를 약간 손봐서 사용가능한 단어들에 대해 사용자 사전에 등록해서 완벽하진 않지만 신조어나 고유명사들에 대한 대응을 했다.<br>\n데이터가 없는 경우에 뉴스기사나 다른 데이터를 학습해서 토크나이징을 할 수 있는 <a href=\"https://github.com/lovit/soynlp\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">soynlp</a> 같은 훌륭한 오픈소스도 참고할까 싶었지만 개발 시간에 대한 한계도 있었고(핑계지만), 검색 결과에 대해 스스로 보장하기 어렵다는 이유로 도입을 하진 않았다. 나중에 여유가 되면 학습을 통한 토크나이져를 추가해볼까도 고민중인 부분이다.<br>\n추가적으로 구글에서는 <a href=\"https://cloud.google.com/natural-language/?hl=ko\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">자연어분석</a> 서비스를 내놓았다. 어쩌면 가까운 미래에는 한글 형태소 분석기가 없어도 한글 검색이 가능해질지도 모르겠다.</p>\n<h3>결론</h3>\n<p>기술적인 이야기를 거의 하지 않았더니 개발일기 처럼 되어 버렸다. 이제 곧 웹에서도 검색기능이 들어갈 예정이니 앞으로는 검색을 좀 더 편하게 할 수 있을것이다. 아직은 좀 더 가다듬고 완성도를 높히는데 목표를 두어야 할 것이다. 약 1년동안 개발했던 내용을 몇문장으로 압축해서 쓰려고 하니 하고 싶은 말은 많은데 모두 다 담지 못한 부분도 있다. 나중에 더 생각 나는 부분들에 대해서 좀 더 내용을 써봐야 겠다.</p>\n"},{"title":"Spring Boot Actuator 를 이용해 버전 정보 제공하기","catalog":true,"date":"2018-03-24T06:23:14.000Z","subtitle":null,"header-img":"/img/header_img/bg.png","_content":"\n### 지금 dev 서버에 배포되어 있는 서버 버전이 몇인가요?\n회사에 서버환경은 dev, sandbox, test, beta, alpha, real 으로 나뉘어 있다. 각 단계별로 기능 테스트를 하고 QA를 통해 모든 기능이 개발 완료 되고 QA도 끝나면 real 서버에 배포가 된다.  \n나와 클라이언트 개발자는 먼저 dev 서버에서 새로운 기능이나 버그 수정등을 테스트 하는데 일정에 쫓길 때는 메이져 버전과 마이너 버전이 동시에 작업되서 두개의 버전을 두고 개발해야 하는 상황이 생기기도 한다.  \n젠킨스를 통해 해당 서버에 어플리케이션을 배포하는데 지금까지는 배포된 버전을 보기 위해선 젠킨스의 배포이력을 찾아 배포된 버전을 찾았어야 했었다. 여간 귀찮은 일이 아닐 수가 없다. 하지만 이 방법밖에는 없으니 얼른 클라이언트 개발자에게 현재 배포된 버전을 찾아서 알려주자.    \n`build.gradle` 에 배포된 버전을 명시해놓고 있긴 하지만 jar로 묶인 패키지에는 버전을 알 수 있는 방법이 없다. 이런 설정정보들을 쉽게 확인할 수 있었으면 좋겠다.  \n\n### 지금 필요한 기능과 제약을 정리해보자.  \n처음엔 무작정 덤벼들까도 했지만 침착하게 숨을 고르고 내가 해야할 일을 정리해보았다.    \n* 배포되는 서버환경별로 어플리케이션의 버전정보를 알고 싶다.  \n* 알기 쉽게 endpoint등의 방법으로 버전을 알려주고 싶다.  \n* 모듈이 여러개가 있기 때문에 현재 돌아가고 있는 어플리케이션의 이름정보등 여러가지를 알고 싶다.  \n\n## 프로젝트의 구조를 살펴보자\nspring-boot 로 구성된 프로젝트는 여러개의 모듈로 구성되어 있다. 각 프로젝트별로 기능들을 모아놓고 있으며 jar로 묶여 runnable한 모듈도 있고 common 이나 utils 같이 기능들을 모아놓은 모듈도 있다.  \n프로젝트의 설정은 아래와 같이 구성되어 있다.  \n\n```\n├── README.md\n├── api\n│   ├── README.md\n│   ├── build.gradle\n│   └── src\n├── batch\n│   ├── build.gradle\n│   └── src\n├── build.gradle\n├── common\n│   ├── build.gradle\n│   └── src\n├── elasticsearch\n│   ├── build.gradle\n│   └── src\n├── gradle\n│   └── wrapper\n├── gradlew\n├── gradlew.bat\n├── mongodb\n│   ├── build.gradle\n│   └── src\n├── mysql\n│   ├── build\n│   ├── build.gradle\n│   └── src\n├── redis\n│   ├── build.gradle\n│   └── src\n├── settings.gradle\n└── utils\n    ├── build.gradle\n    └── src\n\n```\nrunnable한 모듈들의 `build.gradle` 에는 각자 버전들이 명시되어 있다. `api` 모듈의 `build.gradle`을 살펴보자.  \n\n```gradle\napply plugin: 'rebel'\napply plugin: 'org.springframework.boot'\n\next {\n    baseName = 'api'\n    version = '9.2.8-SNAPSHOT'\n}\n\ndependencies {\n    compile project(':common')\n    compile project(':mysql')\n    compile project(':mongodb')\n    compile project(':redis')\n    compile project(':utils')\n    compile project(':elasticsearch')\n\n\t...\n}\n\nbootRun {\n    systemProperties System.properties\n}\n```\n\n`ext` 안에 모듈의 이름과 관리되고 있는 버전의 정보가 들어있다. 어떤 기능이 개발되어 질 때는 버전을 먼저 따고 그 버전에 기능들 개발해 넣게 된다. 클라이언트 개발자들과의 소통은 저 버전으로 하게 된다.  \n하지만 빌드를 하면 저 정보는 jar에 따라 오지 않기 때문에 jar파일만 가지고는 버전정보를 알 수가 없다.  \n안되는게 어디있는가 이제부터 저 정보들을 제공하는 방법들을 알아보도록 하자.  \n\n\n## Spring boot actuator\n\nspring boot 에서 제공하고 있는 공식 모듈중에 [spring boot actuator](https://docs.spring.io/spring-boot/docs/current/reference/htmlsingle/#production-ready) 라는 모듈이 있다. 이게 무엇인고 하고 살펴보니 아래와 같이 정의가 되어 있다.  \n\n```\nDefinition of Actuator\n\nAn actuator is a manufacturing term that refers to a mechanical device for moving or controlling something.   \nActuators can generate a large amount of motion from a small change.\n```\n\n여러 정보들을 작은 작업으로 제공해준다니 내가 찾고 있던 것이 틀림없다. 기본적으로 여러 endpoint 들을 제공하고 있고 info 뿐만 아니라 health 나 metrics 등 여러 기능들을 제공하고 있다. 지금 필요한건 버전에 대한 정보들만 표시할 수있으면 되기 때문에 옆길로 새지말고 직진하도록 하자.  \n아무런 설정을 하고 않고 빌드를 하게 되면 build.gradle 에 명시되어 있는 버전 정보들은 빠지고 빌드가 되게 된다. actuator 을 추가해보자.   \n  \n`build.gradle`  \n\n```\n\n// 1 \next {\n   baseName = 'api'\n   version = '9.2.8-SNAPSHOT'\n}\n\ndependencies {\n\t...\n\t// 2\n\tcompile 'org.springframework.boot:spring-boot-starter-actuator'\n}\n\n// 3\nspringBoot{\n    buildInfo {\n        additionalProperties = [\n                'version': \"${project.ext.version}\",\n                'name': \"${project.ext.baseName}\"\n        ]\n    }\n}\n```\n1. `ext`에는 해당 모듈의 이름과 버전 정보가 들어가게 된다. 클라이언트와 QA가 원하는 값은 저 버전 정보이다.   \n2. 모듈을 추가만 해주면 끝이다. 이제 여러 정보들을 endpoint 로 제공받을 수 있다. 하지만 이번 포스팅에서는 다른 기능들을 알아보는건 스킵하도록 한다. (조금 써보았는데 굉장히 많은 정보들을 제공해주고 있다. 나중에 좀 더 깊게 살펴보는게 좋겠다.)   \n3. [buildInfo](https://docs.spring.io/spring-boot/docs/current/reference/htmlsingle/#howto-build-info) 값을 넣어주면 gradle 로 빌드할 때 기본적인 빌드 정보들을 `build-info.properties` 파일 안에 적어주는데 추가적인 정보들을 넣어줄 수 있다.  \n\n이제 빌드를 해서 결과값을 살펴보자. `build/resources/main/META-INF/build-info.properties` 안에 buildInfo의 기본적인 값들과 추가적으로 기술해준 정보들이 아래와 같이 들어가있다.  \n\n`build-info.properties`  \n\n```\n#Properties\n#Sat Mar 24 16:17:58 KST 2018\nbuild.time=2018-03-24T16\\:17\\:58+0900\nbuild.artifact=api\nbuild.group=teddy\nbuild.name=api\nbuild.version=9.2.8\n```\n\n### dev 서버에 배포된 버전은 9.2.8입니다.\n\n값이 잘 들어와있음을 확인했다. 이제 actuator에서 제공하는 endpoint `info`로 이 값들을 확인할 수 있다.  \n\n```shell\n$ > curl localhost:8080/info\n{\n\t\"build\":{\n\t\t\"version\":\"9.2.8-SNAPSHOT\",\n\t\t\"artifact\":\"teddy\",\n\t\t\"name\":\"api\",\n\t\t\"group\":\"com.nevercaution\",\n\t\t\"time\":1521877296000\n\t}\n}\n```\n\n설정과 적용이 완료 되었다. 이제 어느 누가 서버의 버전을 묻는다면 버벅이지 말고 자신있게 버전을 알려주도록 하자.  \n\n\n## 결론\n요즘 [spring boot reference guide](https://docs.spring.io/spring-boot/docs/current/reference/htmlsingle/#production-ready) 를 읽고 있는데 개인적인 느낌으로는 [django document](https://docs.djangoproject.com/en/2.0/) 보다 훨씬 상세하고 직관적으로 문서를 작성해놓았다고 생각한다. ~~django문서보면서 추상적인 표현에 적잖이 당황했었다~~  \n그리고 spring boot starter 에 많은 기능들이 있어 따로 작업해야 하는 부분이 줄어들었고 적용도 간단히 된다.  \n조금 뜬금없는 생각이지만 spring boot 모듈을 한번쯤은 만들어 봐야 겠다는 생각이 들었다.  \n\n\n\n\n\n\n\n","source":"_posts/spring-boot-actuator.md","raw":"---\ntitle: Spring Boot Actuator 를 이용해 버전 정보 제공하기\ncatalog: true\ndate: 2018-03-24 15:23:14\nsubtitle:\nheader-img: \"/img/header_img/bg.png\"\ntags:\n- springboot\n- gradle\n- spring-boot-actuator\n---\n\n### 지금 dev 서버에 배포되어 있는 서버 버전이 몇인가요?\n회사에 서버환경은 dev, sandbox, test, beta, alpha, real 으로 나뉘어 있다. 각 단계별로 기능 테스트를 하고 QA를 통해 모든 기능이 개발 완료 되고 QA도 끝나면 real 서버에 배포가 된다.  \n나와 클라이언트 개발자는 먼저 dev 서버에서 새로운 기능이나 버그 수정등을 테스트 하는데 일정에 쫓길 때는 메이져 버전과 마이너 버전이 동시에 작업되서 두개의 버전을 두고 개발해야 하는 상황이 생기기도 한다.  \n젠킨스를 통해 해당 서버에 어플리케이션을 배포하는데 지금까지는 배포된 버전을 보기 위해선 젠킨스의 배포이력을 찾아 배포된 버전을 찾았어야 했었다. 여간 귀찮은 일이 아닐 수가 없다. 하지만 이 방법밖에는 없으니 얼른 클라이언트 개발자에게 현재 배포된 버전을 찾아서 알려주자.    \n`build.gradle` 에 배포된 버전을 명시해놓고 있긴 하지만 jar로 묶인 패키지에는 버전을 알 수 있는 방법이 없다. 이런 설정정보들을 쉽게 확인할 수 있었으면 좋겠다.  \n\n### 지금 필요한 기능과 제약을 정리해보자.  \n처음엔 무작정 덤벼들까도 했지만 침착하게 숨을 고르고 내가 해야할 일을 정리해보았다.    \n* 배포되는 서버환경별로 어플리케이션의 버전정보를 알고 싶다.  \n* 알기 쉽게 endpoint등의 방법으로 버전을 알려주고 싶다.  \n* 모듈이 여러개가 있기 때문에 현재 돌아가고 있는 어플리케이션의 이름정보등 여러가지를 알고 싶다.  \n\n## 프로젝트의 구조를 살펴보자\nspring-boot 로 구성된 프로젝트는 여러개의 모듈로 구성되어 있다. 각 프로젝트별로 기능들을 모아놓고 있으며 jar로 묶여 runnable한 모듈도 있고 common 이나 utils 같이 기능들을 모아놓은 모듈도 있다.  \n프로젝트의 설정은 아래와 같이 구성되어 있다.  \n\n```\n├── README.md\n├── api\n│   ├── README.md\n│   ├── build.gradle\n│   └── src\n├── batch\n│   ├── build.gradle\n│   └── src\n├── build.gradle\n├── common\n│   ├── build.gradle\n│   └── src\n├── elasticsearch\n│   ├── build.gradle\n│   └── src\n├── gradle\n│   └── wrapper\n├── gradlew\n├── gradlew.bat\n├── mongodb\n│   ├── build.gradle\n│   └── src\n├── mysql\n│   ├── build\n│   ├── build.gradle\n│   └── src\n├── redis\n│   ├── build.gradle\n│   └── src\n├── settings.gradle\n└── utils\n    ├── build.gradle\n    └── src\n\n```\nrunnable한 모듈들의 `build.gradle` 에는 각자 버전들이 명시되어 있다. `api` 모듈의 `build.gradle`을 살펴보자.  \n\n```gradle\napply plugin: 'rebel'\napply plugin: 'org.springframework.boot'\n\next {\n    baseName = 'api'\n    version = '9.2.8-SNAPSHOT'\n}\n\ndependencies {\n    compile project(':common')\n    compile project(':mysql')\n    compile project(':mongodb')\n    compile project(':redis')\n    compile project(':utils')\n    compile project(':elasticsearch')\n\n\t...\n}\n\nbootRun {\n    systemProperties System.properties\n}\n```\n\n`ext` 안에 모듈의 이름과 관리되고 있는 버전의 정보가 들어있다. 어떤 기능이 개발되어 질 때는 버전을 먼저 따고 그 버전에 기능들 개발해 넣게 된다. 클라이언트 개발자들과의 소통은 저 버전으로 하게 된다.  \n하지만 빌드를 하면 저 정보는 jar에 따라 오지 않기 때문에 jar파일만 가지고는 버전정보를 알 수가 없다.  \n안되는게 어디있는가 이제부터 저 정보들을 제공하는 방법들을 알아보도록 하자.  \n\n\n## Spring boot actuator\n\nspring boot 에서 제공하고 있는 공식 모듈중에 [spring boot actuator](https://docs.spring.io/spring-boot/docs/current/reference/htmlsingle/#production-ready) 라는 모듈이 있다. 이게 무엇인고 하고 살펴보니 아래와 같이 정의가 되어 있다.  \n\n```\nDefinition of Actuator\n\nAn actuator is a manufacturing term that refers to a mechanical device for moving or controlling something.   \nActuators can generate a large amount of motion from a small change.\n```\n\n여러 정보들을 작은 작업으로 제공해준다니 내가 찾고 있던 것이 틀림없다. 기본적으로 여러 endpoint 들을 제공하고 있고 info 뿐만 아니라 health 나 metrics 등 여러 기능들을 제공하고 있다. 지금 필요한건 버전에 대한 정보들만 표시할 수있으면 되기 때문에 옆길로 새지말고 직진하도록 하자.  \n아무런 설정을 하고 않고 빌드를 하게 되면 build.gradle 에 명시되어 있는 버전 정보들은 빠지고 빌드가 되게 된다. actuator 을 추가해보자.   \n  \n`build.gradle`  \n\n```\n\n// 1 \next {\n   baseName = 'api'\n   version = '9.2.8-SNAPSHOT'\n}\n\ndependencies {\n\t...\n\t// 2\n\tcompile 'org.springframework.boot:spring-boot-starter-actuator'\n}\n\n// 3\nspringBoot{\n    buildInfo {\n        additionalProperties = [\n                'version': \"${project.ext.version}\",\n                'name': \"${project.ext.baseName}\"\n        ]\n    }\n}\n```\n1. `ext`에는 해당 모듈의 이름과 버전 정보가 들어가게 된다. 클라이언트와 QA가 원하는 값은 저 버전 정보이다.   \n2. 모듈을 추가만 해주면 끝이다. 이제 여러 정보들을 endpoint 로 제공받을 수 있다. 하지만 이번 포스팅에서는 다른 기능들을 알아보는건 스킵하도록 한다. (조금 써보았는데 굉장히 많은 정보들을 제공해주고 있다. 나중에 좀 더 깊게 살펴보는게 좋겠다.)   \n3. [buildInfo](https://docs.spring.io/spring-boot/docs/current/reference/htmlsingle/#howto-build-info) 값을 넣어주면 gradle 로 빌드할 때 기본적인 빌드 정보들을 `build-info.properties` 파일 안에 적어주는데 추가적인 정보들을 넣어줄 수 있다.  \n\n이제 빌드를 해서 결과값을 살펴보자. `build/resources/main/META-INF/build-info.properties` 안에 buildInfo의 기본적인 값들과 추가적으로 기술해준 정보들이 아래와 같이 들어가있다.  \n\n`build-info.properties`  \n\n```\n#Properties\n#Sat Mar 24 16:17:58 KST 2018\nbuild.time=2018-03-24T16\\:17\\:58+0900\nbuild.artifact=api\nbuild.group=teddy\nbuild.name=api\nbuild.version=9.2.8\n```\n\n### dev 서버에 배포된 버전은 9.2.8입니다.\n\n값이 잘 들어와있음을 확인했다. 이제 actuator에서 제공하는 endpoint `info`로 이 값들을 확인할 수 있다.  \n\n```shell\n$ > curl localhost:8080/info\n{\n\t\"build\":{\n\t\t\"version\":\"9.2.8-SNAPSHOT\",\n\t\t\"artifact\":\"teddy\",\n\t\t\"name\":\"api\",\n\t\t\"group\":\"com.nevercaution\",\n\t\t\"time\":1521877296000\n\t}\n}\n```\n\n설정과 적용이 완료 되었다. 이제 어느 누가 서버의 버전을 묻는다면 버벅이지 말고 자신있게 버전을 알려주도록 하자.  \n\n\n## 결론\n요즘 [spring boot reference guide](https://docs.spring.io/spring-boot/docs/current/reference/htmlsingle/#production-ready) 를 읽고 있는데 개인적인 느낌으로는 [django document](https://docs.djangoproject.com/en/2.0/) 보다 훨씬 상세하고 직관적으로 문서를 작성해놓았다고 생각한다. ~~django문서보면서 추상적인 표현에 적잖이 당황했었다~~  \n그리고 spring boot starter 에 많은 기능들이 있어 따로 작업해야 하는 부분이 줄어들었고 적용도 간단히 된다.  \n조금 뜬금없는 생각이지만 spring boot 모듈을 한번쯤은 만들어 봐야 겠다는 생각이 들었다.  \n\n\n\n\n\n\n\n","slug":"spring-boot-actuator","published":1,"updated":"2018-04-15T05:53:54.530Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjq98sopv000e8ghh26s3af46","content":"<h3><span id=\"지금-dev-서버에-배포되어-있는-서버-버전이-몇인가요\">지금 dev 서버에 배포되어 있는 서버 버전이 몇인가요?</span></h3>\n<p>회사에 서버환경은 dev, sandbox, test, beta, alpha, real 으로 나뉘어 있다. 각 단계별로 기능 테스트를 하고 QA를 통해 모든 기능이 개발 완료 되고 QA도 끝나면 real 서버에 배포가 된다.<br>\n나와 클라이언트 개발자는 먼저 dev 서버에서 새로운 기능이나 버그 수정등을 테스트 하는데 일정에 쫓길 때는 메이져 버전과 마이너 버전이 동시에 작업되서 두개의 버전을 두고 개발해야 하는 상황이 생기기도 한다.<br>\n젠킨스를 통해 해당 서버에 어플리케이션을 배포하는데 지금까지는 배포된 버전을 보기 위해선 젠킨스의 배포이력을 찾아 배포된 버전을 찾았어야 했었다. 여간 귀찮은 일이 아닐 수가 없다. 하지만 이 방법밖에는 없으니 얼른 클라이언트 개발자에게 현재 배포된 버전을 찾아서 알려주자.<br>\n<code>build.gradle</code> 에 배포된 버전을 명시해놓고 있긴 하지만 jar로 묶인 패키지에는 버전을 알 수 있는 방법이 없다. 이런 설정정보들을 쉽게 확인할 수 있었으면 좋겠다.</p>\n<h3><span id=\"지금-필요한-기능과-제약을-정리해보자\">지금 필요한 기능과 제약을 정리해보자.</span></h3>\n<p>처음엔 무작정 덤벼들까도 했지만 침착하게 숨을 고르고 내가 해야할 일을 정리해보았다.</p>\n<ul>\n<li>배포되는 서버환경별로 어플리케이션의 버전정보를 알고 싶다.</li>\n<li>알기 쉽게 endpoint등의 방법으로 버전을 알려주고 싶다.</li>\n<li>모듈이 여러개가 있기 때문에 현재 돌아가고 있는 어플리케이션의 이름정보등 여러가지를 알고 싶다.</li>\n</ul>\n<h2><span id=\"프로젝트의-구조를-살펴보자\">프로젝트의 구조를 살펴보자</span></h2>\n<p>spring-boot 로 구성된 프로젝트는 여러개의 모듈로 구성되어 있다. 각 프로젝트별로 기능들을 모아놓고 있으며 jar로 묶여 runnable한 모듈도 있고 common 이나 utils 같이 기능들을 모아놓은 모듈도 있다.<br>\n프로젝트의 설정은 아래와 같이 구성되어 있다.</p>\n<figure class=\"highlight stylus\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">├── README.md</span><br><span class=\"line\">├── api</span><br><span class=\"line\">│   ├── README.md</span><br><span class=\"line\">│   ├── build.gradle</span><br><span class=\"line\">│   └── src</span><br><span class=\"line\">├── batch</span><br><span class=\"line\">│   ├── build.gradle</span><br><span class=\"line\">│   └── src</span><br><span class=\"line\">├── build.gradle</span><br><span class=\"line\">├── common</span><br><span class=\"line\">│   ├── build.gradle</span><br><span class=\"line\">│   └── src</span><br><span class=\"line\">├── elasticsearch</span><br><span class=\"line\">│   ├── build.gradle</span><br><span class=\"line\">│   └── src</span><br><span class=\"line\">├── gradle</span><br><span class=\"line\">│   └── wrapper</span><br><span class=\"line\">├── gradlew</span><br><span class=\"line\">├── gradlew.bat</span><br><span class=\"line\">├── mongodb</span><br><span class=\"line\">│   ├── build.gradle</span><br><span class=\"line\">│   └── src</span><br><span class=\"line\">├── mysql</span><br><span class=\"line\">│   ├── build</span><br><span class=\"line\">│   ├── build.gradle</span><br><span class=\"line\">│   └── src</span><br><span class=\"line\">├── redis</span><br><span class=\"line\">│   ├── build.gradle</span><br><span class=\"line\">│   └── src</span><br><span class=\"line\">├── settings.gradle</span><br><span class=\"line\">└── utils</span><br><span class=\"line\">    ├── build.gradle</span><br><span class=\"line\">    └── src</span><br></pre></td></tr></table></figure>\n<p>runnable한 모듈들의 <code>build.gradle</code> 에는 각자 버전들이 명시되어 있다. <code>api</code> 모듈의 <code>build.gradle</code>을 살펴보자.</p>\n<figure class=\"highlight gradle\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">apply plugin: <span class=\"string\">'rebel'</span></span><br><span class=\"line\">apply plugin: <span class=\"string\">'org.springframework.boot'</span></span><br><span class=\"line\"></span><br><span class=\"line\">ext &#123;</span><br><span class=\"line\">    baseName = <span class=\"string\">'api'</span></span><br><span class=\"line\">    version = <span class=\"string\">'9.2.8-SNAPSHOT'</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">dependencies</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">compile</span> <span class=\"keyword\">project</span>(<span class=\"string\">':common'</span>)</span><br><span class=\"line\">    <span class=\"keyword\">compile</span> <span class=\"keyword\">project</span>(<span class=\"string\">':mysql'</span>)</span><br><span class=\"line\">    <span class=\"keyword\">compile</span> <span class=\"keyword\">project</span>(<span class=\"string\">':mongodb'</span>)</span><br><span class=\"line\">    <span class=\"keyword\">compile</span> <span class=\"keyword\">project</span>(<span class=\"string\">':redis'</span>)</span><br><span class=\"line\">    <span class=\"keyword\">compile</span> <span class=\"keyword\">project</span>(<span class=\"string\">':utils'</span>)</span><br><span class=\"line\">    <span class=\"keyword\">compile</span> <span class=\"keyword\">project</span>(<span class=\"string\">':elasticsearch'</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">\t...</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">bootRun &#123;</span><br><span class=\"line\">    systemProperties System.properties</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><code>ext</code> 안에 모듈의 이름과 관리되고 있는 버전의 정보가 들어있다. 어떤 기능이 개발되어 질 때는 버전을 먼저 따고 그 버전에 기능들 개발해 넣게 된다. 클라이언트 개발자들과의 소통은 저 버전으로 하게 된다.<br>\n하지만 빌드를 하면 저 정보는 jar에 따라 오지 않기 때문에 jar파일만 가지고는 버전정보를 알 수가 없다.<br>\n안되는게 어디있는가 이제부터 저 정보들을 제공하는 방법들을 알아보도록 하자.</p>\n<h2><span id=\"spring-boot-actuator\">Spring boot actuator</span></h2>\n<p>spring boot 에서 제공하고 있는 공식 모듈중에 <a href=\"https://docs.spring.io/spring-boot/docs/current/reference/htmlsingle/#production-ready\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">spring boot actuator</a> 라는 모듈이 있다. 이게 무엇인고 하고 살펴보니 아래와 같이 정의가 되어 있다.</p>\n<figure class=\"highlight livecodeserver\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Definition <span class=\"keyword\">of</span> Actuator</span><br><span class=\"line\"></span><br><span class=\"line\">An actuator is <span class=\"keyword\">a</span> manufacturing term that refers <span class=\"built_in\">to</span> <span class=\"keyword\">a</span> mechanical device <span class=\"keyword\">for</span> moving <span class=\"keyword\">or</span> controlling something.   </span><br><span class=\"line\">Actuators can generate <span class=\"keyword\">a</span> large amount <span class=\"keyword\">of</span> motion <span class=\"built_in\">from</span> <span class=\"keyword\">a</span> small change.</span><br></pre></td></tr></table></figure>\n<p>여러 정보들을 작은 작업으로 제공해준다니 내가 찾고 있던 것이 틀림없다. 기본적으로 여러 endpoint 들을 제공하고 있고 info 뿐만 아니라 health 나 metrics 등 여러 기능들을 제공하고 있다. 지금 필요한건 버전에 대한 정보들만 표시할 수있으면 되기 때문에 옆길로 새지말고 직진하도록 하자.<br>\n아무런 설정을 하고 않고 빌드를 하게 되면 build.gradle 에 명시되어 있는 버전 정보들은 빠지고 빌드가 되게 된다. actuator 을 추가해보자.</p>\n<p><code>build.gradle</code></p>\n<figure class=\"highlight gradle\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 1 </span></span><br><span class=\"line\">ext &#123;</span><br><span class=\"line\">   baseName = <span class=\"string\">'api'</span></span><br><span class=\"line\">   version = <span class=\"string\">'9.2.8-SNAPSHOT'</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">dependencies</span> &#123;</span><br><span class=\"line\">\t...</span><br><span class=\"line\">\t<span class=\"comment\">// 2</span></span><br><span class=\"line\">\t<span class=\"keyword\">compile</span> <span class=\"string\">'org.springframework.boot:spring-boot-starter-actuator'</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 3</span></span><br><span class=\"line\">springBoot&#123;</span><br><span class=\"line\">    buildInfo &#123;</span><br><span class=\"line\">        additionalProperties = [</span><br><span class=\"line\">                <span class=\"string\">'version'</span>: <span class=\"string\">\"$&#123;project.ext.version&#125;\"</span>,</span><br><span class=\"line\">                <span class=\"string\">'name'</span>: <span class=\"string\">\"$&#123;project.ext.baseName&#125;\"</span></span><br><span class=\"line\">        ]</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ol>\n<li><code>ext</code>에는 해당 모듈의 이름과 버전 정보가 들어가게 된다. 클라이언트와 QA가 원하는 값은 저 버전 정보이다.</li>\n<li>모듈을 추가만 해주면 끝이다. 이제 여러 정보들을 endpoint 로 제공받을 수 있다. 하지만 이번 포스팅에서는 다른 기능들을 알아보는건 스킵하도록 한다. (조금 써보았는데 굉장히 많은 정보들을 제공해주고 있다. 나중에 좀 더 깊게 살펴보는게 좋겠다.)</li>\n<li><a href=\"https://docs.spring.io/spring-boot/docs/current/reference/htmlsingle/#howto-build-info\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">buildInfo</a> 값을 넣어주면 gradle 로 빌드할 때 기본적인 빌드 정보들을 <code>build-info.properties</code> 파일 안에 적어주는데 추가적인 정보들을 넣어줄 수 있다.</li>\n</ol>\n<p>이제 빌드를 해서 결과값을 살펴보자. <code>build/resources/main/META-INF/build-info.properties</code> 안에 buildInfo의 기본적인 값들과 추가적으로 기술해준 정보들이 아래와 같이 들어가있다.</p>\n<p><code>build-info.properties</code></p>\n<figure class=\"highlight routeros\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">#Properties</span></span><br><span class=\"line\"><span class=\"comment\">#Sat Mar 24 16:17:58 KST 2018</span></span><br><span class=\"line\">build.<span class=\"attribute\">time</span>=2018-03-24T16\\:17\\:58+0900</span><br><span class=\"line\">build.<span class=\"attribute\">artifact</span>=api</span><br><span class=\"line\">build.<span class=\"attribute\">group</span>=teddy</span><br><span class=\"line\">build.<span class=\"attribute\">name</span>=api</span><br><span class=\"line\">build.<span class=\"attribute\">version</span>=9.2.8</span><br></pre></td></tr></table></figure>\n<h3><span id=\"dev-서버에-배포된-버전은-928입니다\">dev 서버에 배포된 버전은 9.2.8입니다.</span></h3>\n<p>값이 잘 들어와있음을 확인했다. 이제 actuator에서 제공하는 endpoint <code>info</code>로 이 값들을 확인할 수 있다.</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> &gt; curl localhost:8080/info</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t\"build\":&#123;</span><br><span class=\"line\">\t\t\"version\":\"9.2.8-SNAPSHOT\",</span><br><span class=\"line\">\t\t\"artifact\":\"teddy\",</span><br><span class=\"line\">\t\t\"name\":\"api\",</span><br><span class=\"line\">\t\t\"group\":\"com.nevercaution\",</span><br><span class=\"line\">\t\t\"time\":1521877296000</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>설정과 적용이 완료 되었다. 이제 어느 누가 서버의 버전을 묻는다면 버벅이지 말고 자신있게 버전을 알려주도록 하자.</p>\n<h2><span id=\"결론\">결론</span></h2>\n<p>요즘 <a href=\"https://docs.spring.io/spring-boot/docs/current/reference/htmlsingle/#production-ready\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">spring boot reference guide</a> 를 읽고 있는데 개인적인 느낌으로는 <a href=\"https://docs.djangoproject.com/en/2.0/\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">django document</a> 보다 훨씬 상세하고 직관적으로 문서를 작성해놓았다고 생각한다. <s>django문서보면서 추상적인 표현에 적잖이 당황했었다</s><br>\n그리고 spring boot starter 에 많은 기능들이 있어 따로 작업해야 하는 부분이 줄어들었고 적용도 간단히 된다.<br>\n조금 뜬금없는 생각이지만 spring boot 모듈을 한번쯤은 만들어 봐야 겠다는 생각이 들었다.</p>\n","site":{"data":{}},"excerpt":"","more":"<h3>지금 dev 서버에 배포되어 있는 서버 버전이 몇인가요?</h3>\n<p>회사에 서버환경은 dev, sandbox, test, beta, alpha, real 으로 나뉘어 있다. 각 단계별로 기능 테스트를 하고 QA를 통해 모든 기능이 개발 완료 되고 QA도 끝나면 real 서버에 배포가 된다.<br>\n나와 클라이언트 개발자는 먼저 dev 서버에서 새로운 기능이나 버그 수정등을 테스트 하는데 일정에 쫓길 때는 메이져 버전과 마이너 버전이 동시에 작업되서 두개의 버전을 두고 개발해야 하는 상황이 생기기도 한다.<br>\n젠킨스를 통해 해당 서버에 어플리케이션을 배포하는데 지금까지는 배포된 버전을 보기 위해선 젠킨스의 배포이력을 찾아 배포된 버전을 찾았어야 했었다. 여간 귀찮은 일이 아닐 수가 없다. 하지만 이 방법밖에는 없으니 얼른 클라이언트 개발자에게 현재 배포된 버전을 찾아서 알려주자.<br>\n<code>build.gradle</code> 에 배포된 버전을 명시해놓고 있긴 하지만 jar로 묶인 패키지에는 버전을 알 수 있는 방법이 없다. 이런 설정정보들을 쉽게 확인할 수 있었으면 좋겠다.</p>\n<h3>지금 필요한 기능과 제약을 정리해보자.</h3>\n<p>처음엔 무작정 덤벼들까도 했지만 침착하게 숨을 고르고 내가 해야할 일을 정리해보았다.</p>\n<ul>\n<li>배포되는 서버환경별로 어플리케이션의 버전정보를 알고 싶다.</li>\n<li>알기 쉽게 endpoint등의 방법으로 버전을 알려주고 싶다.</li>\n<li>모듈이 여러개가 있기 때문에 현재 돌아가고 있는 어플리케이션의 이름정보등 여러가지를 알고 싶다.</li>\n</ul>\n<h2>프로젝트의 구조를 살펴보자</h2>\n<p>spring-boot 로 구성된 프로젝트는 여러개의 모듈로 구성되어 있다. 각 프로젝트별로 기능들을 모아놓고 있으며 jar로 묶여 runnable한 모듈도 있고 common 이나 utils 같이 기능들을 모아놓은 모듈도 있다.<br>\n프로젝트의 설정은 아래와 같이 구성되어 있다.</p>\n<figure class=\"highlight stylus\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">├── README.md</span><br><span class=\"line\">├── api</span><br><span class=\"line\">│   ├── README.md</span><br><span class=\"line\">│   ├── build.gradle</span><br><span class=\"line\">│   └── src</span><br><span class=\"line\">├── batch</span><br><span class=\"line\">│   ├── build.gradle</span><br><span class=\"line\">│   └── src</span><br><span class=\"line\">├── build.gradle</span><br><span class=\"line\">├── common</span><br><span class=\"line\">│   ├── build.gradle</span><br><span class=\"line\">│   └── src</span><br><span class=\"line\">├── elasticsearch</span><br><span class=\"line\">│   ├── build.gradle</span><br><span class=\"line\">│   └── src</span><br><span class=\"line\">├── gradle</span><br><span class=\"line\">│   └── wrapper</span><br><span class=\"line\">├── gradlew</span><br><span class=\"line\">├── gradlew.bat</span><br><span class=\"line\">├── mongodb</span><br><span class=\"line\">│   ├── build.gradle</span><br><span class=\"line\">│   └── src</span><br><span class=\"line\">├── mysql</span><br><span class=\"line\">│   ├── build</span><br><span class=\"line\">│   ├── build.gradle</span><br><span class=\"line\">│   └── src</span><br><span class=\"line\">├── redis</span><br><span class=\"line\">│   ├── build.gradle</span><br><span class=\"line\">│   └── src</span><br><span class=\"line\">├── settings.gradle</span><br><span class=\"line\">└── utils</span><br><span class=\"line\">    ├── build.gradle</span><br><span class=\"line\">    └── src</span><br></pre></td></tr></table></figure>\n<p>runnable한 모듈들의 <code>build.gradle</code> 에는 각자 버전들이 명시되어 있다. <code>api</code> 모듈의 <code>build.gradle</code>을 살펴보자.</p>\n<figure class=\"highlight gradle\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">apply plugin: <span class=\"string\">'rebel'</span></span><br><span class=\"line\">apply plugin: <span class=\"string\">'org.springframework.boot'</span></span><br><span class=\"line\"></span><br><span class=\"line\">ext &#123;</span><br><span class=\"line\">    baseName = <span class=\"string\">'api'</span></span><br><span class=\"line\">    version = <span class=\"string\">'9.2.8-SNAPSHOT'</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">dependencies</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">compile</span> <span class=\"keyword\">project</span>(<span class=\"string\">':common'</span>)</span><br><span class=\"line\">    <span class=\"keyword\">compile</span> <span class=\"keyword\">project</span>(<span class=\"string\">':mysql'</span>)</span><br><span class=\"line\">    <span class=\"keyword\">compile</span> <span class=\"keyword\">project</span>(<span class=\"string\">':mongodb'</span>)</span><br><span class=\"line\">    <span class=\"keyword\">compile</span> <span class=\"keyword\">project</span>(<span class=\"string\">':redis'</span>)</span><br><span class=\"line\">    <span class=\"keyword\">compile</span> <span class=\"keyword\">project</span>(<span class=\"string\">':utils'</span>)</span><br><span class=\"line\">    <span class=\"keyword\">compile</span> <span class=\"keyword\">project</span>(<span class=\"string\">':elasticsearch'</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">\t...</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">bootRun &#123;</span><br><span class=\"line\">    systemProperties System.properties</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><code>ext</code> 안에 모듈의 이름과 관리되고 있는 버전의 정보가 들어있다. 어떤 기능이 개발되어 질 때는 버전을 먼저 따고 그 버전에 기능들 개발해 넣게 된다. 클라이언트 개발자들과의 소통은 저 버전으로 하게 된다.<br>\n하지만 빌드를 하면 저 정보는 jar에 따라 오지 않기 때문에 jar파일만 가지고는 버전정보를 알 수가 없다.<br>\n안되는게 어디있는가 이제부터 저 정보들을 제공하는 방법들을 알아보도록 하자.</p>\n<h2>Spring boot actuator</h2>\n<p>spring boot 에서 제공하고 있는 공식 모듈중에 <a href=\"https://docs.spring.io/spring-boot/docs/current/reference/htmlsingle/#production-ready\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">spring boot actuator</a> 라는 모듈이 있다. 이게 무엇인고 하고 살펴보니 아래와 같이 정의가 되어 있다.</p>\n<figure class=\"highlight livecodeserver\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Definition <span class=\"keyword\">of</span> Actuator</span><br><span class=\"line\"></span><br><span class=\"line\">An actuator is <span class=\"keyword\">a</span> manufacturing term that refers <span class=\"built_in\">to</span> <span class=\"keyword\">a</span> mechanical device <span class=\"keyword\">for</span> moving <span class=\"keyword\">or</span> controlling something.   </span><br><span class=\"line\">Actuators can generate <span class=\"keyword\">a</span> large amount <span class=\"keyword\">of</span> motion <span class=\"built_in\">from</span> <span class=\"keyword\">a</span> small change.</span><br></pre></td></tr></table></figure>\n<p>여러 정보들을 작은 작업으로 제공해준다니 내가 찾고 있던 것이 틀림없다. 기본적으로 여러 endpoint 들을 제공하고 있고 info 뿐만 아니라 health 나 metrics 등 여러 기능들을 제공하고 있다. 지금 필요한건 버전에 대한 정보들만 표시할 수있으면 되기 때문에 옆길로 새지말고 직진하도록 하자.<br>\n아무런 설정을 하고 않고 빌드를 하게 되면 build.gradle 에 명시되어 있는 버전 정보들은 빠지고 빌드가 되게 된다. actuator 을 추가해보자.</p>\n<p><code>build.gradle</code></p>\n<figure class=\"highlight gradle\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 1 </span></span><br><span class=\"line\">ext &#123;</span><br><span class=\"line\">   baseName = <span class=\"string\">'api'</span></span><br><span class=\"line\">   version = <span class=\"string\">'9.2.8-SNAPSHOT'</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">dependencies</span> &#123;</span><br><span class=\"line\">\t...</span><br><span class=\"line\">\t<span class=\"comment\">// 2</span></span><br><span class=\"line\">\t<span class=\"keyword\">compile</span> <span class=\"string\">'org.springframework.boot:spring-boot-starter-actuator'</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 3</span></span><br><span class=\"line\">springBoot&#123;</span><br><span class=\"line\">    buildInfo &#123;</span><br><span class=\"line\">        additionalProperties = [</span><br><span class=\"line\">                <span class=\"string\">'version'</span>: <span class=\"string\">\"$&#123;project.ext.version&#125;\"</span>,</span><br><span class=\"line\">                <span class=\"string\">'name'</span>: <span class=\"string\">\"$&#123;project.ext.baseName&#125;\"</span></span><br><span class=\"line\">        ]</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ol>\n<li><code>ext</code>에는 해당 모듈의 이름과 버전 정보가 들어가게 된다. 클라이언트와 QA가 원하는 값은 저 버전 정보이다.</li>\n<li>모듈을 추가만 해주면 끝이다. 이제 여러 정보들을 endpoint 로 제공받을 수 있다. 하지만 이번 포스팅에서는 다른 기능들을 알아보는건 스킵하도록 한다. (조금 써보았는데 굉장히 많은 정보들을 제공해주고 있다. 나중에 좀 더 깊게 살펴보는게 좋겠다.)</li>\n<li><a href=\"https://docs.spring.io/spring-boot/docs/current/reference/htmlsingle/#howto-build-info\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">buildInfo</a> 값을 넣어주면 gradle 로 빌드할 때 기본적인 빌드 정보들을 <code>build-info.properties</code> 파일 안에 적어주는데 추가적인 정보들을 넣어줄 수 있다.</li>\n</ol>\n<p>이제 빌드를 해서 결과값을 살펴보자. <code>build/resources/main/META-INF/build-info.properties</code> 안에 buildInfo의 기본적인 값들과 추가적으로 기술해준 정보들이 아래와 같이 들어가있다.</p>\n<p><code>build-info.properties</code></p>\n<figure class=\"highlight routeros\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">#Properties</span></span><br><span class=\"line\"><span class=\"comment\">#Sat Mar 24 16:17:58 KST 2018</span></span><br><span class=\"line\">build.<span class=\"attribute\">time</span>=2018-03-24T16\\:17\\:58+0900</span><br><span class=\"line\">build.<span class=\"attribute\">artifact</span>=api</span><br><span class=\"line\">build.<span class=\"attribute\">group</span>=teddy</span><br><span class=\"line\">build.<span class=\"attribute\">name</span>=api</span><br><span class=\"line\">build.<span class=\"attribute\">version</span>=9.2.8</span><br></pre></td></tr></table></figure>\n<h3>dev 서버에 배포된 버전은 9.2.8입니다.</h3>\n<p>값이 잘 들어와있음을 확인했다. 이제 actuator에서 제공하는 endpoint <code>info</code>로 이 값들을 확인할 수 있다.</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> &gt; curl localhost:8080/info</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t\"build\":&#123;</span><br><span class=\"line\">\t\t\"version\":\"9.2.8-SNAPSHOT\",</span><br><span class=\"line\">\t\t\"artifact\":\"teddy\",</span><br><span class=\"line\">\t\t\"name\":\"api\",</span><br><span class=\"line\">\t\t\"group\":\"com.nevercaution\",</span><br><span class=\"line\">\t\t\"time\":1521877296000</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>설정과 적용이 완료 되었다. 이제 어느 누가 서버의 버전을 묻는다면 버벅이지 말고 자신있게 버전을 알려주도록 하자.</p>\n<h2>결론</h2>\n<p>요즘 <a href=\"https://docs.spring.io/spring-boot/docs/current/reference/htmlsingle/#production-ready\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">spring boot reference guide</a> 를 읽고 있는데 개인적인 느낌으로는 <a href=\"https://docs.djangoproject.com/en/2.0/\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">django document</a> 보다 훨씬 상세하고 직관적으로 문서를 작성해놓았다고 생각한다. <s>django문서보면서 추상적인 표현에 적잖이 당황했었다</s><br>\n그리고 spring boot starter 에 많은 기능들이 있어 따로 작업해야 하는 부분이 줄어들었고 적용도 간단히 된다.<br>\n조금 뜬금없는 생각이지만 spring boot 모듈을 한번쯤은 만들어 봐야 겠다는 생각이 들었다.</p>\n"},{"title":"Spring boot Custom Annotation 사용하기","catalog":true,"date":"2018-04-15T05:51:10.000Z","subtitle":null,"header-img":"/img/header_img/bg.png","_content":"\n### 썰의 시작\n회사에서 msa 를 눈여겨 보면서 하나로 합쳐져 있는 거대한 프로젝트를 각각 쪼개려는 시도들을 하고 있다. 일에 치여 마음속에서만 맴돌고 있다가 최근에 새로운 기능을 추가해야할 일이 생겨 이때다 싶어 과감히 프로젝트를 쪼개서 작업해보기로 했다.   \n기존에 있던 api server 와 internal 호출을 하면서 데이터를 주고받는 작은 api service 이다. view 가 없기 때문에 Restful 하게 만들었다. (~~내가 front 작업이 약해서는 아니다!~~)  \n새로 추가된 서비스(`mini api server` 라고 하자)에서만 사용하는 테이블들이 있고, 기존 `api server` 는 `mini api server` 과 통신을 해서 해당 정보들에 대한 CRUD 를 할 수 있다.  \n최대한 기존 서비스와는 별도로 작업을 하고자 했고 추후에 물리 디비가 나뉘어도 큰 작업없이 옮겨갈 수 있도록 결합도를 낮추고자 했다.  \nuser 에 대한 데이터는 sharding 되어있고 현재는 디비를 같은 곳에 사용하고 있기 때문에 같은 sharding 전략을 가져가야 한다.  \n\nannotation 얘기를 해야하는데 갑자기 엉뚱한 소리가 나왔네라고 생각할지도 모른다. 결론적으로 내가 해야할 일은 user 가 어느 shard 번호를 배정받았는지를 알아야 한다. 이 작업을 annotation 을 이용해서 유려하게 처리해도록 하자.   \n  \n\n\n## 구현목표  \ncontroller 에서 `@RequestParam` 으로 받은 값중에 특정값은 데이터가 sharding 처리가 되어 있어 각 repository 에서는 각 분배되어 있는 데이터를 잘 조회하기 위해 해당 디비번호를 설정해주어야 한다. 내가 구현해야할 일을 정리해보자. \n \n* user_uid 값은 sharding 처리가 되어 있다.  \n* 사용자는 user 가 어느 디비에 sharding 이 되어있는지 모른다.  \n* repository 에서는 각 분배가 되어 있는 디비에 접근을 해야한다.  \n\n이런 상황에서의 해결법은 여러가지가 있다. 간단하게 처리할 수도, 복잡하게 처리할 수도 있다.    \n하나씩 정리하면서 넘어가도록 하자.  \n\n## 개발 컨셉  \nshard 번호를 처리를 해야한다고 할 때 두가지 방법으로 처리할 수 있다.  \n\n* 사용자가 api 콜을 할 때 shard 번호를 함께 넘겨받는다.  \n* shard 번호가 배정되어 있는 디비에 해당 사용자의 번호를 가져온다.  \n\n### shard 번호 넘겨받기  \n전자의 경우에는 `new api server` 에서 shard 번호를 알고 있을 필요가 없기 때문에 아무런 처리없이 해당 shard 번호를 세팅해주면 된다.    \n현재는 물리디비가 함께 있으므로 이렇게 처리해도 큰 문제가 없다. user 데이터가 같은 디비에 있어 shard 번호만 받으면 동일한 번호에 데이터가 있기 때문이다. 하지만 추후에 디비가 나뉘어져서 shard 전략이 다르게 될 때는 문제가 된다. `api server` 에서는 1번 shard 인데 new api server 에서는 2번 shard 번호를 배정받을 수 있기 때문이다. 이런 이유로 후자의 방법으로 방향을 잡게 되었다.   \n\n### shard 번호 찾아가기\nshard 번호를 `mini api server` 에서 찾아가는 방법도 여러가지가 있다.  \n* 별도의 service 를 만들어 명시적으로 호출해줘 값을 지정한다.  \n* 상위 cnotroller 를 만들어 전체 controller 는 부모 controller 를 상속받아 부모에서 처리한다 (기존 `api server` 방식)  \n* interceptor, annotation 를 이용해 controller 전처리  \n\n1, 2 번의 경우 각 api 호출별로 명시적으로 호출해서 처리할 수 있다. 다만 사용자가 모든 api 에 호출을 해주어야 하는 단점이 있고, 일단 마음에 들지 않는다. user 정보를 조회하는 api 에 모두 같은 로직을 넣어주어야 하기 때문에 코드 중복이 생기고 만약 실수로 코드를 넣지 않았다면 의도치 않은 에러를 발생할 수 있다. 최대한 중복코드를 줄이면서 사용자가 사용하기 편하게 하기 위해 annotation 을 사용해서 처리해보자.  \n\n## custom annotation\n최종결과물부터 보면 다음과 같다. `@RequestParam` 을 사용하지 않고 `@RequestCustomParam` 을 이용한다. 이 annotation 을 붙여두면 알아서 shard 정보를 조회해서 DataSource 에 세팅하고 결과값을 Integer 값으로 반환받아 비지니스 로직에서 사용할 수 있다.   \n\n`FirstController`  \n\n```java\n@RestController\npublic class FirstController {\n\n    @RequestMapping(value = \"/\", method = RequestMethod.GET)\n    public String index(@RequestCustomParam(value = \"uid\") Integer uid) {\n    }\n}\n```\n\n자 이게 가능하게 하기 위해서 하나씩 처리과정을 따라가보자.  \n  \n```\n.\n├── TeddyApplication.java\n├── annotation\n│   └── RequestCustomParam.java\n├── config\n│   └── InterceptConfig.java\n├── controller\n│   └── FirstController.java\n└── handler\n    └── CustomResolver.java\n  \n```\n\n1. `RequestCustomParam` 을 생성   \n2. `InterceptConfig` 에서 customResolver 를 등록    \n3. `CustomResolver` 에서 `RequestCustomParam` 여부를 검사해 필요한 로직 실행    \n4. `FirstController` 에서 필요한 param 값에 `@RequestCustomParam` 로 등록을 하고, 전처리 후 shard 세팅이 된 uid 정보 이용    \n  \n  \n### 하나씩 살펴보자\n하나씩 뜯어보면 그리 어렵지 않다. 대체 어떻게 동작하는 것일까.  \n\n`RequestCustomParam`   \n\n```java\n@Target({ElementType.PARAMETER})\n@Retention(RetentionPolicy.RUNTIME)\npublic @interface RequestCustomParam {\n\n    String value() default \"\";\n}\n\n```\n\nvalue 만 갖고 있으면 되고 다른 설정들은 일단 사용하지 않아서 `RequestParam` 에서 필요한 값만 가져왔다. 주목해야할 점은 Target 과 Retention 이다. Parameter 타입을 이용해 처리하고 RunTime 까지 annotation 을 가져가서 처리하도록 했다.  \n\n`InterceptConfig`  \n\n```java\n@Configuration\npublic class InterceptConfig implements WebMvcConfigurer {\n\n    @Override\n    public void addArgumentResolvers(List<HandlerMethodArgumentResolver> resolvers) {\n        resolvers.add(getCustomResolver());\n    }\n\n    @Bean\n    public CustomResolver getCustomResolver() {\n        return new CustomResolver();\n    }\n}\n```\n\n`WebMvcConfigurer` 를 붙여서 내가 생성한 resolver bean 을 등록해준다. \n\n`CustomResolver`  \n\n```java\n@Configuration\npublic class CustomResolver implements HandlerMethodArgumentResolver {\n\n    @Override\n    public boolean supportsParameter(MethodParameter parameter) {\n        return parameter.hasParameterAnnotation(RequestCustomParam.class);\n    }\n\n    @Override\n    public Integer resolveArgument(MethodParameter parameter, ModelAndViewContainer mavContainer, NativeWebRequest webRequest, WebDataBinderFactory binderFactory) throws Exception {\n\n        RequestCustomParam customParam = parameter.getParameterAnnotation(RequestCustomParam.class);\n        String value = webRequest.getParameter(customParam.value());\n        // do something\n        return Integer.valueOf(value);\n    }\n}\n```\n  \n핵심이 되는 부분이다. `RequestCustomParam` 가 포함되어 있는지 여부를 검사해서 annotation 이 등록되어 있는 request 만 통과를 시킨다. 그리고 사용자가 등록한 value 값을 뽑아와서 필요한 로직처리를 해주면 된다.  \n`// do sonething` 부분에서 shard 를 찾아가는 로직을 추가해주도록 하자.  \n전처리가 끝나면 controller 에서 uid 값을 이용해 비지니스 로직을 수행해야 하기 때문에 value 로 뽑아온 값을 다시 돌려준다.  \n여기서 참고할 부분은 parameter 로 뽑아온 값은 무조건 String 타입으로 반환된다. 각자 필요한 타입으로 변환해서 사용하도록 하자.  \n(아마 일반적으로 처리하기 위해 String 으로만 반환받게 한듯 싶다. 여러 타입으로 반환하는 것보다 처리가 간단하고 여러 타입으로 변환하는 작업 자체가 불필요하다고 느꼈을까)  \n신경써야할 부분이 있다면 `parameter.getParameterAnnotation`, `webRequest.getParameter` 은 `@Nullable` 이기 때문에 NPE 처리를 해주면 좋다.  \n\n이제 필요한 부분에만 `@RequestCustomParam(value = \"uid\") Integer uid` 으로 명시해서 처리하면 사용자는 sharding 에 대한 로직을 신경쓰지 않아도 된다.  \n별도의 service 로 나누어 처리하는 것보다 명시적이고 중복코드 없이 간단하게 처리할 수 있다.  \n\n\n## 결론\n지금까지 작업한 전체 코드는 [여기](https://github.com/nevercaution/customAnnotation) 에서 확인할 수 있다.  \nannotation 을 사용하면 특정 로직들은 뒤에서 처리되기 때문에 관심을 갖지 않고 보면 어떻게 동작하는지 이해하기 힘들다. 반대로 annotation 에 대한 이해가 있으면 코드는 훨씬 간결해지고 직관적으로 처리할 수 있게 된다. 이전까지는 annotation 은 알아서 동작하겠지 하며 큰 신경을 쓰고 있지 않았었는데, 직접 사용해보니 기존의 로직을 좀 더 깔끔하게 처리할 수 있다는 부분이 마음에 든다.  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","source":"_posts/spring-boot-custom-annotation.md","raw":"---\ntitle: Spring boot Custom Annotation 사용하기  \ncatalog: true\ndate: 2018-04-15 14:51:10\nsubtitle:\nheader-img: \"/img/header_img/bg.png\"\ntags:\n- springboot\n- annotation\n- argumentresolver\n---\n\n### 썰의 시작\n회사에서 msa 를 눈여겨 보면서 하나로 합쳐져 있는 거대한 프로젝트를 각각 쪼개려는 시도들을 하고 있다. 일에 치여 마음속에서만 맴돌고 있다가 최근에 새로운 기능을 추가해야할 일이 생겨 이때다 싶어 과감히 프로젝트를 쪼개서 작업해보기로 했다.   \n기존에 있던 api server 와 internal 호출을 하면서 데이터를 주고받는 작은 api service 이다. view 가 없기 때문에 Restful 하게 만들었다. (~~내가 front 작업이 약해서는 아니다!~~)  \n새로 추가된 서비스(`mini api server` 라고 하자)에서만 사용하는 테이블들이 있고, 기존 `api server` 는 `mini api server` 과 통신을 해서 해당 정보들에 대한 CRUD 를 할 수 있다.  \n최대한 기존 서비스와는 별도로 작업을 하고자 했고 추후에 물리 디비가 나뉘어도 큰 작업없이 옮겨갈 수 있도록 결합도를 낮추고자 했다.  \nuser 에 대한 데이터는 sharding 되어있고 현재는 디비를 같은 곳에 사용하고 있기 때문에 같은 sharding 전략을 가져가야 한다.  \n\nannotation 얘기를 해야하는데 갑자기 엉뚱한 소리가 나왔네라고 생각할지도 모른다. 결론적으로 내가 해야할 일은 user 가 어느 shard 번호를 배정받았는지를 알아야 한다. 이 작업을 annotation 을 이용해서 유려하게 처리해도록 하자.   \n  \n\n\n## 구현목표  \ncontroller 에서 `@RequestParam` 으로 받은 값중에 특정값은 데이터가 sharding 처리가 되어 있어 각 repository 에서는 각 분배되어 있는 데이터를 잘 조회하기 위해 해당 디비번호를 설정해주어야 한다. 내가 구현해야할 일을 정리해보자. \n \n* user_uid 값은 sharding 처리가 되어 있다.  \n* 사용자는 user 가 어느 디비에 sharding 이 되어있는지 모른다.  \n* repository 에서는 각 분배가 되어 있는 디비에 접근을 해야한다.  \n\n이런 상황에서의 해결법은 여러가지가 있다. 간단하게 처리할 수도, 복잡하게 처리할 수도 있다.    \n하나씩 정리하면서 넘어가도록 하자.  \n\n## 개발 컨셉  \nshard 번호를 처리를 해야한다고 할 때 두가지 방법으로 처리할 수 있다.  \n\n* 사용자가 api 콜을 할 때 shard 번호를 함께 넘겨받는다.  \n* shard 번호가 배정되어 있는 디비에 해당 사용자의 번호를 가져온다.  \n\n### shard 번호 넘겨받기  \n전자의 경우에는 `new api server` 에서 shard 번호를 알고 있을 필요가 없기 때문에 아무런 처리없이 해당 shard 번호를 세팅해주면 된다.    \n현재는 물리디비가 함께 있으므로 이렇게 처리해도 큰 문제가 없다. user 데이터가 같은 디비에 있어 shard 번호만 받으면 동일한 번호에 데이터가 있기 때문이다. 하지만 추후에 디비가 나뉘어져서 shard 전략이 다르게 될 때는 문제가 된다. `api server` 에서는 1번 shard 인데 new api server 에서는 2번 shard 번호를 배정받을 수 있기 때문이다. 이런 이유로 후자의 방법으로 방향을 잡게 되었다.   \n\n### shard 번호 찾아가기\nshard 번호를 `mini api server` 에서 찾아가는 방법도 여러가지가 있다.  \n* 별도의 service 를 만들어 명시적으로 호출해줘 값을 지정한다.  \n* 상위 cnotroller 를 만들어 전체 controller 는 부모 controller 를 상속받아 부모에서 처리한다 (기존 `api server` 방식)  \n* interceptor, annotation 를 이용해 controller 전처리  \n\n1, 2 번의 경우 각 api 호출별로 명시적으로 호출해서 처리할 수 있다. 다만 사용자가 모든 api 에 호출을 해주어야 하는 단점이 있고, 일단 마음에 들지 않는다. user 정보를 조회하는 api 에 모두 같은 로직을 넣어주어야 하기 때문에 코드 중복이 생기고 만약 실수로 코드를 넣지 않았다면 의도치 않은 에러를 발생할 수 있다. 최대한 중복코드를 줄이면서 사용자가 사용하기 편하게 하기 위해 annotation 을 사용해서 처리해보자.  \n\n## custom annotation\n최종결과물부터 보면 다음과 같다. `@RequestParam` 을 사용하지 않고 `@RequestCustomParam` 을 이용한다. 이 annotation 을 붙여두면 알아서 shard 정보를 조회해서 DataSource 에 세팅하고 결과값을 Integer 값으로 반환받아 비지니스 로직에서 사용할 수 있다.   \n\n`FirstController`  \n\n```java\n@RestController\npublic class FirstController {\n\n    @RequestMapping(value = \"/\", method = RequestMethod.GET)\n    public String index(@RequestCustomParam(value = \"uid\") Integer uid) {\n    }\n}\n```\n\n자 이게 가능하게 하기 위해서 하나씩 처리과정을 따라가보자.  \n  \n```\n.\n├── TeddyApplication.java\n├── annotation\n│   └── RequestCustomParam.java\n├── config\n│   └── InterceptConfig.java\n├── controller\n│   └── FirstController.java\n└── handler\n    └── CustomResolver.java\n  \n```\n\n1. `RequestCustomParam` 을 생성   \n2. `InterceptConfig` 에서 customResolver 를 등록    \n3. `CustomResolver` 에서 `RequestCustomParam` 여부를 검사해 필요한 로직 실행    \n4. `FirstController` 에서 필요한 param 값에 `@RequestCustomParam` 로 등록을 하고, 전처리 후 shard 세팅이 된 uid 정보 이용    \n  \n  \n### 하나씩 살펴보자\n하나씩 뜯어보면 그리 어렵지 않다. 대체 어떻게 동작하는 것일까.  \n\n`RequestCustomParam`   \n\n```java\n@Target({ElementType.PARAMETER})\n@Retention(RetentionPolicy.RUNTIME)\npublic @interface RequestCustomParam {\n\n    String value() default \"\";\n}\n\n```\n\nvalue 만 갖고 있으면 되고 다른 설정들은 일단 사용하지 않아서 `RequestParam` 에서 필요한 값만 가져왔다. 주목해야할 점은 Target 과 Retention 이다. Parameter 타입을 이용해 처리하고 RunTime 까지 annotation 을 가져가서 처리하도록 했다.  \n\n`InterceptConfig`  \n\n```java\n@Configuration\npublic class InterceptConfig implements WebMvcConfigurer {\n\n    @Override\n    public void addArgumentResolvers(List<HandlerMethodArgumentResolver> resolvers) {\n        resolvers.add(getCustomResolver());\n    }\n\n    @Bean\n    public CustomResolver getCustomResolver() {\n        return new CustomResolver();\n    }\n}\n```\n\n`WebMvcConfigurer` 를 붙여서 내가 생성한 resolver bean 을 등록해준다. \n\n`CustomResolver`  \n\n```java\n@Configuration\npublic class CustomResolver implements HandlerMethodArgumentResolver {\n\n    @Override\n    public boolean supportsParameter(MethodParameter parameter) {\n        return parameter.hasParameterAnnotation(RequestCustomParam.class);\n    }\n\n    @Override\n    public Integer resolveArgument(MethodParameter parameter, ModelAndViewContainer mavContainer, NativeWebRequest webRequest, WebDataBinderFactory binderFactory) throws Exception {\n\n        RequestCustomParam customParam = parameter.getParameterAnnotation(RequestCustomParam.class);\n        String value = webRequest.getParameter(customParam.value());\n        // do something\n        return Integer.valueOf(value);\n    }\n}\n```\n  \n핵심이 되는 부분이다. `RequestCustomParam` 가 포함되어 있는지 여부를 검사해서 annotation 이 등록되어 있는 request 만 통과를 시킨다. 그리고 사용자가 등록한 value 값을 뽑아와서 필요한 로직처리를 해주면 된다.  \n`// do sonething` 부분에서 shard 를 찾아가는 로직을 추가해주도록 하자.  \n전처리가 끝나면 controller 에서 uid 값을 이용해 비지니스 로직을 수행해야 하기 때문에 value 로 뽑아온 값을 다시 돌려준다.  \n여기서 참고할 부분은 parameter 로 뽑아온 값은 무조건 String 타입으로 반환된다. 각자 필요한 타입으로 변환해서 사용하도록 하자.  \n(아마 일반적으로 처리하기 위해 String 으로만 반환받게 한듯 싶다. 여러 타입으로 반환하는 것보다 처리가 간단하고 여러 타입으로 변환하는 작업 자체가 불필요하다고 느꼈을까)  \n신경써야할 부분이 있다면 `parameter.getParameterAnnotation`, `webRequest.getParameter` 은 `@Nullable` 이기 때문에 NPE 처리를 해주면 좋다.  \n\n이제 필요한 부분에만 `@RequestCustomParam(value = \"uid\") Integer uid` 으로 명시해서 처리하면 사용자는 sharding 에 대한 로직을 신경쓰지 않아도 된다.  \n별도의 service 로 나누어 처리하는 것보다 명시적이고 중복코드 없이 간단하게 처리할 수 있다.  \n\n\n## 결론\n지금까지 작업한 전체 코드는 [여기](https://github.com/nevercaution/customAnnotation) 에서 확인할 수 있다.  \nannotation 을 사용하면 특정 로직들은 뒤에서 처리되기 때문에 관심을 갖지 않고 보면 어떻게 동작하는지 이해하기 힘들다. 반대로 annotation 에 대한 이해가 있으면 코드는 훨씬 간결해지고 직관적으로 처리할 수 있게 된다. 이전까지는 annotation 은 알아서 동작하겠지 하며 큰 신경을 쓰고 있지 않았었는데, 직접 사용해보니 기존의 로직을 좀 더 깔끔하게 처리할 수 있다는 부분이 마음에 든다.  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","slug":"spring-boot-custom-annotation","published":1,"updated":"2018-04-15T08:06:43.632Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjq98sopy000g8ghh2cm6cwsx","content":"<h3><span id=\"썰의-시작\">썰의 시작</span></h3>\n<p>회사에서 msa 를 눈여겨 보면서 하나로 합쳐져 있는 거대한 프로젝트를 각각 쪼개려는 시도들을 하고 있다. 일에 치여 마음속에서만 맴돌고 있다가 최근에 새로운 기능을 추가해야할 일이 생겨 이때다 싶어 과감히 프로젝트를 쪼개서 작업해보기로 했다.<br>\n기존에 있던 api server 와 internal 호출을 하면서 데이터를 주고받는 작은 api service 이다. view 가 없기 때문에 Restful 하게 만들었다. (<s>내가 front 작업이 약해서는 아니다!</s>)<br>\n새로 추가된 서비스(<code>mini api server</code> 라고 하자)에서만 사용하는 테이블들이 있고, 기존 <code>api server</code> 는 <code>mini api server</code> 과 통신을 해서 해당 정보들에 대한 CRUD 를 할 수 있다.<br>\n최대한 기존 서비스와는 별도로 작업을 하고자 했고 추후에 물리 디비가 나뉘어도 큰 작업없이 옮겨갈 수 있도록 결합도를 낮추고자 했다.<br>\nuser 에 대한 데이터는 sharding 되어있고 현재는 디비를 같은 곳에 사용하고 있기 때문에 같은 sharding 전략을 가져가야 한다.</p>\n<p>annotation 얘기를 해야하는데 갑자기 엉뚱한 소리가 나왔네라고 생각할지도 모른다. 결론적으로 내가 해야할 일은 user 가 어느 shard 번호를 배정받았는지를 알아야 한다. 이 작업을 annotation 을 이용해서 유려하게 처리해도록 하자.</p>\n<h2><span id=\"구현목표\">구현목표</span></h2>\n<p>controller 에서 <code>@RequestParam</code> 으로 받은 값중에 특정값은 데이터가 sharding 처리가 되어 있어 각 repository 에서는 각 분배되어 있는 데이터를 잘 조회하기 위해 해당 디비번호를 설정해주어야 한다. 내가 구현해야할 일을 정리해보자.</p>\n<ul>\n<li>user_uid 값은 sharding 처리가 되어 있다.</li>\n<li>사용자는 user 가 어느 디비에 sharding 이 되어있는지 모른다.</li>\n<li>repository 에서는 각 분배가 되어 있는 디비에 접근을 해야한다.</li>\n</ul>\n<p>이런 상황에서의 해결법은 여러가지가 있다. 간단하게 처리할 수도, 복잡하게 처리할 수도 있다.<br>\n하나씩 정리하면서 넘어가도록 하자.</p>\n<h2><span id=\"개발-컨셉\">개발 컨셉</span></h2>\n<p>shard 번호를 처리를 해야한다고 할 때 두가지 방법으로 처리할 수 있다.</p>\n<ul>\n<li>사용자가 api 콜을 할 때 shard 번호를 함께 넘겨받는다.</li>\n<li>shard 번호가 배정되어 있는 디비에 해당 사용자의 번호를 가져온다.</li>\n</ul>\n<h3><span id=\"shard-번호-넘겨받기\">shard 번호 넘겨받기</span></h3>\n<p>전자의 경우에는 <code>new api server</code> 에서 shard 번호를 알고 있을 필요가 없기 때문에 아무런 처리없이 해당 shard 번호를 세팅해주면 된다.<br>\n현재는 물리디비가 함께 있으므로 이렇게 처리해도 큰 문제가 없다. user 데이터가 같은 디비에 있어 shard 번호만 받으면 동일한 번호에 데이터가 있기 때문이다. 하지만 추후에 디비가 나뉘어져서 shard 전략이 다르게 될 때는 문제가 된다. <code>api server</code> 에서는 1번 shard 인데 new api server 에서는 2번 shard 번호를 배정받을 수 있기 때문이다. 이런 이유로 후자의 방법으로 방향을 잡게 되었다.</p>\n<h3><span id=\"shard-번호-찾아가기\">shard 번호 찾아가기</span></h3>\n<p>shard 번호를 <code>mini api server</code> 에서 찾아가는 방법도 여러가지가 있다.</p>\n<ul>\n<li>별도의 service 를 만들어 명시적으로 호출해줘 값을 지정한다.</li>\n<li>상위 cnotroller 를 만들어 전체 controller 는 부모 controller 를 상속받아 부모에서 처리한다 (기존 <code>api server</code> 방식)</li>\n<li>interceptor, annotation 를 이용해 controller 전처리</li>\n</ul>\n<p>1, 2 번의 경우 각 api 호출별로 명시적으로 호출해서 처리할 수 있다. 다만 사용자가 모든 api 에 호출을 해주어야 하는 단점이 있고, 일단 마음에 들지 않는다. user 정보를 조회하는 api 에 모두 같은 로직을 넣어주어야 하기 때문에 코드 중복이 생기고 만약 실수로 코드를 넣지 않았다면 의도치 않은 에러를 발생할 수 있다. 최대한 중복코드를 줄이면서 사용자가 사용하기 편하게 하기 위해 annotation 을 사용해서 처리해보자.</p>\n<h2><span id=\"custom-annotation\">custom annotation</span></h2>\n<p>최종결과물부터 보면 다음과 같다. <code>@RequestParam</code> 을 사용하지 않고 <code>@RequestCustomParam</code> 을 이용한다. 이 annotation 을 붙여두면 알아서 shard 정보를 조회해서 DataSource 에 세팅하고 결과값을 Integer 값으로 반환받아 비지니스 로직에서 사용할 수 있다.</p>\n<p><code>FirstController</code></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@RestController</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">FirstController</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@RequestMapping</span>(value = <span class=\"string\">\"/\"</span>, method = RequestMethod.GET)</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">index</span><span class=\"params\">(@RequestCustomParam(value = <span class=\"string\">\"uid\"</span>)</span> Integer uid) </span>&#123;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>자 이게 가능하게 하기 위해서 하나씩 처리과정을 따라가보자.</p>\n<figure class=\"highlight routeros\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">.</span><br><span class=\"line\">├── TeddyApplication.java</span><br><span class=\"line\">├── annotation</span><br><span class=\"line\">│   └── RequestCustomParam.java</span><br><span class=\"line\">├── config</span><br><span class=\"line\">│   └── InterceptConfig.java</span><br><span class=\"line\">├── controller</span><br><span class=\"line\">│   └── FirstController.java</span><br><span class=\"line\">└── handler</span><br><span class=\"line\">    └── CustomResolver.java</span><br></pre></td></tr></table></figure>\n<ol>\n<li><code>RequestCustomParam</code> 을 생성</li>\n<li><code>InterceptConfig</code> 에서 customResolver 를 등록</li>\n<li><code>CustomResolver</code> 에서 <code>RequestCustomParam</code> 여부를 검사해 필요한 로직 실행</li>\n<li><code>FirstController</code> 에서 필요한 param 값에 <code>@RequestCustomParam</code> 로 등록을 하고, 전처리 후 shard 세팅이 된 uid 정보 이용</li>\n</ol>\n<h3><span id=\"하나씩-살펴보자\">하나씩 살펴보자</span></h3>\n<p>하나씩 뜯어보면 그리 어렵지 않다. 대체 어떻게 동작하는 것일까.</p>\n<p><code>RequestCustomParam</code></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Target</span>(&#123;ElementType.PARAMETER&#125;)</span><br><span class=\"line\"><span class=\"meta\">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"meta\">@interface</span> RequestCustomParam &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\">String <span class=\"title\">value</span><span class=\"params\">()</span> <span class=\"keyword\">default</span> \"\"</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>value 만 갖고 있으면 되고 다른 설정들은 일단 사용하지 않아서 <code>RequestParam</code> 에서 필요한 값만 가져왔다. 주목해야할 점은 Target 과 Retention 이다. Parameter 타입을 이용해 처리하고 RunTime 까지 annotation 을 가져가서 처리하도록 했다.</p>\n<p><code>InterceptConfig</code></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Configuration</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">InterceptConfig</span> <span class=\"keyword\">implements</span> <span class=\"title\">WebMvcConfigurer</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">addArgumentResolvers</span><span class=\"params\">(List&lt;HandlerMethodArgumentResolver&gt; resolvers)</span> </span>&#123;</span><br><span class=\"line\">        resolvers.add(getCustomResolver());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Bean</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> CustomResolver <span class=\"title\">getCustomResolver</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> CustomResolver();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><code>WebMvcConfigurer</code> 를 붙여서 내가 생성한 resolver bean 을 등록해준다.</p>\n<p><code>CustomResolver</code></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Configuration</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">CustomResolver</span> <span class=\"keyword\">implements</span> <span class=\"title\">HandlerMethodArgumentResolver</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">supportsParameter</span><span class=\"params\">(MethodParameter parameter)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> parameter.hasParameterAnnotation(RequestCustomParam.class);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Integer <span class=\"title\">resolveArgument</span><span class=\"params\">(MethodParameter parameter, ModelAndViewContainer mavContainer, NativeWebRequest webRequest, WebDataBinderFactory binderFactory)</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        RequestCustomParam customParam = parameter.getParameterAnnotation(RequestCustomParam.class);</span><br><span class=\"line\">        String value = webRequest.getParameter(customParam.value());</span><br><span class=\"line\">        <span class=\"comment\">// do something</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> Integer.valueOf(value);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>핵심이 되는 부분이다. <code>RequestCustomParam</code> 가 포함되어 있는지 여부를 검사해서 annotation 이 등록되어 있는 request 만 통과를 시킨다. 그리고 사용자가 등록한 value 값을 뽑아와서 필요한 로직처리를 해주면 된다.<br>\n<code>// do sonething</code> 부분에서 shard 를 찾아가는 로직을 추가해주도록 하자.<br>\n전처리가 끝나면 controller 에서 uid 값을 이용해 비지니스 로직을 수행해야 하기 때문에 value 로 뽑아온 값을 다시 돌려준다.<br>\n여기서 참고할 부분은 parameter 로 뽑아온 값은 무조건 String 타입으로 반환된다. 각자 필요한 타입으로 변환해서 사용하도록 하자.<br>\n(아마 일반적으로 처리하기 위해 String 으로만 반환받게 한듯 싶다. 여러 타입으로 반환하는 것보다 처리가 간단하고 여러 타입으로 변환하는 작업 자체가 불필요하다고 느꼈을까)<br>\n신경써야할 부분이 있다면 <code>parameter.getParameterAnnotation</code>, <code>webRequest.getParameter</code> 은 <code>@Nullable</code> 이기 때문에 NPE 처리를 해주면 좋다.</p>\n<p>이제 필요한 부분에만 <code>@RequestCustomParam(value = &quot;uid&quot;) Integer uid</code> 으로 명시해서 처리하면 사용자는 sharding 에 대한 로직을 신경쓰지 않아도 된다.<br>\n별도의 service 로 나누어 처리하는 것보다 명시적이고 중복코드 없이 간단하게 처리할 수 있다.</p>\n<h2><span id=\"결론\">결론</span></h2>\n<p>지금까지 작업한 전체 코드는 <a href=\"https://github.com/nevercaution/customAnnotation\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">여기</a> 에서 확인할 수 있다.<br>\nannotation 을 사용하면 특정 로직들은 뒤에서 처리되기 때문에 관심을 갖지 않고 보면 어떻게 동작하는지 이해하기 힘들다. 반대로 annotation 에 대한 이해가 있으면 코드는 훨씬 간결해지고 직관적으로 처리할 수 있게 된다. 이전까지는 annotation 은 알아서 동작하겠지 하며 큰 신경을 쓰고 있지 않았었는데, 직접 사용해보니 기존의 로직을 좀 더 깔끔하게 처리할 수 있다는 부분이 마음에 든다.</p>\n","site":{"data":{}},"excerpt":"","more":"<h3>썰의 시작</h3>\n<p>회사에서 msa 를 눈여겨 보면서 하나로 합쳐져 있는 거대한 프로젝트를 각각 쪼개려는 시도들을 하고 있다. 일에 치여 마음속에서만 맴돌고 있다가 최근에 새로운 기능을 추가해야할 일이 생겨 이때다 싶어 과감히 프로젝트를 쪼개서 작업해보기로 했다.<br>\n기존에 있던 api server 와 internal 호출을 하면서 데이터를 주고받는 작은 api service 이다. view 가 없기 때문에 Restful 하게 만들었다. (<s>내가 front 작업이 약해서는 아니다!</s>)<br>\n새로 추가된 서비스(<code>mini api server</code> 라고 하자)에서만 사용하는 테이블들이 있고, 기존 <code>api server</code> 는 <code>mini api server</code> 과 통신을 해서 해당 정보들에 대한 CRUD 를 할 수 있다.<br>\n최대한 기존 서비스와는 별도로 작업을 하고자 했고 추후에 물리 디비가 나뉘어도 큰 작업없이 옮겨갈 수 있도록 결합도를 낮추고자 했다.<br>\nuser 에 대한 데이터는 sharding 되어있고 현재는 디비를 같은 곳에 사용하고 있기 때문에 같은 sharding 전략을 가져가야 한다.</p>\n<p>annotation 얘기를 해야하는데 갑자기 엉뚱한 소리가 나왔네라고 생각할지도 모른다. 결론적으로 내가 해야할 일은 user 가 어느 shard 번호를 배정받았는지를 알아야 한다. 이 작업을 annotation 을 이용해서 유려하게 처리해도록 하자.</p>\n<h2>구현목표</h2>\n<p>controller 에서 <code>@RequestParam</code> 으로 받은 값중에 특정값은 데이터가 sharding 처리가 되어 있어 각 repository 에서는 각 분배되어 있는 데이터를 잘 조회하기 위해 해당 디비번호를 설정해주어야 한다. 내가 구현해야할 일을 정리해보자.</p>\n<ul>\n<li>user_uid 값은 sharding 처리가 되어 있다.</li>\n<li>사용자는 user 가 어느 디비에 sharding 이 되어있는지 모른다.</li>\n<li>repository 에서는 각 분배가 되어 있는 디비에 접근을 해야한다.</li>\n</ul>\n<p>이런 상황에서의 해결법은 여러가지가 있다. 간단하게 처리할 수도, 복잡하게 처리할 수도 있다.<br>\n하나씩 정리하면서 넘어가도록 하자.</p>\n<h2>개발 컨셉</h2>\n<p>shard 번호를 처리를 해야한다고 할 때 두가지 방법으로 처리할 수 있다.</p>\n<ul>\n<li>사용자가 api 콜을 할 때 shard 번호를 함께 넘겨받는다.</li>\n<li>shard 번호가 배정되어 있는 디비에 해당 사용자의 번호를 가져온다.</li>\n</ul>\n<h3>shard 번호 넘겨받기</h3>\n<p>전자의 경우에는 <code>new api server</code> 에서 shard 번호를 알고 있을 필요가 없기 때문에 아무런 처리없이 해당 shard 번호를 세팅해주면 된다.<br>\n현재는 물리디비가 함께 있으므로 이렇게 처리해도 큰 문제가 없다. user 데이터가 같은 디비에 있어 shard 번호만 받으면 동일한 번호에 데이터가 있기 때문이다. 하지만 추후에 디비가 나뉘어져서 shard 전략이 다르게 될 때는 문제가 된다. <code>api server</code> 에서는 1번 shard 인데 new api server 에서는 2번 shard 번호를 배정받을 수 있기 때문이다. 이런 이유로 후자의 방법으로 방향을 잡게 되었다.</p>\n<h3>shard 번호 찾아가기</h3>\n<p>shard 번호를 <code>mini api server</code> 에서 찾아가는 방법도 여러가지가 있다.</p>\n<ul>\n<li>별도의 service 를 만들어 명시적으로 호출해줘 값을 지정한다.</li>\n<li>상위 cnotroller 를 만들어 전체 controller 는 부모 controller 를 상속받아 부모에서 처리한다 (기존 <code>api server</code> 방식)</li>\n<li>interceptor, annotation 를 이용해 controller 전처리</li>\n</ul>\n<p>1, 2 번의 경우 각 api 호출별로 명시적으로 호출해서 처리할 수 있다. 다만 사용자가 모든 api 에 호출을 해주어야 하는 단점이 있고, 일단 마음에 들지 않는다. user 정보를 조회하는 api 에 모두 같은 로직을 넣어주어야 하기 때문에 코드 중복이 생기고 만약 실수로 코드를 넣지 않았다면 의도치 않은 에러를 발생할 수 있다. 최대한 중복코드를 줄이면서 사용자가 사용하기 편하게 하기 위해 annotation 을 사용해서 처리해보자.</p>\n<h2>custom annotation</h2>\n<p>최종결과물부터 보면 다음과 같다. <code>@RequestParam</code> 을 사용하지 않고 <code>@RequestCustomParam</code> 을 이용한다. 이 annotation 을 붙여두면 알아서 shard 정보를 조회해서 DataSource 에 세팅하고 결과값을 Integer 값으로 반환받아 비지니스 로직에서 사용할 수 있다.</p>\n<p><code>FirstController</code></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@RestController</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">FirstController</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@RequestMapping</span>(value = <span class=\"string\">\"/\"</span>, method = RequestMethod.GET)</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">index</span><span class=\"params\">(@RequestCustomParam(value = <span class=\"string\">\"uid\"</span>)</span> Integer uid) </span>&#123;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>자 이게 가능하게 하기 위해서 하나씩 처리과정을 따라가보자.</p>\n<figure class=\"highlight routeros\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">.</span><br><span class=\"line\">├── TeddyApplication.java</span><br><span class=\"line\">├── annotation</span><br><span class=\"line\">│   └── RequestCustomParam.java</span><br><span class=\"line\">├── config</span><br><span class=\"line\">│   └── InterceptConfig.java</span><br><span class=\"line\">├── controller</span><br><span class=\"line\">│   └── FirstController.java</span><br><span class=\"line\">└── handler</span><br><span class=\"line\">    └── CustomResolver.java</span><br></pre></td></tr></table></figure>\n<ol>\n<li><code>RequestCustomParam</code> 을 생성</li>\n<li><code>InterceptConfig</code> 에서 customResolver 를 등록</li>\n<li><code>CustomResolver</code> 에서 <code>RequestCustomParam</code> 여부를 검사해 필요한 로직 실행</li>\n<li><code>FirstController</code> 에서 필요한 param 값에 <code>@RequestCustomParam</code> 로 등록을 하고, 전처리 후 shard 세팅이 된 uid 정보 이용</li>\n</ol>\n<h3>하나씩 살펴보자</h3>\n<p>하나씩 뜯어보면 그리 어렵지 않다. 대체 어떻게 동작하는 것일까.</p>\n<p><code>RequestCustomParam</code></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Target</span>(&#123;ElementType.PARAMETER&#125;)</span><br><span class=\"line\"><span class=\"meta\">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"meta\">@interface</span> RequestCustomParam &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\">String <span class=\"title\">value</span><span class=\"params\">()</span> <span class=\"keyword\">default</span> \"\"</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>value 만 갖고 있으면 되고 다른 설정들은 일단 사용하지 않아서 <code>RequestParam</code> 에서 필요한 값만 가져왔다. 주목해야할 점은 Target 과 Retention 이다. Parameter 타입을 이용해 처리하고 RunTime 까지 annotation 을 가져가서 처리하도록 했다.</p>\n<p><code>InterceptConfig</code></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Configuration</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">InterceptConfig</span> <span class=\"keyword\">implements</span> <span class=\"title\">WebMvcConfigurer</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">addArgumentResolvers</span><span class=\"params\">(List&lt;HandlerMethodArgumentResolver&gt; resolvers)</span> </span>&#123;</span><br><span class=\"line\">        resolvers.add(getCustomResolver());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Bean</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> CustomResolver <span class=\"title\">getCustomResolver</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> CustomResolver();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><code>WebMvcConfigurer</code> 를 붙여서 내가 생성한 resolver bean 을 등록해준다.</p>\n<p><code>CustomResolver</code></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Configuration</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">CustomResolver</span> <span class=\"keyword\">implements</span> <span class=\"title\">HandlerMethodArgumentResolver</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">supportsParameter</span><span class=\"params\">(MethodParameter parameter)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> parameter.hasParameterAnnotation(RequestCustomParam.class);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Integer <span class=\"title\">resolveArgument</span><span class=\"params\">(MethodParameter parameter, ModelAndViewContainer mavContainer, NativeWebRequest webRequest, WebDataBinderFactory binderFactory)</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        RequestCustomParam customParam = parameter.getParameterAnnotation(RequestCustomParam.class);</span><br><span class=\"line\">        String value = webRequest.getParameter(customParam.value());</span><br><span class=\"line\">        <span class=\"comment\">// do something</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> Integer.valueOf(value);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>핵심이 되는 부분이다. <code>RequestCustomParam</code> 가 포함되어 있는지 여부를 검사해서 annotation 이 등록되어 있는 request 만 통과를 시킨다. 그리고 사용자가 등록한 value 값을 뽑아와서 필요한 로직처리를 해주면 된다.<br>\n<code>// do sonething</code> 부분에서 shard 를 찾아가는 로직을 추가해주도록 하자.<br>\n전처리가 끝나면 controller 에서 uid 값을 이용해 비지니스 로직을 수행해야 하기 때문에 value 로 뽑아온 값을 다시 돌려준다.<br>\n여기서 참고할 부분은 parameter 로 뽑아온 값은 무조건 String 타입으로 반환된다. 각자 필요한 타입으로 변환해서 사용하도록 하자.<br>\n(아마 일반적으로 처리하기 위해 String 으로만 반환받게 한듯 싶다. 여러 타입으로 반환하는 것보다 처리가 간단하고 여러 타입으로 변환하는 작업 자체가 불필요하다고 느꼈을까)<br>\n신경써야할 부분이 있다면 <code>parameter.getParameterAnnotation</code>, <code>webRequest.getParameter</code> 은 <code>@Nullable</code> 이기 때문에 NPE 처리를 해주면 좋다.</p>\n<p>이제 필요한 부분에만 <code>@RequestCustomParam(value = &quot;uid&quot;) Integer uid</code> 으로 명시해서 처리하면 사용자는 sharding 에 대한 로직을 신경쓰지 않아도 된다.<br>\n별도의 service 로 나누어 처리하는 것보다 명시적이고 중복코드 없이 간단하게 처리할 수 있다.</p>\n<h2>결론</h2>\n<p>지금까지 작업한 전체 코드는 <a href=\"https://github.com/nevercaution/customAnnotation\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">여기</a> 에서 확인할 수 있다.<br>\nannotation 을 사용하면 특정 로직들은 뒤에서 처리되기 때문에 관심을 갖지 않고 보면 어떻게 동작하는지 이해하기 힘들다. 반대로 annotation 에 대한 이해가 있으면 코드는 훨씬 간결해지고 직관적으로 처리할 수 있게 된다. 이전까지는 annotation 은 알아서 동작하겠지 하며 큰 신경을 쓰고 있지 않았었는데, 직접 사용해보니 기존의 로직을 좀 더 깔끔하게 처리할 수 있다는 부분이 마음에 든다.</p>\n"},{"title":"spring boot 에서 jsp view 만들기 (feat freemarker)","catalog":true,"date":"2018-02-22T02:33:19.000Z","subtitle":null,"header-img":"/img/header_img/bg.png","_content":"\n### view를 추가해야한다.  \n\nspring 을 사용하다가 spring boot 로 넘어오면서 front, back 을 나누어서 백단은 나름 Restful 하게 해서 api 콜만 처리하는 방식으로 변경하는 중이다.(front 는 react로 구성하는 중이다.) 그래서 spring boot 에서는 따로 view 처리해야할 일이 없었는데 기존에 spring 에서 view 처리를 해주는 요청을 가져와야 할일이 생겼다.  \n하지만 찾아보니 기존에 spring 에서 하던 방법으로는 안될 것 같다.  \n왜냐하면 [spring boot 에서는 jar 로 사용할 때는 jsp를 사용할 수 없다고 한다.](https://docs.spring.io/spring-boot/docs/current/reference/html/boot-features-developing-web-applications.html#boot-features-jsp-limitations)  \n내용을 읽어보니 boot에 내장 tomcat에 하드코딩 패턴때문에 jar형식으로는 webapp내용을 가져올 수 없다고 한다. 그리고 공식적으로 jsp를 지원하지 않는다고 한다. boot에서 밀고 있는 template engine 들이 여러개 있었는데 간단한 view 하나 추가하는데 공수가 많이 들게되면 좋지 않을꺼라 생각해서 jsp로 view 를 구성하는 방법을 시도해보았다.  \n일단 작업을 시작하기 전에 현재 사용하고 있는 버전들을 정리하고 간다.  \n\n### 사용하고 있는 버전은 다음과 같다.\n* spring boot 1.5.7\n* gradle 4.4  \n\n### 나중에는 없어질 view 이지만\nfront작업이 react로 완료되면 이 view 는 더이상 필요하지 않다.  \n그래서 나는 최소한의 공수로 기존에 있는 jsp 파일을 사용하여 가볍게 포팅만 하고자 했다.  \n\n--- \n\n## 1차 시도\nspring boot 에서 jsp view를 사용하기 위해 spring에서 구성하는 방법과 추가적으로 필요한 설정들을 해주었다.  \nspring boot 의 내장 tomcat에는 jsp parser가 없기 때문에 의존 패키지를 추가해주어야 한다.  \n\n- build.gradle  \n\n```bash\nderendencies {\n    compile('javax.servlet:jstl')\n    compile(\"org.apache.tomcat.embed:tomcat-embed-jasper\")\n}\n```\n  \n그리고 구조는 아래와 같이 구성했다. main밑에 webapp폴더를 추가해서 jsp파일을 추가해준다.  \n\n```bash\n.\n├── build.gradle\n├── gradlew\n├── gradlew.bat\n└── src\n    ├── main\n    │   ├── java\n    │   │   └── com\n    │   │       └── example\n    │   │           └── demo\n    │   │               ├── DemoApplication.java\n    │   │               └── MyController.java\n    │   ├── resources\n    │   │   └── application.properties\n    │   └── webapp\n    │       └── WEB-INF\n    │           └── jsp\n    │               └── index.jsp\n    └── test\n```\n  \nspring boot 는 webapp의 위치를 모르기 때문에 설정파일에 경로를 명시해주어야 한다.  \n* application.properties  \n  \n```bash\nspring.mvc.view.prefix=/WEB-INF/jsp/\nspring.mvc.view.suffix=.jsp\n```\n  \n설정은 다했다. 이제 controller에서 view를 호출해보자.  \n* MyController.java  \n\n```java\npackage com.example.demo;\n\nimport org.springframework.stereotype.Controller;\nimport org.springframework.web.bind.annotation.RequestMapping;\nimport org.springframework.web.servlet.ModelAndView;\n\n@Controller\npublic class MyController {\n\n    @RequestMapping(value = \"/\")\n    public ModelAndView main() {\n        ModelAndView view = new ModelAndView(\"index\");\n        view.addObject(\"text\", \"world\");\n        return view;\n    }\n}\n```\n설정파일에서 prefix, suffix를 적어주었기 때문에 view이름은 파일이름만 넣어주면 된다.  \n\n* index.jsp\n\n```html\n<html>\n    <body>\n        <h1>Hello world</h1>\n        hello ${text}\n    </body>\n</html>\n```\n이제 bootRun 을 하면 build 를 하고 테스트를 해볼 수 있다.  \n\n```bash\n$ ./gradlew clean bootRun\n:compileJava \n:processResources \n:classes \n:findMainClass\n:bootRun\n```\n\n* localhost:8080/\n```html\nHello world\n\nhello world\n```\n\nbuild 명령어로 jar파일을 만들어 보자. \n```sh\n$ ./gradlew clean build\n:compileJava \n:processResources \n:classes \n:findMainClass\n:jar\n:bootRepackage\n:assemble\n:compileTestJava \n:processTestResources NO-SOURCE\n:testClasses \n:test \n:check \n:build\n\nBUILD SUCCESSFUL\n\nTotal time: 1.494 secs\n```\n\n`./build/libs/testGradle-0.0.1-SNAPSHOT.jar` 에 jar가 만들어졌다. 이걸로 직접 띄워서 호출해보자.  \n\n```bash\n$ java -jar build/libs/testGradle-0.0.1-SNAPSHOT.jar\n```\n잘 뜨는 것을 확인 할 수 있다. 그런데 더이상 boot진영에서도 jsp파일을 그대로 쓰는걸 권장하고 있지 않으니 그냥 추천해주는 template engine로 넘어가야겠다는 생각이 들었다.  \n\n## 2차 시도\n찾아보니 정말 [여러가지 template engine](\"http://www.baeldung.com/spring-template-engines\")들이 있었다. 곰곰히 찾아보다 간단해 보이는 [Free Marker](\"https://freemarker.apache.org/\")를 써보기로 했다.  \n설정을 추가해주는 것도 간단하다. 추가를 해보자.  \n  \n* build.gradle\n  \n```bash\ndependencies {\n    compile('org.springframework.boot:spring-boot-starter-freemarker')\n}\n```\n\n그리고 jsp로 인한 설정들을 모두 제거해준다.  \n* application.properties\n\n```bash\n#spring.mvc.view.prefix=/WEB-INF/jsp/\n#spring.mvc.view.suffix=.jsp\n```\n\n그리고 free marker 의 확장자는 `.ftl` 이다. 기본적인 파일 위치는 `resources/templates/` 이다.  \n이에 따라 파일명을 수정해주고 이동까지 하면 아래와 같이 된다.  \n\n```bash\n.\n├── build.gradle\n├── gradle\n│   └── wrapper\n│       ├── gradle-wrapper.jar\n│       └── gradle-wrapper.properties\n├── gradlew\n├── gradlew.bat\n└── src\n    ├── main\n    │   ├── java\n    │   │   └── com\n    │   │       └── example\n    │   │           └── demo\n    │   │               ├── DemoApplication.java\n    │   │               └── MyController.java\n    │   └── resources\n    │       ├── application.properties\n    │       └── templates\n    │           └── index.ftl\n    └── test\n        └── java\n            └── com\n                └── example\n                    └── demo\n                        └── DemoApplicationTests.java\n```\n\n위와 같이 설정하고 빌드를 하고 jar파일을 띄워주면 1차시도와 동일한 결과가 나온다.  \n처음에는 jsp파일을 가지고 어떻게든 띄워보려고 노력했지만 다른 template engine을 보니 복잡한 jsp파일이 아니라면 굳이 사용하지 않아도 될거라는 생각이 들었다.  \n\n## 결론\n아무래도 이제는 spring boot를 사용하면서 jsp를 사용하기는 어려울듯 싶다. 나도 결국에는 다른 template engine을 사용했는데 설정부터 적용이 너무 편해진 느낌.  \n각 template engine마다 문법이 조금 달라서 개인의 기호에 맞게 써야겠다만..(예전에 node를 할 때 [jade](\"https://www.npmjs.com/package/jade\")같은 경우엔 적잖은 충격을 받았었다.)  \n아무래도 아직까지는 html친화적인 문법이 조금은 더 익숙한 느낌이다.  ","source":"_posts/spring-boot-jsp.md","raw":"---\ntitle: \"spring boot 에서 jsp view 만들기 (feat freemarker)\"\ncatalog: true\ndate: 2018-02-22 11:33:19\nsubtitle:\nheader-img: \"/img/header_img/bg.png\"\ntags:\n- springboot\n- jsp\n- freemarker\n- gradle\n---\n\n### view를 추가해야한다.  \n\nspring 을 사용하다가 spring boot 로 넘어오면서 front, back 을 나누어서 백단은 나름 Restful 하게 해서 api 콜만 처리하는 방식으로 변경하는 중이다.(front 는 react로 구성하는 중이다.) 그래서 spring boot 에서는 따로 view 처리해야할 일이 없었는데 기존에 spring 에서 view 처리를 해주는 요청을 가져와야 할일이 생겼다.  \n하지만 찾아보니 기존에 spring 에서 하던 방법으로는 안될 것 같다.  \n왜냐하면 [spring boot 에서는 jar 로 사용할 때는 jsp를 사용할 수 없다고 한다.](https://docs.spring.io/spring-boot/docs/current/reference/html/boot-features-developing-web-applications.html#boot-features-jsp-limitations)  \n내용을 읽어보니 boot에 내장 tomcat에 하드코딩 패턴때문에 jar형식으로는 webapp내용을 가져올 수 없다고 한다. 그리고 공식적으로 jsp를 지원하지 않는다고 한다. boot에서 밀고 있는 template engine 들이 여러개 있었는데 간단한 view 하나 추가하는데 공수가 많이 들게되면 좋지 않을꺼라 생각해서 jsp로 view 를 구성하는 방법을 시도해보았다.  \n일단 작업을 시작하기 전에 현재 사용하고 있는 버전들을 정리하고 간다.  \n\n### 사용하고 있는 버전은 다음과 같다.\n* spring boot 1.5.7\n* gradle 4.4  \n\n### 나중에는 없어질 view 이지만\nfront작업이 react로 완료되면 이 view 는 더이상 필요하지 않다.  \n그래서 나는 최소한의 공수로 기존에 있는 jsp 파일을 사용하여 가볍게 포팅만 하고자 했다.  \n\n--- \n\n## 1차 시도\nspring boot 에서 jsp view를 사용하기 위해 spring에서 구성하는 방법과 추가적으로 필요한 설정들을 해주었다.  \nspring boot 의 내장 tomcat에는 jsp parser가 없기 때문에 의존 패키지를 추가해주어야 한다.  \n\n- build.gradle  \n\n```bash\nderendencies {\n    compile('javax.servlet:jstl')\n    compile(\"org.apache.tomcat.embed:tomcat-embed-jasper\")\n}\n```\n  \n그리고 구조는 아래와 같이 구성했다. main밑에 webapp폴더를 추가해서 jsp파일을 추가해준다.  \n\n```bash\n.\n├── build.gradle\n├── gradlew\n├── gradlew.bat\n└── src\n    ├── main\n    │   ├── java\n    │   │   └── com\n    │   │       └── example\n    │   │           └── demo\n    │   │               ├── DemoApplication.java\n    │   │               └── MyController.java\n    │   ├── resources\n    │   │   └── application.properties\n    │   └── webapp\n    │       └── WEB-INF\n    │           └── jsp\n    │               └── index.jsp\n    └── test\n```\n  \nspring boot 는 webapp의 위치를 모르기 때문에 설정파일에 경로를 명시해주어야 한다.  \n* application.properties  \n  \n```bash\nspring.mvc.view.prefix=/WEB-INF/jsp/\nspring.mvc.view.suffix=.jsp\n```\n  \n설정은 다했다. 이제 controller에서 view를 호출해보자.  \n* MyController.java  \n\n```java\npackage com.example.demo;\n\nimport org.springframework.stereotype.Controller;\nimport org.springframework.web.bind.annotation.RequestMapping;\nimport org.springframework.web.servlet.ModelAndView;\n\n@Controller\npublic class MyController {\n\n    @RequestMapping(value = \"/\")\n    public ModelAndView main() {\n        ModelAndView view = new ModelAndView(\"index\");\n        view.addObject(\"text\", \"world\");\n        return view;\n    }\n}\n```\n설정파일에서 prefix, suffix를 적어주었기 때문에 view이름은 파일이름만 넣어주면 된다.  \n\n* index.jsp\n\n```html\n<html>\n    <body>\n        <h1>Hello world</h1>\n        hello ${text}\n    </body>\n</html>\n```\n이제 bootRun 을 하면 build 를 하고 테스트를 해볼 수 있다.  \n\n```bash\n$ ./gradlew clean bootRun\n:compileJava \n:processResources \n:classes \n:findMainClass\n:bootRun\n```\n\n* localhost:8080/\n```html\nHello world\n\nhello world\n```\n\nbuild 명령어로 jar파일을 만들어 보자. \n```sh\n$ ./gradlew clean build\n:compileJava \n:processResources \n:classes \n:findMainClass\n:jar\n:bootRepackage\n:assemble\n:compileTestJava \n:processTestResources NO-SOURCE\n:testClasses \n:test \n:check \n:build\n\nBUILD SUCCESSFUL\n\nTotal time: 1.494 secs\n```\n\n`./build/libs/testGradle-0.0.1-SNAPSHOT.jar` 에 jar가 만들어졌다. 이걸로 직접 띄워서 호출해보자.  \n\n```bash\n$ java -jar build/libs/testGradle-0.0.1-SNAPSHOT.jar\n```\n잘 뜨는 것을 확인 할 수 있다. 그런데 더이상 boot진영에서도 jsp파일을 그대로 쓰는걸 권장하고 있지 않으니 그냥 추천해주는 template engine로 넘어가야겠다는 생각이 들었다.  \n\n## 2차 시도\n찾아보니 정말 [여러가지 template engine](\"http://www.baeldung.com/spring-template-engines\")들이 있었다. 곰곰히 찾아보다 간단해 보이는 [Free Marker](\"https://freemarker.apache.org/\")를 써보기로 했다.  \n설정을 추가해주는 것도 간단하다. 추가를 해보자.  \n  \n* build.gradle\n  \n```bash\ndependencies {\n    compile('org.springframework.boot:spring-boot-starter-freemarker')\n}\n```\n\n그리고 jsp로 인한 설정들을 모두 제거해준다.  \n* application.properties\n\n```bash\n#spring.mvc.view.prefix=/WEB-INF/jsp/\n#spring.mvc.view.suffix=.jsp\n```\n\n그리고 free marker 의 확장자는 `.ftl` 이다. 기본적인 파일 위치는 `resources/templates/` 이다.  \n이에 따라 파일명을 수정해주고 이동까지 하면 아래와 같이 된다.  \n\n```bash\n.\n├── build.gradle\n├── gradle\n│   └── wrapper\n│       ├── gradle-wrapper.jar\n│       └── gradle-wrapper.properties\n├── gradlew\n├── gradlew.bat\n└── src\n    ├── main\n    │   ├── java\n    │   │   └── com\n    │   │       └── example\n    │   │           └── demo\n    │   │               ├── DemoApplication.java\n    │   │               └── MyController.java\n    │   └── resources\n    │       ├── application.properties\n    │       └── templates\n    │           └── index.ftl\n    └── test\n        └── java\n            └── com\n                └── example\n                    └── demo\n                        └── DemoApplicationTests.java\n```\n\n위와 같이 설정하고 빌드를 하고 jar파일을 띄워주면 1차시도와 동일한 결과가 나온다.  \n처음에는 jsp파일을 가지고 어떻게든 띄워보려고 노력했지만 다른 template engine을 보니 복잡한 jsp파일이 아니라면 굳이 사용하지 않아도 될거라는 생각이 들었다.  \n\n## 결론\n아무래도 이제는 spring boot를 사용하면서 jsp를 사용하기는 어려울듯 싶다. 나도 결국에는 다른 template engine을 사용했는데 설정부터 적용이 너무 편해진 느낌.  \n각 template engine마다 문법이 조금 달라서 개인의 기호에 맞게 써야겠다만..(예전에 node를 할 때 [jade](\"https://www.npmjs.com/package/jade\")같은 경우엔 적잖은 충격을 받았었다.)  \n아무래도 아직까지는 html친화적인 문법이 조금은 더 익숙한 느낌이다.  ","slug":"spring-boot-jsp","published":1,"updated":"2018-04-15T08:09:11.335Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjq98soq2000h8ghhh0mew9nt","content":"<h3><span id=\"view를-추가해야한다\">view를 추가해야한다.</span></h3>\n<p>spring 을 사용하다가 spring boot 로 넘어오면서 front, back 을 나누어서 백단은 나름 Restful 하게 해서 api 콜만 처리하는 방식으로 변경하는 중이다.(front 는 react로 구성하는 중이다.) 그래서 spring boot 에서는 따로 view 처리해야할 일이 없었는데 기존에 spring 에서 view 처리를 해주는 요청을 가져와야 할일이 생겼다.<br>\n하지만 찾아보니 기존에 spring 에서 하던 방법으로는 안될 것 같다.<br>\n왜냐하면 <a href=\"https://docs.spring.io/spring-boot/docs/current/reference/html/boot-features-developing-web-applications.html#boot-features-jsp-limitations\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">spring boot 에서는 jar 로 사용할 때는 jsp를 사용할 수 없다고 한다.</a><br>\n내용을 읽어보니 boot에 내장 tomcat에 하드코딩 패턴때문에 jar형식으로는 webapp내용을 가져올 수 없다고 한다. 그리고 공식적으로 jsp를 지원하지 않는다고 한다. boot에서 밀고 있는 template engine 들이 여러개 있었는데 간단한 view 하나 추가하는데 공수가 많이 들게되면 좋지 않을꺼라 생각해서 jsp로 view 를 구성하는 방법을 시도해보았다.<br>\n일단 작업을 시작하기 전에 현재 사용하고 있는 버전들을 정리하고 간다.</p>\n<h3><span id=\"사용하고-있는-버전은-다음과-같다\">사용하고 있는 버전은 다음과 같다.</span></h3>\n<ul>\n<li>spring boot 1.5.7</li>\n<li>gradle 4.4</li>\n</ul>\n<h3><span id=\"나중에는-없어질-view-이지만\">나중에는 없어질 view 이지만</span></h3>\n<p>front작업이 react로 완료되면 이 view 는 더이상 필요하지 않다.<br>\n그래서 나는 최소한의 공수로 기존에 있는 jsp 파일을 사용하여 가볍게 포팅만 하고자 했다.</p>\n<hr>\n<h2><span id=\"1차-시도\">1차 시도</span></h2>\n<p>spring boot 에서 jsp view를 사용하기 위해 spring에서 구성하는 방법과 추가적으로 필요한 설정들을 해주었다.<br>\nspring boot 의 내장 tomcat에는 jsp parser가 없기 때문에 의존 패키지를 추가해주어야 한다.</p>\n<ul>\n<li>build.gradle</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">derendencies &#123;</span><br><span class=\"line\">    compile(<span class=\"string\">'javax.servlet:jstl'</span>)</span><br><span class=\"line\">    compile(<span class=\"string\">\"org.apache.tomcat.embed:tomcat-embed-jasper\"</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>그리고 구조는 아래와 같이 구성했다. main밑에 webapp폴더를 추가해서 jsp파일을 추가해준다.</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">.</span><br><span class=\"line\">├── build.gradle</span><br><span class=\"line\">├── gradlew</span><br><span class=\"line\">├── gradlew.bat</span><br><span class=\"line\">└── src</span><br><span class=\"line\">    ├── main</span><br><span class=\"line\">    │   ├── java</span><br><span class=\"line\">    │   │   └── com</span><br><span class=\"line\">    │   │       └── example</span><br><span class=\"line\">    │   │           └── demo</span><br><span class=\"line\">    │   │               ├── DemoApplication.java</span><br><span class=\"line\">    │   │               └── MyController.java</span><br><span class=\"line\">    │   ├── resources</span><br><span class=\"line\">    │   │   └── application.properties</span><br><span class=\"line\">    │   └── webapp</span><br><span class=\"line\">    │       └── WEB-INF</span><br><span class=\"line\">    │           └── jsp</span><br><span class=\"line\">    │               └── index.jsp</span><br><span class=\"line\">    └── <span class=\"built_in\">test</span></span><br></pre></td></tr></table></figure>\n<p>spring boot 는 webapp의 위치를 모르기 때문에 설정파일에 경로를 명시해주어야 한다.</p>\n<ul>\n<li>application.properties</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">spring.mvc.view.prefix=/WEB-INF/jsp/</span><br><span class=\"line\">spring.mvc.view.suffix=.jsp</span><br></pre></td></tr></table></figure>\n<p>설정은 다했다. 이제 controller에서 view를 호출해보자.</p>\n<ul>\n<li>MyController.java</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> com.example.demo;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.stereotype.Controller;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.web.bind.annotation.RequestMapping;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.web.servlet.ModelAndView;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Controller</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyController</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@RequestMapping</span>(value = <span class=\"string\">\"/\"</span>)</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> ModelAndView <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        ModelAndView view = <span class=\"keyword\">new</span> ModelAndView(<span class=\"string\">\"index\"</span>);</span><br><span class=\"line\">        view.addObject(<span class=\"string\">\"text\"</span>, <span class=\"string\">\"world\"</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> view;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>설정파일에서 prefix, suffix를 적어주었기 때문에 view이름은 파일이름만 넣어주면 된다.</p>\n<ul>\n<li>index.jsp</li>\n</ul>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">html</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">body</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">h1</span>&gt;</span>Hello world<span class=\"tag\">&lt;/<span class=\"name\">h1</span>&gt;</span></span><br><span class=\"line\">        hello $&#123;text&#125;</span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">body</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">html</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>이제 bootRun 을 하면 build 를 하고 테스트를 해볼 수 있다.</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ ./gradlew clean bootRun</span><br><span class=\"line\">:compileJava </span><br><span class=\"line\">:processResources </span><br><span class=\"line\">:classes </span><br><span class=\"line\">:findMainClass</span><br><span class=\"line\">:bootRun</span><br></pre></td></tr></table></figure>\n<ul>\n<li>localhost:8080/</li>\n</ul>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Hello world</span><br><span class=\"line\"></span><br><span class=\"line\">hello world</span><br></pre></td></tr></table></figure>\n<p>build 명령어로 jar파일을 만들어 보자.</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ ./gradlew clean build</span><br><span class=\"line\">:compileJava </span><br><span class=\"line\">:processResources </span><br><span class=\"line\">:classes </span><br><span class=\"line\">:findMainClass</span><br><span class=\"line\">:jar</span><br><span class=\"line\">:bootRepackage</span><br><span class=\"line\">:assemble</span><br><span class=\"line\">:compileTestJava </span><br><span class=\"line\">:processTestResources NO-SOURCE</span><br><span class=\"line\">:testClasses </span><br><span class=\"line\">:<span class=\"built_in\">test</span> </span><br><span class=\"line\">:check </span><br><span class=\"line\">:build</span><br><span class=\"line\"></span><br><span class=\"line\">BUILD SUCCESSFUL</span><br><span class=\"line\"></span><br><span class=\"line\">Total time: 1.494 secs</span><br></pre></td></tr></table></figure>\n<p><code>./build/libs/testGradle-0.0.1-SNAPSHOT.jar</code> 에 jar가 만들어졌다. 이걸로 직접 띄워서 호출해보자.</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ java -jar build/libs/testGradle-0.0.1-SNAPSHOT.jar</span><br></pre></td></tr></table></figure>\n<p>잘 뜨는 것을 확인 할 수 있다. 그런데 더이상 boot진영에서도 jsp파일을 그대로 쓰는걸 권장하고 있지 않으니 그냥 추천해주는 template engine로 넘어가야겠다는 생각이 들었다.</p>\n<h2><span id=\"2차-시도\">2차 시도</span></h2>\n<p>찾아보니 정말 <a href=\"%22http://www.baeldung.com/spring-template-engines%22\">여러가지 template engine</a>들이 있었다. 곰곰히 찾아보다 간단해 보이는 <a href=\"%22https://freemarker.apache.org/%22\">Free Marker</a>를 써보기로 했다.<br>\n설정을 추가해주는 것도 간단하다. 추가를 해보자.</p>\n<ul>\n<li>build.gradle</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">dependencies &#123;</span><br><span class=\"line\">    compile(<span class=\"string\">'org.springframework.boot:spring-boot-starter-freemarker'</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>그리고 jsp로 인한 설정들을 모두 제거해준다.</p>\n<ul>\n<li>application.properties</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">#spring.mvc.view.prefix=/WEB-INF/jsp/</span></span><br><span class=\"line\"><span class=\"comment\">#spring.mvc.view.suffix=.jsp</span></span><br></pre></td></tr></table></figure>\n<p>그리고 free marker 의 확장자는 <code>.ftl</code> 이다. 기본적인 파일 위치는 <code>resources/templates/</code> 이다.<br>\n이에 따라 파일명을 수정해주고 이동까지 하면 아래와 같이 된다.</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">.</span><br><span class=\"line\">├── build.gradle</span><br><span class=\"line\">├── gradle</span><br><span class=\"line\">│   └── wrapper</span><br><span class=\"line\">│       ├── gradle-wrapper.jar</span><br><span class=\"line\">│       └── gradle-wrapper.properties</span><br><span class=\"line\">├── gradlew</span><br><span class=\"line\">├── gradlew.bat</span><br><span class=\"line\">└── src</span><br><span class=\"line\">    ├── main</span><br><span class=\"line\">    │   ├── java</span><br><span class=\"line\">    │   │   └── com</span><br><span class=\"line\">    │   │       └── example</span><br><span class=\"line\">    │   │           └── demo</span><br><span class=\"line\">    │   │               ├── DemoApplication.java</span><br><span class=\"line\">    │   │               └── MyController.java</span><br><span class=\"line\">    │   └── resources</span><br><span class=\"line\">    │       ├── application.properties</span><br><span class=\"line\">    │       └── templates</span><br><span class=\"line\">    │           └── index.ftl</span><br><span class=\"line\">    └── <span class=\"built_in\">test</span></span><br><span class=\"line\">        └── java</span><br><span class=\"line\">            └── com</span><br><span class=\"line\">                └── example</span><br><span class=\"line\">                    └── demo</span><br><span class=\"line\">                        └── DemoApplicationTests.java</span><br></pre></td></tr></table></figure>\n<p>위와 같이 설정하고 빌드를 하고 jar파일을 띄워주면 1차시도와 동일한 결과가 나온다.<br>\n처음에는 jsp파일을 가지고 어떻게든 띄워보려고 노력했지만 다른 template engine을 보니 복잡한 jsp파일이 아니라면 굳이 사용하지 않아도 될거라는 생각이 들었다.</p>\n<h2><span id=\"결론\">결론</span></h2>\n<p>아무래도 이제는 spring boot를 사용하면서 jsp를 사용하기는 어려울듯 싶다. 나도 결국에는 다른 template engine을 사용했는데 설정부터 적용이 너무 편해진 느낌.<br>\n각 template engine마다 문법이 조금 달라서 개인의 기호에 맞게 써야겠다만…(예전에 node를 할 때 <a href=\"%22https://www.npmjs.com/package/jade%22\">jade</a>같은 경우엔 적잖은 충격을 받았었다.)<br>\n아무래도 아직까지는 html친화적인 문법이 조금은 더 익숙한 느낌이다.</p>\n","site":{"data":{}},"excerpt":"","more":"<h3>view를 추가해야한다.</h3>\n<p>spring 을 사용하다가 spring boot 로 넘어오면서 front, back 을 나누어서 백단은 나름 Restful 하게 해서 api 콜만 처리하는 방식으로 변경하는 중이다.(front 는 react로 구성하는 중이다.) 그래서 spring boot 에서는 따로 view 처리해야할 일이 없었는데 기존에 spring 에서 view 처리를 해주는 요청을 가져와야 할일이 생겼다.<br>\n하지만 찾아보니 기존에 spring 에서 하던 방법으로는 안될 것 같다.<br>\n왜냐하면 <a href=\"https://docs.spring.io/spring-boot/docs/current/reference/html/boot-features-developing-web-applications.html#boot-features-jsp-limitations\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">spring boot 에서는 jar 로 사용할 때는 jsp를 사용할 수 없다고 한다.</a><br>\n내용을 읽어보니 boot에 내장 tomcat에 하드코딩 패턴때문에 jar형식으로는 webapp내용을 가져올 수 없다고 한다. 그리고 공식적으로 jsp를 지원하지 않는다고 한다. boot에서 밀고 있는 template engine 들이 여러개 있었는데 간단한 view 하나 추가하는데 공수가 많이 들게되면 좋지 않을꺼라 생각해서 jsp로 view 를 구성하는 방법을 시도해보았다.<br>\n일단 작업을 시작하기 전에 현재 사용하고 있는 버전들을 정리하고 간다.</p>\n<h3>사용하고 있는 버전은 다음과 같다.</h3>\n<ul>\n<li>spring boot 1.5.7</li>\n<li>gradle 4.4</li>\n</ul>\n<h3>나중에는 없어질 view 이지만</h3>\n<p>front작업이 react로 완료되면 이 view 는 더이상 필요하지 않다.<br>\n그래서 나는 최소한의 공수로 기존에 있는 jsp 파일을 사용하여 가볍게 포팅만 하고자 했다.</p>\n<hr>\n<h2>1차 시도</h2>\n<p>spring boot 에서 jsp view를 사용하기 위해 spring에서 구성하는 방법과 추가적으로 필요한 설정들을 해주었다.<br>\nspring boot 의 내장 tomcat에는 jsp parser가 없기 때문에 의존 패키지를 추가해주어야 한다.</p>\n<ul>\n<li>build.gradle</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">derendencies &#123;</span><br><span class=\"line\">    compile(<span class=\"string\">'javax.servlet:jstl'</span>)</span><br><span class=\"line\">    compile(<span class=\"string\">\"org.apache.tomcat.embed:tomcat-embed-jasper\"</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>그리고 구조는 아래와 같이 구성했다. main밑에 webapp폴더를 추가해서 jsp파일을 추가해준다.</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">.</span><br><span class=\"line\">├── build.gradle</span><br><span class=\"line\">├── gradlew</span><br><span class=\"line\">├── gradlew.bat</span><br><span class=\"line\">└── src</span><br><span class=\"line\">    ├── main</span><br><span class=\"line\">    │   ├── java</span><br><span class=\"line\">    │   │   └── com</span><br><span class=\"line\">    │   │       └── example</span><br><span class=\"line\">    │   │           └── demo</span><br><span class=\"line\">    │   │               ├── DemoApplication.java</span><br><span class=\"line\">    │   │               └── MyController.java</span><br><span class=\"line\">    │   ├── resources</span><br><span class=\"line\">    │   │   └── application.properties</span><br><span class=\"line\">    │   └── webapp</span><br><span class=\"line\">    │       └── WEB-INF</span><br><span class=\"line\">    │           └── jsp</span><br><span class=\"line\">    │               └── index.jsp</span><br><span class=\"line\">    └── <span class=\"built_in\">test</span></span><br></pre></td></tr></table></figure>\n<p>spring boot 는 webapp의 위치를 모르기 때문에 설정파일에 경로를 명시해주어야 한다.</p>\n<ul>\n<li>application.properties</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">spring.mvc.view.prefix=/WEB-INF/jsp/</span><br><span class=\"line\">spring.mvc.view.suffix=.jsp</span><br></pre></td></tr></table></figure>\n<p>설정은 다했다. 이제 controller에서 view를 호출해보자.</p>\n<ul>\n<li>MyController.java</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> com.example.demo;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.stereotype.Controller;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.web.bind.annotation.RequestMapping;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.web.servlet.ModelAndView;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Controller</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyController</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@RequestMapping</span>(value = <span class=\"string\">\"/\"</span>)</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> ModelAndView <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        ModelAndView view = <span class=\"keyword\">new</span> ModelAndView(<span class=\"string\">\"index\"</span>);</span><br><span class=\"line\">        view.addObject(<span class=\"string\">\"text\"</span>, <span class=\"string\">\"world\"</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> view;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>설정파일에서 prefix, suffix를 적어주었기 때문에 view이름은 파일이름만 넣어주면 된다.</p>\n<ul>\n<li>index.jsp</li>\n</ul>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">html</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">body</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">h1</span>&gt;</span>Hello world<span class=\"tag\">&lt;/<span class=\"name\">h1</span>&gt;</span></span><br><span class=\"line\">        hello $&#123;text&#125;</span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">body</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">html</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>이제 bootRun 을 하면 build 를 하고 테스트를 해볼 수 있다.</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ ./gradlew clean bootRun</span><br><span class=\"line\">:compileJava </span><br><span class=\"line\">:processResources </span><br><span class=\"line\">:classes </span><br><span class=\"line\">:findMainClass</span><br><span class=\"line\">:bootRun</span><br></pre></td></tr></table></figure>\n<ul>\n<li>localhost:8080/</li>\n</ul>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Hello world</span><br><span class=\"line\"></span><br><span class=\"line\">hello world</span><br></pre></td></tr></table></figure>\n<p>build 명령어로 jar파일을 만들어 보자.</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ ./gradlew clean build</span><br><span class=\"line\">:compileJava </span><br><span class=\"line\">:processResources </span><br><span class=\"line\">:classes </span><br><span class=\"line\">:findMainClass</span><br><span class=\"line\">:jar</span><br><span class=\"line\">:bootRepackage</span><br><span class=\"line\">:assemble</span><br><span class=\"line\">:compileTestJava </span><br><span class=\"line\">:processTestResources NO-SOURCE</span><br><span class=\"line\">:testClasses </span><br><span class=\"line\">:<span class=\"built_in\">test</span> </span><br><span class=\"line\">:check </span><br><span class=\"line\">:build</span><br><span class=\"line\"></span><br><span class=\"line\">BUILD SUCCESSFUL</span><br><span class=\"line\"></span><br><span class=\"line\">Total time: 1.494 secs</span><br></pre></td></tr></table></figure>\n<p><code>./build/libs/testGradle-0.0.1-SNAPSHOT.jar</code> 에 jar가 만들어졌다. 이걸로 직접 띄워서 호출해보자.</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ java -jar build/libs/testGradle-0.0.1-SNAPSHOT.jar</span><br></pre></td></tr></table></figure>\n<p>잘 뜨는 것을 확인 할 수 있다. 그런데 더이상 boot진영에서도 jsp파일을 그대로 쓰는걸 권장하고 있지 않으니 그냥 추천해주는 template engine로 넘어가야겠다는 생각이 들었다.</p>\n<h2>2차 시도</h2>\n<p>찾아보니 정말 <a href=\"%22http://www.baeldung.com/spring-template-engines%22\">여러가지 template engine</a>들이 있었다. 곰곰히 찾아보다 간단해 보이는 <a href=\"%22https://freemarker.apache.org/%22\">Free Marker</a>를 써보기로 했다.<br>\n설정을 추가해주는 것도 간단하다. 추가를 해보자.</p>\n<ul>\n<li>build.gradle</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">dependencies &#123;</span><br><span class=\"line\">    compile(<span class=\"string\">'org.springframework.boot:spring-boot-starter-freemarker'</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>그리고 jsp로 인한 설정들을 모두 제거해준다.</p>\n<ul>\n<li>application.properties</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">#spring.mvc.view.prefix=/WEB-INF/jsp/</span></span><br><span class=\"line\"><span class=\"comment\">#spring.mvc.view.suffix=.jsp</span></span><br></pre></td></tr></table></figure>\n<p>그리고 free marker 의 확장자는 <code>.ftl</code> 이다. 기본적인 파일 위치는 <code>resources/templates/</code> 이다.<br>\n이에 따라 파일명을 수정해주고 이동까지 하면 아래와 같이 된다.</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">.</span><br><span class=\"line\">├── build.gradle</span><br><span class=\"line\">├── gradle</span><br><span class=\"line\">│   └── wrapper</span><br><span class=\"line\">│       ├── gradle-wrapper.jar</span><br><span class=\"line\">│       └── gradle-wrapper.properties</span><br><span class=\"line\">├── gradlew</span><br><span class=\"line\">├── gradlew.bat</span><br><span class=\"line\">└── src</span><br><span class=\"line\">    ├── main</span><br><span class=\"line\">    │   ├── java</span><br><span class=\"line\">    │   │   └── com</span><br><span class=\"line\">    │   │       └── example</span><br><span class=\"line\">    │   │           └── demo</span><br><span class=\"line\">    │   │               ├── DemoApplication.java</span><br><span class=\"line\">    │   │               └── MyController.java</span><br><span class=\"line\">    │   └── resources</span><br><span class=\"line\">    │       ├── application.properties</span><br><span class=\"line\">    │       └── templates</span><br><span class=\"line\">    │           └── index.ftl</span><br><span class=\"line\">    └── <span class=\"built_in\">test</span></span><br><span class=\"line\">        └── java</span><br><span class=\"line\">            └── com</span><br><span class=\"line\">                └── example</span><br><span class=\"line\">                    └── demo</span><br><span class=\"line\">                        └── DemoApplicationTests.java</span><br></pre></td></tr></table></figure>\n<p>위와 같이 설정하고 빌드를 하고 jar파일을 띄워주면 1차시도와 동일한 결과가 나온다.<br>\n처음에는 jsp파일을 가지고 어떻게든 띄워보려고 노력했지만 다른 template engine을 보니 복잡한 jsp파일이 아니라면 굳이 사용하지 않아도 될거라는 생각이 들었다.</p>\n<h2>결론</h2>\n<p>아무래도 이제는 spring boot를 사용하면서 jsp를 사용하기는 어려울듯 싶다. 나도 결국에는 다른 template engine을 사용했는데 설정부터 적용이 너무 편해진 느낌.<br>\n각 template engine마다 문법이 조금 달라서 개인의 기호에 맞게 써야겠다만…(예전에 node를 할 때 <a href=\"%22https://www.npmjs.com/package/jade%22\">jade</a>같은 경우엔 적잖은 충격을 받았었다.)<br>\n아무래도 아직까지는 html친화적인 문법이 조금은 더 익숙한 느낌이다.</p>\n"},{"title":"spring boot 에서 redis pub/sub 을 이용해 동적으로 value 사용하기","catalog":true,"date":"2018-07-16T06:52:31.000Z","subtitle":null,"header-img":"/img/header_img/bg.png","_content":"\n배포없이 설정값을 변경해야하는 일이 생겼다. 설정값 하나 때문에 전체 api 서버를 재배포 해야하는건 부담이 있었고 실시간으로 설정값을 변경해서 바로바로 코드에 반영해야 하는 일이었다. 이를 구현하기 위해서는 여러가지 방법이 있는데 그중에서 가장 손이 덜가면서 부하가 덜 드는 방법으로 구현을 하고자 했다. 이런 저런 방법을 찾아보면서 찾게 된 방법들이다.  \n\n1. [redis](https://redis.io/commands/get) 를 이용해 값을 가져오는 방식\n2. [spring cloud](http://projects.spring.io/spring-cloud/) 를 이용해 설정값을 전파 방는 방식\n3. [Apache commons configuration](https://commons.apache.org/proper/commons-configuration/) 을 이용해 외부파일에 설정값을 전파하는 방식\n\n1번의 경우는 구현이 가장 간단한 방식이다. key 값으로 원하는 설정값을 넣어 바로 꺼내어 사용하면 되기 때문이다. 하지만 redis 에 계속해서 조회를 하기 때문에 부하가 올라감 염려가 있다. 자주 불리는 endpoint 가 아니라면 괜찮지만 login 같이 조회수가 높은 endpoint 라면 단순한 로직 추가임에도 로드가 올라가 redis 에 부담을 줄 수가 있어 이 방법은 최후의 보루(?) 로 남겨두기로 했다.  \n2번의 경우는 spring cloud 를 사용해서 yml 파일들을 spring cloud config server 에 올려두고 spring cloud client 들이 해당 설정 파일을 받아가는 형식이라 지금 구현하고자 하는 바를 만족한다. 하지만 spring cloud 는 이런 기능 외에 훨씬 더 많은 기능들을 제공하고 있는데, 동적으로 설정값 하나 넣자고 배보다 배꼽이 더 큰 구현을 하기엔 부적합하다고 판단 되었다.   \n3번의 경우는 spring boot 외부에 설정파일을 따로 두어 파일을 읽어 값을 사용하는 방식이다. 역시 지금 구현하고자 하는 목표와 비슷하기도 하고 구현의 난이도나 범위가 크지 않았지만 파일을 주기적으로 읽어야 하는 부담 (file IO 는 부하가 크고 속도도 느린 편이다.) 이 있었고, 전체 api 서버에 변경된 설정값이 담긴 파일을 전파하려면 [ansible](https://www.ansible.com/) 이나 별도의 구현을 통해 전체 서버에 전달을 해주어야 하는데, 이 역시 구현체보다 구현을 해야하는 범위가 넘어서버리게 되어버려 마음에 들지 않았다.    \n마감 시간이 급박한건 아니었지만 그렇다고 해서 큰일을 벌일 정도의 규모의 일감이 아니었기 때문에 적당한 선에서 작업하고 넘어가는 것이 좋다고 생각했다. 회사 동료들과 어떻게 할까 고민하다가 문득 redis pub/sub 을 이용해 메모리에 설정값들을 가지고 있으면 어떨까 생각을 했다. 필요할 때만 redis litenser 가 사용되고 file IO 보다 가벼우며 과도하게 redis connection 을 맺지 않아 부하도 크지 않아 괜찮을거라 판단했다.  \n~~다들 아시겠지만 Reactive 의 publisher subscriber 가 아니다!~~\n\n## 시나리오 순서 \n각 api 서버당 약속된 channel 로 redis 를 통해 subscribe 한다.  \n서버가 올라간 직후에는 로컬 메모리에 데이터가 없으니 redis 를 통해 publish 해준다.  \n로컬 메모리에 있는 설정값을 사용하고, 필요에 의해 변경될 사항이 있다면 다시 publish 해준다.  \n(사족) redis publish 당시에 value 값을 SET 해주고 로컬 메모리에서 접근이 실패했다면 redis 에서 key 값으로 GET 을 한다.  \n\n방어코드는 짜기 나름이다. `사족` 부분에서의 동작은 넣어도 되고 안넣어도 그만이다. 서비스단에서 로컬 메모리에 key 에 대응하는 값이 없을 때에 대한 처리를 잘 해준다면 굳이 추가하지 않아도 되는 기능이다.  \n\n### 환경 설정\n\n```\ngradle 4.8.1\nspring boot 2.0.3.RELEASE\nredis 3.2.3\nlettuce 5.0.4.RELEASE\n```\n\nredis java client 는 lettuce 를 사용하였다. 사내에서는 기본적으로 jedis 를 사용하는데, redis 의 버전 대응도 느린편이고 async 에 대한 지원도 아직 없는 상태이다. 이번 포스트에서는 redis 의 async 부분을 다루지는 않지만, (다른 포스트에서는 살짝 다룬 부분이 있다) 앞으로 redis client 를 사용할 때는 jedis 는 점점 더 손이 덜 갈듯 싶다.  \n\n### build.gradle\n  \n```gradle\ndependencies {\n    compile('org.springframework.boot:spring-boot-starter')\n    compile('org.springframework.boot:spring-boot-starter-web')\n    compile('io.lettuce:lettuce-core')\n    compile('com.google.code.gson:gson:2.8.0')\n    compile('org.apache.logging.log4j:log4j-core:2.9.1')\n    compileOnly('org.projectlombok:lombok')\n\n    testCompile('org.springframework.boot:spring-boot-starter-test')\n}\n```\n\nredis 와 이를 전달해 줄 수 있는 json 으로 gson 을 사용하기로 했다. 여기서도 역시 jackson 과의 비교가 들어가는데 이번에 구현해야할 기능에서는 간단한 기능들만 필요하므로 gson 을 사용하는 것으로 한다.    \n[jackson vs gson](http://www.baeldung.com/jackson-vs-gson) 에서 기능이나 사용에 대한 차이를 볼 수 있다.  \n\n\n## pub/sub 을 이용해 데이터 갱신하기 \n\n### thread, subscriber 초기화및 등록\n\n로컬에 스레드와 subscriber 를 최초에 초기화 해주도록 한다.\n\n```java\nprivate CustomSubscriber customSubscriber;\nprivate Thread localThread;\nprivate RedisService redisService;\n\nprivate CustomSubscriber getCustomSubscriber() {\n    if (customSubscriber == null) {\n        customSubscriber = new CustomSubscriber() {\n            @Override\n            public void message(String channel, String message) {\n                update(message);\n            }\n        };\n    }\n    return customSubscriber;\n}\n\n@PostConstruct\npublic void init() {\n    if (localThread == null) {\n        localThread = new Thread(() -> redisService.subscribe(CHANNEL, getCustomSubscriber()));\n    }\n    localThread.start();\n}\n\n@PreDestroy\npublic void destroy() {\n    redisService.unSubscribe(getCustomSubscriber());\n}\n\n```\n\n- redis subscribe 을 하게 되면 blocking 이 걸리게 되므로 별도의 thread 를 생성해 subscribe 하도록 한다.   \n- localThread 는 최초에 하나의 subscriber 를 생성해 구독을 하고, destroy 될 때 구독을 해지한다.  \n- 등록된 subscriber 에서는 받은 메세지를 `update` 메소드로 전달해준다.  \n  \n### message 전달 및 데이터 갱신 \n  \n```java\nprivate void update(String message) {\n    try {\n        String[] split = message.split(\"\\\\|\");\n        String key = split[0];\n        String value = split[1];\n        this.cacheMap.put(key, value);\n        log.debug(\"update success : \" + message);\n    } catch (Exception e) {\n        log.warn(\"update fail : \" + message, e);\n    }\n}\n    \npublic Long publish(String key, String value) {\n    String message = key + \"|\" + value;\n    Long publish = redisService.publish(CHANNEL, message);\n    return publish;\n}\n```  \n\n- publish 와 subscribe 에서는 약속된 메세지 포멧을 가지도록 한다. 여기서는 간단한 key, value 형태로만 가져할 수 있도록 message 를 `|` 를 구분자로 가져가기로 했다. 즉, `message = key|value` 로 약속을 하고 파싱을 해서 사용하도록 한다.  \n- subscribe 에서 받아온 message 를 `|` 구분자로 쪼개 key 와 value 를 가져와 로컬 메모리에 올리도록 한다. \n\n### 데이터 제공\n\n```java\nprivate ConcurrentHashMap<String, String> cacheMap = new ConcurrentHashMap<>();\nprivate static Gson gson = new GsonBuilder().setFieldNamingPolicy(FieldNamingPolicy.LOWER_CASE_WITH_UNDERSCORES)\n        .setDateFormat(\"yyyy-MM-dd HH:mm:ss\")\n        .disableHtmlEscaping()\n        .excludeFieldsWithModifiers(Modifier.TRANSIENT)\n        .create();\n\npublic <T> T get(String key, Class<T> tClass) {\n    try {\n        String valueString = this.cacheMap.get(key);\n        return gson.fromJson(valueString, tClass);\n    } catch (Exception e) {\n        log.warn(\"get error > key \" + key, e);\n        return null;\n    }\n}\n```\n\n- get 함수를 통해 로컬 메모리에 있는 데이터를 제공해주는데, 데이터가 갱신되는 도중에 여러 스레드가 동시에 접근하면서 정합성을 맞춰주기 위해 `ConcurrentHashMap` 를 사용했다.  \n\n참고로 `get` 메소드는 Optional 로 감싸주면 더욱 좋다. null 을 반환하는 것보다 Optional.empty() 를 반환해주는 모양이 외부에서도 사용할 때 좀 더 편하게 사용할 수 있을 것이다. 위의 `get` 메소드를 조금 고쳐보자.  \n\n### 조금 더 편하게 데이터 제공\n\n```\npublic <T> Optional<T> get(String key, Class<T> tClass) {\n    try {\n        String valueString = this.cacheMap.get(key);\n        return Optional.of(gson.fromJson(valueString, tClass));\n    } catch (Exception e) {\n        log.warn(\"get error > key \" + key, e);\n        return Optional.empty();\n    }\n}\n\npublic <T> T get(String key, Class<T> tClass, T defaultValue) {\n    return get(key, tClass).orElse(defaultValue);\n}\n```\n\n추가적으로 메모리에 없는 key 값을 조회하고자 할 때 null 이나 Optional.empty() 를 반환하면 외부에서는 이에 대한 후속 처리를 해줘야 한다. 이 때 defaultValue 를 지정할 수 있게 해준다면 사용하는 쪽 로직이 좀 더 편해질 수 있다.  \n\n## 결론\n\n이제 약속된 채널로 publish 를 하면 subscribe 하고 있는 모든 서버들에서 일괄적으로 특정 설정값을 바꿔 사용할 수 있다. 지금은 단순하게 key, value 값을 동적으로 변경하는 곳에 pub/sub 을 사용하였지만, 조금만 응용하면 여러가지 부분에 사용할 수 있을 것이다. 예제 소스는 [여기](https://github.com/nevercaution/spring-boot-redis-pub-sub) 에서 확인할 수 있다.   \n\n## 추신\nredis pub/sub 을 이용하면 기존에 사용하고 있던 부분에서 전혀 다른 페러다임으로 동적인 데이터들을 갱신할 수 있다. 현재 사내에서는 레디스 데이터 캐싱을 시간단위로 기록하고 있는데, 잘 활용하면 실시간으로 캐시 데이터에 반영을 할 수도 있을거라 기대할 수 있다. 하지만 모든 과하면 안된다. publish 하는 채널들이 많아지고 subscribe 하는 구독자들이 많아지거나, redis cluster 에서 subscription 을 과도하게 한다면 오히려 안좋은 결과를 가져올 것이다. 그러므로 충분히 검토한 후 각자 목적에 맞는 곳에 사용하는 것이 좋다고 생각된다.  \n\n\n","source":"_posts/spring-boot-redis-pub-sub.md","raw":"---\ntitle: spring boot 에서 redis pub/sub 을 이용해 동적으로 value 사용하기\ncatalog: true\ndate: 2018-07-16 15:52:31\nsubtitle:\nheader-img: \"/img/header_img/bg.png\"\ntags:\n- redis\n- pubsub\n- springboot\n- dynamicConfiguration\n- lettuce\n---\n\n배포없이 설정값을 변경해야하는 일이 생겼다. 설정값 하나 때문에 전체 api 서버를 재배포 해야하는건 부담이 있었고 실시간으로 설정값을 변경해서 바로바로 코드에 반영해야 하는 일이었다. 이를 구현하기 위해서는 여러가지 방법이 있는데 그중에서 가장 손이 덜가면서 부하가 덜 드는 방법으로 구현을 하고자 했다. 이런 저런 방법을 찾아보면서 찾게 된 방법들이다.  \n\n1. [redis](https://redis.io/commands/get) 를 이용해 값을 가져오는 방식\n2. [spring cloud](http://projects.spring.io/spring-cloud/) 를 이용해 설정값을 전파 방는 방식\n3. [Apache commons configuration](https://commons.apache.org/proper/commons-configuration/) 을 이용해 외부파일에 설정값을 전파하는 방식\n\n1번의 경우는 구현이 가장 간단한 방식이다. key 값으로 원하는 설정값을 넣어 바로 꺼내어 사용하면 되기 때문이다. 하지만 redis 에 계속해서 조회를 하기 때문에 부하가 올라감 염려가 있다. 자주 불리는 endpoint 가 아니라면 괜찮지만 login 같이 조회수가 높은 endpoint 라면 단순한 로직 추가임에도 로드가 올라가 redis 에 부담을 줄 수가 있어 이 방법은 최후의 보루(?) 로 남겨두기로 했다.  \n2번의 경우는 spring cloud 를 사용해서 yml 파일들을 spring cloud config server 에 올려두고 spring cloud client 들이 해당 설정 파일을 받아가는 형식이라 지금 구현하고자 하는 바를 만족한다. 하지만 spring cloud 는 이런 기능 외에 훨씬 더 많은 기능들을 제공하고 있는데, 동적으로 설정값 하나 넣자고 배보다 배꼽이 더 큰 구현을 하기엔 부적합하다고 판단 되었다.   \n3번의 경우는 spring boot 외부에 설정파일을 따로 두어 파일을 읽어 값을 사용하는 방식이다. 역시 지금 구현하고자 하는 목표와 비슷하기도 하고 구현의 난이도나 범위가 크지 않았지만 파일을 주기적으로 읽어야 하는 부담 (file IO 는 부하가 크고 속도도 느린 편이다.) 이 있었고, 전체 api 서버에 변경된 설정값이 담긴 파일을 전파하려면 [ansible](https://www.ansible.com/) 이나 별도의 구현을 통해 전체 서버에 전달을 해주어야 하는데, 이 역시 구현체보다 구현을 해야하는 범위가 넘어서버리게 되어버려 마음에 들지 않았다.    \n마감 시간이 급박한건 아니었지만 그렇다고 해서 큰일을 벌일 정도의 규모의 일감이 아니었기 때문에 적당한 선에서 작업하고 넘어가는 것이 좋다고 생각했다. 회사 동료들과 어떻게 할까 고민하다가 문득 redis pub/sub 을 이용해 메모리에 설정값들을 가지고 있으면 어떨까 생각을 했다. 필요할 때만 redis litenser 가 사용되고 file IO 보다 가벼우며 과도하게 redis connection 을 맺지 않아 부하도 크지 않아 괜찮을거라 판단했다.  \n~~다들 아시겠지만 Reactive 의 publisher subscriber 가 아니다!~~\n\n## 시나리오 순서 \n각 api 서버당 약속된 channel 로 redis 를 통해 subscribe 한다.  \n서버가 올라간 직후에는 로컬 메모리에 데이터가 없으니 redis 를 통해 publish 해준다.  \n로컬 메모리에 있는 설정값을 사용하고, 필요에 의해 변경될 사항이 있다면 다시 publish 해준다.  \n(사족) redis publish 당시에 value 값을 SET 해주고 로컬 메모리에서 접근이 실패했다면 redis 에서 key 값으로 GET 을 한다.  \n\n방어코드는 짜기 나름이다. `사족` 부분에서의 동작은 넣어도 되고 안넣어도 그만이다. 서비스단에서 로컬 메모리에 key 에 대응하는 값이 없을 때에 대한 처리를 잘 해준다면 굳이 추가하지 않아도 되는 기능이다.  \n\n### 환경 설정\n\n```\ngradle 4.8.1\nspring boot 2.0.3.RELEASE\nredis 3.2.3\nlettuce 5.0.4.RELEASE\n```\n\nredis java client 는 lettuce 를 사용하였다. 사내에서는 기본적으로 jedis 를 사용하는데, redis 의 버전 대응도 느린편이고 async 에 대한 지원도 아직 없는 상태이다. 이번 포스트에서는 redis 의 async 부분을 다루지는 않지만, (다른 포스트에서는 살짝 다룬 부분이 있다) 앞으로 redis client 를 사용할 때는 jedis 는 점점 더 손이 덜 갈듯 싶다.  \n\n### build.gradle\n  \n```gradle\ndependencies {\n    compile('org.springframework.boot:spring-boot-starter')\n    compile('org.springframework.boot:spring-boot-starter-web')\n    compile('io.lettuce:lettuce-core')\n    compile('com.google.code.gson:gson:2.8.0')\n    compile('org.apache.logging.log4j:log4j-core:2.9.1')\n    compileOnly('org.projectlombok:lombok')\n\n    testCompile('org.springframework.boot:spring-boot-starter-test')\n}\n```\n\nredis 와 이를 전달해 줄 수 있는 json 으로 gson 을 사용하기로 했다. 여기서도 역시 jackson 과의 비교가 들어가는데 이번에 구현해야할 기능에서는 간단한 기능들만 필요하므로 gson 을 사용하는 것으로 한다.    \n[jackson vs gson](http://www.baeldung.com/jackson-vs-gson) 에서 기능이나 사용에 대한 차이를 볼 수 있다.  \n\n\n## pub/sub 을 이용해 데이터 갱신하기 \n\n### thread, subscriber 초기화및 등록\n\n로컬에 스레드와 subscriber 를 최초에 초기화 해주도록 한다.\n\n```java\nprivate CustomSubscriber customSubscriber;\nprivate Thread localThread;\nprivate RedisService redisService;\n\nprivate CustomSubscriber getCustomSubscriber() {\n    if (customSubscriber == null) {\n        customSubscriber = new CustomSubscriber() {\n            @Override\n            public void message(String channel, String message) {\n                update(message);\n            }\n        };\n    }\n    return customSubscriber;\n}\n\n@PostConstruct\npublic void init() {\n    if (localThread == null) {\n        localThread = new Thread(() -> redisService.subscribe(CHANNEL, getCustomSubscriber()));\n    }\n    localThread.start();\n}\n\n@PreDestroy\npublic void destroy() {\n    redisService.unSubscribe(getCustomSubscriber());\n}\n\n```\n\n- redis subscribe 을 하게 되면 blocking 이 걸리게 되므로 별도의 thread 를 생성해 subscribe 하도록 한다.   \n- localThread 는 최초에 하나의 subscriber 를 생성해 구독을 하고, destroy 될 때 구독을 해지한다.  \n- 등록된 subscriber 에서는 받은 메세지를 `update` 메소드로 전달해준다.  \n  \n### message 전달 및 데이터 갱신 \n  \n```java\nprivate void update(String message) {\n    try {\n        String[] split = message.split(\"\\\\|\");\n        String key = split[0];\n        String value = split[1];\n        this.cacheMap.put(key, value);\n        log.debug(\"update success : \" + message);\n    } catch (Exception e) {\n        log.warn(\"update fail : \" + message, e);\n    }\n}\n    \npublic Long publish(String key, String value) {\n    String message = key + \"|\" + value;\n    Long publish = redisService.publish(CHANNEL, message);\n    return publish;\n}\n```  \n\n- publish 와 subscribe 에서는 약속된 메세지 포멧을 가지도록 한다. 여기서는 간단한 key, value 형태로만 가져할 수 있도록 message 를 `|` 를 구분자로 가져가기로 했다. 즉, `message = key|value` 로 약속을 하고 파싱을 해서 사용하도록 한다.  \n- subscribe 에서 받아온 message 를 `|` 구분자로 쪼개 key 와 value 를 가져와 로컬 메모리에 올리도록 한다. \n\n### 데이터 제공\n\n```java\nprivate ConcurrentHashMap<String, String> cacheMap = new ConcurrentHashMap<>();\nprivate static Gson gson = new GsonBuilder().setFieldNamingPolicy(FieldNamingPolicy.LOWER_CASE_WITH_UNDERSCORES)\n        .setDateFormat(\"yyyy-MM-dd HH:mm:ss\")\n        .disableHtmlEscaping()\n        .excludeFieldsWithModifiers(Modifier.TRANSIENT)\n        .create();\n\npublic <T> T get(String key, Class<T> tClass) {\n    try {\n        String valueString = this.cacheMap.get(key);\n        return gson.fromJson(valueString, tClass);\n    } catch (Exception e) {\n        log.warn(\"get error > key \" + key, e);\n        return null;\n    }\n}\n```\n\n- get 함수를 통해 로컬 메모리에 있는 데이터를 제공해주는데, 데이터가 갱신되는 도중에 여러 스레드가 동시에 접근하면서 정합성을 맞춰주기 위해 `ConcurrentHashMap` 를 사용했다.  \n\n참고로 `get` 메소드는 Optional 로 감싸주면 더욱 좋다. null 을 반환하는 것보다 Optional.empty() 를 반환해주는 모양이 외부에서도 사용할 때 좀 더 편하게 사용할 수 있을 것이다. 위의 `get` 메소드를 조금 고쳐보자.  \n\n### 조금 더 편하게 데이터 제공\n\n```\npublic <T> Optional<T> get(String key, Class<T> tClass) {\n    try {\n        String valueString = this.cacheMap.get(key);\n        return Optional.of(gson.fromJson(valueString, tClass));\n    } catch (Exception e) {\n        log.warn(\"get error > key \" + key, e);\n        return Optional.empty();\n    }\n}\n\npublic <T> T get(String key, Class<T> tClass, T defaultValue) {\n    return get(key, tClass).orElse(defaultValue);\n}\n```\n\n추가적으로 메모리에 없는 key 값을 조회하고자 할 때 null 이나 Optional.empty() 를 반환하면 외부에서는 이에 대한 후속 처리를 해줘야 한다. 이 때 defaultValue 를 지정할 수 있게 해준다면 사용하는 쪽 로직이 좀 더 편해질 수 있다.  \n\n## 결론\n\n이제 약속된 채널로 publish 를 하면 subscribe 하고 있는 모든 서버들에서 일괄적으로 특정 설정값을 바꿔 사용할 수 있다. 지금은 단순하게 key, value 값을 동적으로 변경하는 곳에 pub/sub 을 사용하였지만, 조금만 응용하면 여러가지 부분에 사용할 수 있을 것이다. 예제 소스는 [여기](https://github.com/nevercaution/spring-boot-redis-pub-sub) 에서 확인할 수 있다.   \n\n## 추신\nredis pub/sub 을 이용하면 기존에 사용하고 있던 부분에서 전혀 다른 페러다임으로 동적인 데이터들을 갱신할 수 있다. 현재 사내에서는 레디스 데이터 캐싱을 시간단위로 기록하고 있는데, 잘 활용하면 실시간으로 캐시 데이터에 반영을 할 수도 있을거라 기대할 수 있다. 하지만 모든 과하면 안된다. publish 하는 채널들이 많아지고 subscribe 하는 구독자들이 많아지거나, redis cluster 에서 subscription 을 과도하게 한다면 오히려 안좋은 결과를 가져올 것이다. 그러므로 충분히 검토한 후 각자 목적에 맞는 곳에 사용하는 것이 좋다고 생각된다.  \n\n\n","slug":"spring-boot-redis-pub-sub","published":1,"updated":"2018-12-24T04:50:49.960Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjq98soq8000j8ghhgeheffcp","content":"<p>배포없이 설정값을 변경해야하는 일이 생겼다. 설정값 하나 때문에 전체 api 서버를 재배포 해야하는건 부담이 있었고 실시간으로 설정값을 변경해서 바로바로 코드에 반영해야 하는 일이었다. 이를 구현하기 위해서는 여러가지 방법이 있는데 그중에서 가장 손이 덜가면서 부하가 덜 드는 방법으로 구현을 하고자 했다. 이런 저런 방법을 찾아보면서 찾게 된 방법들이다.</p>\n<ol>\n<li><a href=\"https://redis.io/commands/get\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">redis</a> 를 이용해 값을 가져오는 방식</li>\n<li><a href=\"http://projects.spring.io/spring-cloud/\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">spring cloud</a> 를 이용해 설정값을 전파 방는 방식</li>\n<li><a href=\"https://commons.apache.org/proper/commons-configuration/\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">Apache commons configuration</a> 을 이용해 외부파일에 설정값을 전파하는 방식</li>\n</ol>\n<p>1번의 경우는 구현이 가장 간단한 방식이다. key 값으로 원하는 설정값을 넣어 바로 꺼내어 사용하면 되기 때문이다. 하지만 redis 에 계속해서 조회를 하기 때문에 부하가 올라감 염려가 있다. 자주 불리는 endpoint 가 아니라면 괜찮지만 login 같이 조회수가 높은 endpoint 라면 단순한 로직 추가임에도 로드가 올라가 redis 에 부담을 줄 수가 있어 이 방법은 최후의 보루(?) 로 남겨두기로 했다.<br>\n2번의 경우는 spring cloud 를 사용해서 yml 파일들을 spring cloud config server 에 올려두고 spring cloud client 들이 해당 설정 파일을 받아가는 형식이라 지금 구현하고자 하는 바를 만족한다. 하지만 spring cloud 는 이런 기능 외에 훨씬 더 많은 기능들을 제공하고 있는데, 동적으로 설정값 하나 넣자고 배보다 배꼽이 더 큰 구현을 하기엔 부적합하다고 판단 되었다.<br>\n3번의 경우는 spring boot 외부에 설정파일을 따로 두어 파일을 읽어 값을 사용하는 방식이다. 역시 지금 구현하고자 하는 목표와 비슷하기도 하고 구현의 난이도나 범위가 크지 않았지만 파일을 주기적으로 읽어야 하는 부담 (file IO 는 부하가 크고 속도도 느린 편이다.) 이 있었고, 전체 api 서버에 변경된 설정값이 담긴 파일을 전파하려면 <a href=\"https://www.ansible.com/\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">ansible</a> 이나 별도의 구현을 통해 전체 서버에 전달을 해주어야 하는데, 이 역시 구현체보다 구현을 해야하는 범위가 넘어서버리게 되어버려 마음에 들지 않았다.<br>\n마감 시간이 급박한건 아니었지만 그렇다고 해서 큰일을 벌일 정도의 규모의 일감이 아니었기 때문에 적당한 선에서 작업하고 넘어가는 것이 좋다고 생각했다. 회사 동료들과 어떻게 할까 고민하다가 문득 redis pub/sub 을 이용해 메모리에 설정값들을 가지고 있으면 어떨까 생각을 했다. 필요할 때만 redis litenser 가 사용되고 file IO 보다 가벼우며 과도하게 redis connection 을 맺지 않아 부하도 크지 않아 괜찮을거라 판단했다.<br>\n<s>다들 아시겠지만 Reactive 의 publisher subscriber 가 아니다!</s></p>\n<h2><span id=\"시나리오-순서\">시나리오 순서</span></h2>\n<p>각 api 서버당 약속된 channel 로 redis 를 통해 subscribe 한다.<br>\n서버가 올라간 직후에는 로컬 메모리에 데이터가 없으니 redis 를 통해 publish 해준다.<br>\n로컬 메모리에 있는 설정값을 사용하고, 필요에 의해 변경될 사항이 있다면 다시 publish 해준다.<br>\n(사족) redis publish 당시에 value 값을 SET 해주고 로컬 메모리에서 접근이 실패했다면 redis 에서 key 값으로 GET 을 한다.</p>\n<p>방어코드는 짜기 나름이다. <code>사족</code> 부분에서의 동작은 넣어도 되고 안넣어도 그만이다. 서비스단에서 로컬 메모리에 key 에 대응하는 값이 없을 때에 대한 처리를 잘 해준다면 굳이 추가하지 않아도 되는 기능이다.</p>\n<h3><span id=\"환경-설정\">환경 설정</span></h3>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-tag\">gradle</span> 4<span class=\"selector-class\">.8</span><span class=\"selector-class\">.1</span></span><br><span class=\"line\"><span class=\"selector-tag\">spring</span> <span class=\"selector-tag\">boot</span> 2<span class=\"selector-class\">.0</span><span class=\"selector-class\">.3</span><span class=\"selector-class\">.RELEASE</span></span><br><span class=\"line\"><span class=\"selector-tag\">redis</span> 3<span class=\"selector-class\">.2</span><span class=\"selector-class\">.3</span></span><br><span class=\"line\"><span class=\"selector-tag\">lettuce</span> 5<span class=\"selector-class\">.0</span><span class=\"selector-class\">.4</span><span class=\"selector-class\">.RELEASE</span></span><br></pre></td></tr></table></figure>\n<p>redis java client 는 lettuce 를 사용하였다. 사내에서는 기본적으로 jedis 를 사용하는데, redis 의 버전 대응도 느린편이고 async 에 대한 지원도 아직 없는 상태이다. 이번 포스트에서는 redis 의 async 부분을 다루지는 않지만, (다른 포스트에서는 살짝 다룬 부분이 있다) 앞으로 redis client 를 사용할 때는 jedis 는 점점 더 손이 덜 갈듯 싶다.</p>\n<h3><span id=\"buildgradle\">build.gradle</span></h3>\n<figure class=\"highlight gradle\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">dependencies</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">compile</span>(<span class=\"string\">'org.springframework.boot:spring-boot-starter'</span>)</span><br><span class=\"line\">    <span class=\"keyword\">compile</span>(<span class=\"string\">'org.springframework.boot:spring-boot-starter-web'</span>)</span><br><span class=\"line\">    <span class=\"keyword\">compile</span>(<span class=\"string\">'io.lettuce:lettuce-core'</span>)</span><br><span class=\"line\">    <span class=\"keyword\">compile</span>(<span class=\"string\">'com.google.code.gson:gson:2.8.0'</span>)</span><br><span class=\"line\">    <span class=\"keyword\">compile</span>(<span class=\"string\">'org.apache.logging.log4j:log4j-core:2.9.1'</span>)</span><br><span class=\"line\">    compileOnly(<span class=\"string\">'org.projectlombok:lombok'</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">    testCompile(<span class=\"string\">'org.springframework.boot:spring-boot-starter-test'</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>redis 와 이를 전달해 줄 수 있는 json 으로 gson 을 사용하기로 했다. 여기서도 역시 jackson 과의 비교가 들어가는데 이번에 구현해야할 기능에서는 간단한 기능들만 필요하므로 gson 을 사용하는 것으로 한다.<br>\n<a href=\"http://www.baeldung.com/jackson-vs-gson\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">jackson vs gson</a> 에서 기능이나 사용에 대한 차이를 볼 수 있다.</p>\n<h2><span id=\"pubsub-을-이용해-데이터-갱신하기\">pub/sub 을 이용해 데이터 갱신하기</span></h2>\n<h3><span id=\"thread-subscriber-초기화및-등록\">thread, subscriber 초기화및 등록</span></h3>\n<p>로컬에 스레드와 subscriber 를 최초에 초기화 해주도록 한다.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> CustomSubscriber customSubscriber;</span><br><span class=\"line\"><span class=\"keyword\">private</span> Thread localThread;</span><br><span class=\"line\"><span class=\"keyword\">private</span> RedisService redisService;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> CustomSubscriber <span class=\"title\">getCustomSubscriber</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (customSubscriber == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        customSubscriber = <span class=\"keyword\">new</span> CustomSubscriber() &#123;</span><br><span class=\"line\">            <span class=\"meta\">@Override</span></span><br><span class=\"line\">            <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">message</span><span class=\"params\">(String channel, String message)</span> </span>&#123;</span><br><span class=\"line\">                update(message);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> customSubscriber;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@PostConstruct</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">init</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (localThread == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        localThread = <span class=\"keyword\">new</span> Thread(() -&gt; redisService.subscribe(CHANNEL, getCustomSubscriber()));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    localThread.start();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@PreDestroy</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">destroy</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    redisService.unSubscribe(getCustomSubscriber());</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>redis subscribe 을 하게 되면 blocking 이 걸리게 되므로 별도의 thread 를 생성해 subscribe 하도록 한다.</li>\n<li>localThread 는 최초에 하나의 subscriber 를 생성해 구독을 하고, destroy 될 때 구독을 해지한다.</li>\n<li>등록된 subscriber 에서는 받은 메세지를 <code>update</code> 메소드로 전달해준다.</li>\n</ul>\n<h3><span id=\"message-전달-및-데이터-갱신\">message 전달 및 데이터 갱신</span></h3>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">update</span><span class=\"params\">(String message)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        String[] split = message.split(<span class=\"string\">\"\\\\|\"</span>);</span><br><span class=\"line\">        String key = split[<span class=\"number\">0</span>];</span><br><span class=\"line\">        String value = split[<span class=\"number\">1</span>];</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.cacheMap.put(key, value);</span><br><span class=\"line\">        log.debug(<span class=\"string\">\"update success : \"</span> + message);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">        log.warn(<span class=\"string\">\"update fail : \"</span> + message, e);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">    </span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> Long <span class=\"title\">publish</span><span class=\"params\">(String key, String value)</span> </span>&#123;</span><br><span class=\"line\">    String message = key + <span class=\"string\">\"|\"</span> + value;</span><br><span class=\"line\">    Long publish = redisService.publish(CHANNEL, message);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> publish;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">```  </span><br><span class=\"line\"></span><br><span class=\"line\">- publish 와 subscribe 에서는 약속된 메세지 포멧을 가지도록 한다. 여기서는 간단한 key, value 형태로만 가져할 수 있도록 message 를 `|` 를 구분자로 가져가기로 했다. 즉, `message = key|value` 로 약속을 하고 파싱을 해서 사용하도록 한다.  </span><br><span class=\"line\">- subscribe 에서 받아온 message 를 `|` 구분자로 쪼개 key 와 value 를 가져와 로컬 메모리에 올리도록 한다. </span><br><span class=\"line\"></span><br><span class=\"line\">### 데이터 제공</span><br><span class=\"line\"></span><br><span class=\"line\">```java</span><br><span class=\"line\"><span class=\"keyword\">private</span> ConcurrentHashMap&lt;String, String&gt; cacheMap = <span class=\"keyword\">new</span> ConcurrentHashMap&lt;&gt;();</span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> Gson gson = <span class=\"keyword\">new</span> GsonBuilder().setFieldNamingPolicy(FieldNamingPolicy.LOWER_CASE_WITH_UNDERSCORES)</span><br><span class=\"line\">        .setDateFormat(<span class=\"string\">\"yyyy-MM-dd HH:mm:ss\"</span>)</span><br><span class=\"line\">        .disableHtmlEscaping()</span><br><span class=\"line\">        .excludeFieldsWithModifiers(Modifier.TRANSIENT)</span><br><span class=\"line\">        .create();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> &lt;T&gt; <span class=\"function\">T <span class=\"title\">get</span><span class=\"params\">(String key, Class&lt;T&gt; tClass)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        String valueString = <span class=\"keyword\">this</span>.cacheMap.get(key);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> gson.fromJson(valueString, tClass);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">        log.warn(<span class=\"string\">\"get error &gt; key \"</span> + key, e);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>get 함수를 통해 로컬 메모리에 있는 데이터를 제공해주는데, 데이터가 갱신되는 도중에 여러 스레드가 동시에 접근하면서 정합성을 맞춰주기 위해 <code>ConcurrentHashMap</code> 를 사용했다.</li>\n</ul>\n<p>참고로 <code>get</code> 메소드는 Optional 로 감싸주면 더욱 좋다. null 을 반환하는 것보다 Optional.empty() 를 반환해주는 모양이 외부에서도 사용할 때 좀 더 편하게 사용할 수 있을 것이다. 위의 <code>get</code> 메소드를 조금 고쳐보자.</p>\n<h3><span id=\"조금-더-편하게-데이터-제공\">조금 더 편하게 데이터 제공</span></h3>\n<figure class=\"highlight processing\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> &lt;T&gt; Optional&lt;T&gt; <span class=\"built_in\">get</span>(<span class=\"keyword\">String</span> <span class=\"built_in\">key</span>, Class&lt;T&gt; tClass) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">String</span> valueString = <span class=\"keyword\">this</span>.cacheMap.<span class=\"built_in\">get</span>(<span class=\"built_in\">key</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> Optional.of(gson.fromJson(valueString, tClass));</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">log</span>.warn(<span class=\"string\">\"get error &gt; key \"</span> + <span class=\"built_in\">key</span>, e);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> Optional.empty();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> &lt;T&gt; T <span class=\"built_in\">get</span>(<span class=\"keyword\">String</span> <span class=\"built_in\">key</span>, Class&lt;T&gt; tClass, T defaultValue) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">get</span>(<span class=\"built_in\">key</span>, tClass).orElse(defaultValue);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>추가적으로 메모리에 없는 key 값을 조회하고자 할 때 null 이나 Optional.empty() 를 반환하면 외부에서는 이에 대한 후속 처리를 해줘야 한다. 이 때 defaultValue 를 지정할 수 있게 해준다면 사용하는 쪽 로직이 좀 더 편해질 수 있다.</p>\n<h2><span id=\"결론\">결론</span></h2>\n<p>이제 약속된 채널로 publish 를 하면 subscribe 하고 있는 모든 서버들에서 일괄적으로 특정 설정값을 바꿔 사용할 수 있다. 지금은 단순하게 key, value 값을 동적으로 변경하는 곳에 pub/sub 을 사용하였지만, 조금만 응용하면 여러가지 부분에 사용할 수 있을 것이다. 예제 소스는 <a href=\"https://github.com/nevercaution/spring-boot-redis-pub-sub\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">여기</a> 에서 확인할 수 있다.</p>\n<h2><span id=\"추신\">추신</span></h2>\n<p>redis pub/sub 을 이용하면 기존에 사용하고 있던 부분에서 전혀 다른 페러다임으로 동적인 데이터들을 갱신할 수 있다. 현재 사내에서는 레디스 데이터 캐싱을 시간단위로 기록하고 있는데, 잘 활용하면 실시간으로 캐시 데이터에 반영을 할 수도 있을거라 기대할 수 있다. 하지만 모든 과하면 안된다. publish 하는 채널들이 많아지고 subscribe 하는 구독자들이 많아지거나, redis cluster 에서 subscription 을 과도하게 한다면 오히려 안좋은 결과를 가져올 것이다. 그러므로 충분히 검토한 후 각자 목적에 맞는 곳에 사용하는 것이 좋다고 생각된다.</p>\n","site":{"data":{}},"excerpt":"","more":"<p>배포없이 설정값을 변경해야하는 일이 생겼다. 설정값 하나 때문에 전체 api 서버를 재배포 해야하는건 부담이 있었고 실시간으로 설정값을 변경해서 바로바로 코드에 반영해야 하는 일이었다. 이를 구현하기 위해서는 여러가지 방법이 있는데 그중에서 가장 손이 덜가면서 부하가 덜 드는 방법으로 구현을 하고자 했다. 이런 저런 방법을 찾아보면서 찾게 된 방법들이다.</p>\n<ol>\n<li><a href=\"https://redis.io/commands/get\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">redis</a> 를 이용해 값을 가져오는 방식</li>\n<li><a href=\"http://projects.spring.io/spring-cloud/\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">spring cloud</a> 를 이용해 설정값을 전파 방는 방식</li>\n<li><a href=\"https://commons.apache.org/proper/commons-configuration/\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">Apache commons configuration</a> 을 이용해 외부파일에 설정값을 전파하는 방식</li>\n</ol>\n<p>1번의 경우는 구현이 가장 간단한 방식이다. key 값으로 원하는 설정값을 넣어 바로 꺼내어 사용하면 되기 때문이다. 하지만 redis 에 계속해서 조회를 하기 때문에 부하가 올라감 염려가 있다. 자주 불리는 endpoint 가 아니라면 괜찮지만 login 같이 조회수가 높은 endpoint 라면 단순한 로직 추가임에도 로드가 올라가 redis 에 부담을 줄 수가 있어 이 방법은 최후의 보루(?) 로 남겨두기로 했다.<br>\n2번의 경우는 spring cloud 를 사용해서 yml 파일들을 spring cloud config server 에 올려두고 spring cloud client 들이 해당 설정 파일을 받아가는 형식이라 지금 구현하고자 하는 바를 만족한다. 하지만 spring cloud 는 이런 기능 외에 훨씬 더 많은 기능들을 제공하고 있는데, 동적으로 설정값 하나 넣자고 배보다 배꼽이 더 큰 구현을 하기엔 부적합하다고 판단 되었다.<br>\n3번의 경우는 spring boot 외부에 설정파일을 따로 두어 파일을 읽어 값을 사용하는 방식이다. 역시 지금 구현하고자 하는 목표와 비슷하기도 하고 구현의 난이도나 범위가 크지 않았지만 파일을 주기적으로 읽어야 하는 부담 (file IO 는 부하가 크고 속도도 느린 편이다.) 이 있었고, 전체 api 서버에 변경된 설정값이 담긴 파일을 전파하려면 <a href=\"https://www.ansible.com/\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">ansible</a> 이나 별도의 구현을 통해 전체 서버에 전달을 해주어야 하는데, 이 역시 구현체보다 구현을 해야하는 범위가 넘어서버리게 되어버려 마음에 들지 않았다.<br>\n마감 시간이 급박한건 아니었지만 그렇다고 해서 큰일을 벌일 정도의 규모의 일감이 아니었기 때문에 적당한 선에서 작업하고 넘어가는 것이 좋다고 생각했다. 회사 동료들과 어떻게 할까 고민하다가 문득 redis pub/sub 을 이용해 메모리에 설정값들을 가지고 있으면 어떨까 생각을 했다. 필요할 때만 redis litenser 가 사용되고 file IO 보다 가벼우며 과도하게 redis connection 을 맺지 않아 부하도 크지 않아 괜찮을거라 판단했다.<br>\n<s>다들 아시겠지만 Reactive 의 publisher subscriber 가 아니다!</s></p>\n<h2>시나리오 순서</h2>\n<p>각 api 서버당 약속된 channel 로 redis 를 통해 subscribe 한다.<br>\n서버가 올라간 직후에는 로컬 메모리에 데이터가 없으니 redis 를 통해 publish 해준다.<br>\n로컬 메모리에 있는 설정값을 사용하고, 필요에 의해 변경될 사항이 있다면 다시 publish 해준다.<br>\n(사족) redis publish 당시에 value 값을 SET 해주고 로컬 메모리에서 접근이 실패했다면 redis 에서 key 값으로 GET 을 한다.</p>\n<p>방어코드는 짜기 나름이다. <code>사족</code> 부분에서의 동작은 넣어도 되고 안넣어도 그만이다. 서비스단에서 로컬 메모리에 key 에 대응하는 값이 없을 때에 대한 처리를 잘 해준다면 굳이 추가하지 않아도 되는 기능이다.</p>\n<h3>환경 설정</h3>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-tag\">gradle</span> 4<span class=\"selector-class\">.8</span><span class=\"selector-class\">.1</span></span><br><span class=\"line\"><span class=\"selector-tag\">spring</span> <span class=\"selector-tag\">boot</span> 2<span class=\"selector-class\">.0</span><span class=\"selector-class\">.3</span><span class=\"selector-class\">.RELEASE</span></span><br><span class=\"line\"><span class=\"selector-tag\">redis</span> 3<span class=\"selector-class\">.2</span><span class=\"selector-class\">.3</span></span><br><span class=\"line\"><span class=\"selector-tag\">lettuce</span> 5<span class=\"selector-class\">.0</span><span class=\"selector-class\">.4</span><span class=\"selector-class\">.RELEASE</span></span><br></pre></td></tr></table></figure>\n<p>redis java client 는 lettuce 를 사용하였다. 사내에서는 기본적으로 jedis 를 사용하는데, redis 의 버전 대응도 느린편이고 async 에 대한 지원도 아직 없는 상태이다. 이번 포스트에서는 redis 의 async 부분을 다루지는 않지만, (다른 포스트에서는 살짝 다룬 부분이 있다) 앞으로 redis client 를 사용할 때는 jedis 는 점점 더 손이 덜 갈듯 싶다.</p>\n<h3>build.gradle</h3>\n<figure class=\"highlight gradle\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">dependencies</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">compile</span>(<span class=\"string\">'org.springframework.boot:spring-boot-starter'</span>)</span><br><span class=\"line\">    <span class=\"keyword\">compile</span>(<span class=\"string\">'org.springframework.boot:spring-boot-starter-web'</span>)</span><br><span class=\"line\">    <span class=\"keyword\">compile</span>(<span class=\"string\">'io.lettuce:lettuce-core'</span>)</span><br><span class=\"line\">    <span class=\"keyword\">compile</span>(<span class=\"string\">'com.google.code.gson:gson:2.8.0'</span>)</span><br><span class=\"line\">    <span class=\"keyword\">compile</span>(<span class=\"string\">'org.apache.logging.log4j:log4j-core:2.9.1'</span>)</span><br><span class=\"line\">    compileOnly(<span class=\"string\">'org.projectlombok:lombok'</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">    testCompile(<span class=\"string\">'org.springframework.boot:spring-boot-starter-test'</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>redis 와 이를 전달해 줄 수 있는 json 으로 gson 을 사용하기로 했다. 여기서도 역시 jackson 과의 비교가 들어가는데 이번에 구현해야할 기능에서는 간단한 기능들만 필요하므로 gson 을 사용하는 것으로 한다.<br>\n<a href=\"http://www.baeldung.com/jackson-vs-gson\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">jackson vs gson</a> 에서 기능이나 사용에 대한 차이를 볼 수 있다.</p>\n<h2>pub/sub 을 이용해 데이터 갱신하기</h2>\n<h3>thread, subscriber 초기화및 등록</h3>\n<p>로컬에 스레드와 subscriber 를 최초에 초기화 해주도록 한다.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> CustomSubscriber customSubscriber;</span><br><span class=\"line\"><span class=\"keyword\">private</span> Thread localThread;</span><br><span class=\"line\"><span class=\"keyword\">private</span> RedisService redisService;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> CustomSubscriber <span class=\"title\">getCustomSubscriber</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (customSubscriber == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        customSubscriber = <span class=\"keyword\">new</span> CustomSubscriber() &#123;</span><br><span class=\"line\">            <span class=\"meta\">@Override</span></span><br><span class=\"line\">            <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">message</span><span class=\"params\">(String channel, String message)</span> </span>&#123;</span><br><span class=\"line\">                update(message);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> customSubscriber;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@PostConstruct</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">init</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (localThread == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        localThread = <span class=\"keyword\">new</span> Thread(() -&gt; redisService.subscribe(CHANNEL, getCustomSubscriber()));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    localThread.start();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@PreDestroy</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">destroy</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    redisService.unSubscribe(getCustomSubscriber());</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>redis subscribe 을 하게 되면 blocking 이 걸리게 되므로 별도의 thread 를 생성해 subscribe 하도록 한다.</li>\n<li>localThread 는 최초에 하나의 subscriber 를 생성해 구독을 하고, destroy 될 때 구독을 해지한다.</li>\n<li>등록된 subscriber 에서는 받은 메세지를 <code>update</code> 메소드로 전달해준다.</li>\n</ul>\n<h3>message 전달 및 데이터 갱신</h3>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">update</span><span class=\"params\">(String message)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        String[] split = message.split(<span class=\"string\">\"\\\\|\"</span>);</span><br><span class=\"line\">        String key = split[<span class=\"number\">0</span>];</span><br><span class=\"line\">        String value = split[<span class=\"number\">1</span>];</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.cacheMap.put(key, value);</span><br><span class=\"line\">        log.debug(<span class=\"string\">\"update success : \"</span> + message);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">        log.warn(<span class=\"string\">\"update fail : \"</span> + message, e);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">    </span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> Long <span class=\"title\">publish</span><span class=\"params\">(String key, String value)</span> </span>&#123;</span><br><span class=\"line\">    String message = key + <span class=\"string\">\"|\"</span> + value;</span><br><span class=\"line\">    Long publish = redisService.publish(CHANNEL, message);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> publish;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">```  </span><br><span class=\"line\"></span><br><span class=\"line\">- publish 와 subscribe 에서는 약속된 메세지 포멧을 가지도록 한다. 여기서는 간단한 key, value 형태로만 가져할 수 있도록 message 를 `|` 를 구분자로 가져가기로 했다. 즉, `message = key|value` 로 약속을 하고 파싱을 해서 사용하도록 한다.  </span><br><span class=\"line\">- subscribe 에서 받아온 message 를 `|` 구분자로 쪼개 key 와 value 를 가져와 로컬 메모리에 올리도록 한다. </span><br><span class=\"line\"></span><br><span class=\"line\">### 데이터 제공</span><br><span class=\"line\"></span><br><span class=\"line\">```java</span><br><span class=\"line\"><span class=\"keyword\">private</span> ConcurrentHashMap&lt;String, String&gt; cacheMap = <span class=\"keyword\">new</span> ConcurrentHashMap&lt;&gt;();</span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> Gson gson = <span class=\"keyword\">new</span> GsonBuilder().setFieldNamingPolicy(FieldNamingPolicy.LOWER_CASE_WITH_UNDERSCORES)</span><br><span class=\"line\">        .setDateFormat(<span class=\"string\">\"yyyy-MM-dd HH:mm:ss\"</span>)</span><br><span class=\"line\">        .disableHtmlEscaping()</span><br><span class=\"line\">        .excludeFieldsWithModifiers(Modifier.TRANSIENT)</span><br><span class=\"line\">        .create();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> &lt;T&gt; <span class=\"function\">T <span class=\"title\">get</span><span class=\"params\">(String key, Class&lt;T&gt; tClass)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        String valueString = <span class=\"keyword\">this</span>.cacheMap.get(key);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> gson.fromJson(valueString, tClass);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">        log.warn(<span class=\"string\">\"get error &gt; key \"</span> + key, e);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>get 함수를 통해 로컬 메모리에 있는 데이터를 제공해주는데, 데이터가 갱신되는 도중에 여러 스레드가 동시에 접근하면서 정합성을 맞춰주기 위해 <code>ConcurrentHashMap</code> 를 사용했다.</li>\n</ul>\n<p>참고로 <code>get</code> 메소드는 Optional 로 감싸주면 더욱 좋다. null 을 반환하는 것보다 Optional.empty() 를 반환해주는 모양이 외부에서도 사용할 때 좀 더 편하게 사용할 수 있을 것이다. 위의 <code>get</code> 메소드를 조금 고쳐보자.</p>\n<h3>조금 더 편하게 데이터 제공</h3>\n<figure class=\"highlight processing\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> &lt;T&gt; Optional&lt;T&gt; <span class=\"built_in\">get</span>(<span class=\"keyword\">String</span> <span class=\"built_in\">key</span>, Class&lt;T&gt; tClass) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">String</span> valueString = <span class=\"keyword\">this</span>.cacheMap.<span class=\"built_in\">get</span>(<span class=\"built_in\">key</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> Optional.of(gson.fromJson(valueString, tClass));</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">log</span>.warn(<span class=\"string\">\"get error &gt; key \"</span> + <span class=\"built_in\">key</span>, e);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> Optional.empty();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> &lt;T&gt; T <span class=\"built_in\">get</span>(<span class=\"keyword\">String</span> <span class=\"built_in\">key</span>, Class&lt;T&gt; tClass, T defaultValue) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">get</span>(<span class=\"built_in\">key</span>, tClass).orElse(defaultValue);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>추가적으로 메모리에 없는 key 값을 조회하고자 할 때 null 이나 Optional.empty() 를 반환하면 외부에서는 이에 대한 후속 처리를 해줘야 한다. 이 때 defaultValue 를 지정할 수 있게 해준다면 사용하는 쪽 로직이 좀 더 편해질 수 있다.</p>\n<h2>결론</h2>\n<p>이제 약속된 채널로 publish 를 하면 subscribe 하고 있는 모든 서버들에서 일괄적으로 특정 설정값을 바꿔 사용할 수 있다. 지금은 단순하게 key, value 값을 동적으로 변경하는 곳에 pub/sub 을 사용하였지만, 조금만 응용하면 여러가지 부분에 사용할 수 있을 것이다. 예제 소스는 <a href=\"https://github.com/nevercaution/spring-boot-redis-pub-sub\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">여기</a> 에서 확인할 수 있다.</p>\n<h2>추신</h2>\n<p>redis pub/sub 을 이용하면 기존에 사용하고 있던 부분에서 전혀 다른 페러다임으로 동적인 데이터들을 갱신할 수 있다. 현재 사내에서는 레디스 데이터 캐싱을 시간단위로 기록하고 있는데, 잘 활용하면 실시간으로 캐시 데이터에 반영을 할 수도 있을거라 기대할 수 있다. 하지만 모든 과하면 안된다. publish 하는 채널들이 많아지고 subscribe 하는 구독자들이 많아지거나, redis cluster 에서 subscription 을 과도하게 한다면 오히려 안좋은 결과를 가져올 것이다. 그러므로 충분히 검토한 후 각자 목적에 맞는 곳에 사용하는 것이 좋다고 생각된다.</p>\n"},{"title":"Python에서 iOS, Android 스토어 인앱 결제 검증하기","catalog":true,"date":"2016-03-11T07:43:24.000Z","subtitle":null,"header-img":"/img/header_img/bg.png","_content":"Django framework를 이용해서 프로젝트를 만들면서 했던 여러가지 삽질들과 넘어야했던 많은 산들과 몰랐던 부분들에 대해서 내 나름 공부 겸 기록을 위해 남겨둬야 겠다는 생각이 들었다. 프로젝트로 한창 바빴던 시기에는 당장 앞에 놓여진 일들에 치여 이런 생각을 못하고 있다가 지금은 조금 여유가 되어 그 때 있었던 일들에 대한 나름의 경험을 기록해보고자 한다.\n\n그 중에 한가지가 인앱 아이템 결제하기 였다. 나는 예전에 cocos2d-x로 게임을 개발했던 시절엔 결제 프로세스를 클라이언트(단말기)사이드만 알고 있었고 서버사이드의 로직은 전혀 모르고 있었는데, 오히려 이번에 서버 로직을 구현하면서 그 때 그 시절의 경험이 많은 도움이 되었다. 앱 내에 아이템을 구매하고 구매한 아이템을 유저에게 잘 넣어주는 로직이야 구현방식도 다양하고 여러 기교들이 들어가 있는데 오늘은 그 중에서 나름 간단한(?) 파트인 두 플랫폼의 결제 영수증 검증 로직의 삽질 경험을 적어보고자 한다.\n\n이번에 대응했던 클라이언트는 google play store와 iOS app store 두개의 플랫폼이다. 차례차례 훑어보자.\n각 플랫폼별 스토어의 앱 등록과 각종 키발급 같은 내용은 다루지 않고 순수하게 영수증 검증만을 볼 것이다.\n\n1. google In-app billing\n구글 결제 영수증 검증의 경우 생각보다 단순해서 처음에는 이게 맞나? 싶었다. 일반적으로 생각하기에는 구글의 결제서버에 영수증 정보를 넘겨 유효한 영수증인지 여부를 판단해서 진행이 되는줄 알았는데(이렇게 하는 방법도 있다고 한다.), 훨씬 간단한 방법이 있었다. 암호화된 영수증 정보를 클라이언트로 부터 받아와서 local에서 검증하는 방식이다.\n\n일단 pip를 이용해서 Crypto 라이브러리를 설치하도록 하자.\n\n```\npip install pycrypto\n```\n \n\n다음은 영수증 검증 코드이다. signed_data 는 안드로이드 결제완료시 넘어온 암호화된 영수증 문자열이고 signature는 클라이언트와 약속된 특정 문자열이다. 안드로이드에서 결제를 요청할 당시 이 값을 함께 넘겨주면 signed_data 내부에 이 signature 값이 심어들어가게 되고, 복호화를 하면 이 값이 풀어져 나와 영수증 검증을 할 수 있다.\n\n```\nfrom base64 import b64decode\nfrom Crypto.Hash import SHA\nfrom Crypto.PublicKey import RSA\nfrom Crypto.Signature import PKCS1_v1_5\n\n# Your base64 encoded public key from Google Play.\nPUBLIC_KEY_BASE64 = 'YOUR_PUBLIC_KEY_BASE64'\n\ndef verify_for_google(signed_data, signature):\n    \"\"\"Returns whether the given data was signed with the private key.\"\"\"\n    key = RSA.importKey(_pem_format(PUBLIC_KEY_BASE64))\n    verifier = PKCS1_v1_5.new(key)\n    data = SHA.new(signed_data.encode('utf8'))\n    sig = b64decode(signature)\n\n    return verifier.verify(data, sig)\n\n\ndef _pem_format(key):\n    return '\\n'.join([\n        '-----BEGIN PUBLIC KEY-----',\n        '\\n'.join(_chunks(key, 64)),\n        '-----END PUBLIC KEY-----'\n    ])\n\n\ndef _chunks(s, n):\n    for start in range(0, len(s), n):\n        yield s[start:start+n]\n```\n\n\n먼저 스토어에서 발급받은 공개키가 필요하다. 이 키를 이용해 넘어온 데이터가 유효한지 여부를 판단할 수 있다.\n1. RSA 암호 방식으로 암호화가 되어 있기 때문에 PUBLIC KEY 를 이용해 key객체를 생성한다.\n2. PKCS(Public Key Cryptography Standard)를 이용해서 암호화된 영수증을 검증 할것이다. 1번에서 만들어진 key를 이용해 verifier 객체를 생성하자.\n3. SHA(Secure Hash Algorithm)으로 된 signed_data를 객체로 생성한다.\n4. signature 를 decode 한다.\n5. 2번에서 생성한 verifier를 통해 data 와 sig 의 유효성을 판단한다. 유효한 영수증은 True 그렇지 않으면 False 를 반환한다.\n이 부분에 대해서는 좀 더 공부가 필요해 보인다.. 현재는 암호화에 대한 꼭지들이 의미하는 바를 인지해야겠지만 이들이 어떤 작업을 하는지에 대한 공부도 반드시 필요할 것이다.\n코드 내용이 그리 간단하지는 않지만 비교적 빠르게 구글 영수증 검증을 할 수 있었다. 구글의 개발자 사이트를 들어가 이런 저런 글도 읽오보고 여러 포스팅을 찾아보면서 여러가지 자료를 봐왔었는데 stackoverflow 에서 찾은 글들을 추려 간단하게 메소드로 정리했다. 내가 여기서 삽질 했던 부분은 대체 signed_data 와 signature 가 무엇을 뜻하는지 알 수가 없었다는 점이였다. 대부분의 자료들에서는 저 둘이 무엇을 의미하는지 자세히 기술을 해놓지 않거나 아예 어떤 값을 의미하는지를 써놓지 않은 글들이 많았다. 나도 처음에는 이리저리 고민을 해보다가 일단 맨땅에 헤딩을 하고보자는 마음으로 여러 땅에 삽집을 하다가 찾은 결과물이다.\n\n\n2. iOS in-app purchase\n이번에는 iOS결제 영수증 검증을 해보도록 하자. apple은 구글과는 다르게 결제 서버에 영수증을 보내서 넘어온 값을 통해 영수증의 유효성을 판단한다. 직접 apple의 결제 api를 호출해서 검증을 해도 되지만 역시나 Python은 있을만하다고 생각하는 라이브러리는 이미 존재하거나 누군가가 만들어 놨다. 우리는 이 라이브러리를 만든분 께 감사를 드리며 코드를 받아가도록 하자.\n\n```\npip install itunes-iap\n```\n\nitunes-iap를 설치하면 의존성 라이브러리들이 이것저것 왕창 설치된다. 궁금하면 ($pip list 를 통해 확인해볼것)\n이번에는 iOS 영수증 검증 코드를 보도록 하자. 이 때 transaction_id 는 결제 당시 결과값으로 오는 구매 영수증 id이고, raw_data는 암호화된 영수증 문자열이다. \n\n```\nimport itunesiap\n\ndef _verify_for_ios(transaction_id: str, raw_data: str):\n    \"\"\"\n    seeAlso : https://developer.apple.com/library/ios/releasenotes/General/ValidateAppStoreReceipt/Chapters/ValidateRemotely.html\n    :param transaction_id: 결제 transaction_id\n    :param raw_data: base64-encoded data\n    :return: boolean\n    :raises: Otherwise raise a request exception (RuntimeError, itunesiap.exc.InvalidReceipt)\n    \"\"\"\n    try:\n        # for sandbox environment.\n        #     with itunesiap.env.sandbox:\n        #         response = itunesiap.verify(raw_data)\n\n        # for production environment. (default)\n        response = itunesiap.verify(raw_data)  # base64-encoded data\n\n        def _get_key(re):\n            \"\"\" 영수증리스트에서 비교 키를 반환합니다. \"\"\"\n            return re.purchase_date_ms\n\n        # 넘어온 in_app 영수증 리스트에서 구매 시각이 가장 마지막인 영수증을 가져와서 transaction_id를 비교한다.\n        # 오름 차순으로 정렬해서 구매시각이 가장 마지막 영수증을 가져옵니다.\n        receipts = sorted(response.receipt.in_app, key=_get_key)\n        last_receipt = receipts[len(receipts) - 1]\n        if last_receipt.transaction_id != transaction_id:\n            #  구매시각이 가장 마지막인 영수증의 transaction_id 가 일치 하지 않는다.\n            return False\n\n        return response.status == 0\n```\n\niOS 영수증 유효성 검증은 간단하다. itunesiap.verify 메소드를 통해 iOS에서 넘어온 데이터를 넣고 호출하면 복호화된 영수증 데이터가 나온다. 이 때 status 값이 0 이라면 유효한 영수증이라고 판단한다. 뭔가 apple다운 api라고 생각한다. 처음 iOS영수증 검증을 할 당시엔 verify 메소드만 호출하고 그 뒤에 넘어온 데이터의 status 값만 확인하고 유효성을 검증했다. \n여기서 나의 삽질이 시작되었다. \n\n1. 일단 주석에서 보는것과 같이 sandbox환경과 real환경일 때에 호출하는 api가 다르다. itunesiap의 환경을 설정을 해주는 방법은 여러가지가 있다. 각자 개발환경에서 영수증 유효성을 검사할 때엔 sandbox와 real환경을 잘 구분해서 api를 호출해주도록 하자. 아무리 유효한 영수증이라 할지라도 틀린 환경의 api를 호출하면 유효하지 않다고 판단하기 때문이다. \n\n2. 보통 verify 메소드를 호출하면 receipt 값 안에 하나의 영수증 정보만 가져온다. 하지만 특정 상황의 경우 receipt 데이터 안에 1개 이상의 영수증 정보가 딸려 오는 경우가 있다. 이 때에 한가지 데이터만이 유효한 영수증 값이다. 이 중에서 한가지 영수증만을 가지고 검증을 해야 하는데 여러 삽질 후에 깨달은 바는 receipt 안의 데이터들의 purchase_date_ms 값을 이용해 가장 마지막에 결제된 영수증 정보가 파라메터로 넘어온 transaction_id 와 동일하다는 점을 알게 되었다. 그래서 _get_key 메소드를 통해 receipt 리스트를 정렬하고, 그 중에 가장 마지막 영수증 정보를 뽑아 transaction_id 가 같은지 여부를 판단한다. \n\n자 이제 우리는 python을 이용해서 android, iOS의 영수증을 검증할 수 있게 되었다. 간단하지도 복잡하지도 않고, 몰랐을 때는 어려워 난해했지만 알고나니 더 난해한 비교적 간단하게 할 수 있는 파트였다. 이제 어디가서 이 두 플랫폼의 결제 영수증쯤은 아무렇지도 않게 검증 할 수 있다고 당당히 얘기하자.\n\n\n","source":"_posts/store-inapp-in-python.md","raw":"---\ntitle: \"Python에서 iOS, Android 스토어 인앱 결제 검증하기\"\ncatalog: true\ndate: 2016-03-11 16:43:24\nsubtitle:\nheader-img: \"/img/header_img/bg.png\"\ntags:\n- python\n- ios\n- android\n- inapp\n---\nDjango framework를 이용해서 프로젝트를 만들면서 했던 여러가지 삽질들과 넘어야했던 많은 산들과 몰랐던 부분들에 대해서 내 나름 공부 겸 기록을 위해 남겨둬야 겠다는 생각이 들었다. 프로젝트로 한창 바빴던 시기에는 당장 앞에 놓여진 일들에 치여 이런 생각을 못하고 있다가 지금은 조금 여유가 되어 그 때 있었던 일들에 대한 나름의 경험을 기록해보고자 한다.\n\n그 중에 한가지가 인앱 아이템 결제하기 였다. 나는 예전에 cocos2d-x로 게임을 개발했던 시절엔 결제 프로세스를 클라이언트(단말기)사이드만 알고 있었고 서버사이드의 로직은 전혀 모르고 있었는데, 오히려 이번에 서버 로직을 구현하면서 그 때 그 시절의 경험이 많은 도움이 되었다. 앱 내에 아이템을 구매하고 구매한 아이템을 유저에게 잘 넣어주는 로직이야 구현방식도 다양하고 여러 기교들이 들어가 있는데 오늘은 그 중에서 나름 간단한(?) 파트인 두 플랫폼의 결제 영수증 검증 로직의 삽질 경험을 적어보고자 한다.\n\n이번에 대응했던 클라이언트는 google play store와 iOS app store 두개의 플랫폼이다. 차례차례 훑어보자.\n각 플랫폼별 스토어의 앱 등록과 각종 키발급 같은 내용은 다루지 않고 순수하게 영수증 검증만을 볼 것이다.\n\n1. google In-app billing\n구글 결제 영수증 검증의 경우 생각보다 단순해서 처음에는 이게 맞나? 싶었다. 일반적으로 생각하기에는 구글의 결제서버에 영수증 정보를 넘겨 유효한 영수증인지 여부를 판단해서 진행이 되는줄 알았는데(이렇게 하는 방법도 있다고 한다.), 훨씬 간단한 방법이 있었다. 암호화된 영수증 정보를 클라이언트로 부터 받아와서 local에서 검증하는 방식이다.\n\n일단 pip를 이용해서 Crypto 라이브러리를 설치하도록 하자.\n\n```\npip install pycrypto\n```\n \n\n다음은 영수증 검증 코드이다. signed_data 는 안드로이드 결제완료시 넘어온 암호화된 영수증 문자열이고 signature는 클라이언트와 약속된 특정 문자열이다. 안드로이드에서 결제를 요청할 당시 이 값을 함께 넘겨주면 signed_data 내부에 이 signature 값이 심어들어가게 되고, 복호화를 하면 이 값이 풀어져 나와 영수증 검증을 할 수 있다.\n\n```\nfrom base64 import b64decode\nfrom Crypto.Hash import SHA\nfrom Crypto.PublicKey import RSA\nfrom Crypto.Signature import PKCS1_v1_5\n\n# Your base64 encoded public key from Google Play.\nPUBLIC_KEY_BASE64 = 'YOUR_PUBLIC_KEY_BASE64'\n\ndef verify_for_google(signed_data, signature):\n    \"\"\"Returns whether the given data was signed with the private key.\"\"\"\n    key = RSA.importKey(_pem_format(PUBLIC_KEY_BASE64))\n    verifier = PKCS1_v1_5.new(key)\n    data = SHA.new(signed_data.encode('utf8'))\n    sig = b64decode(signature)\n\n    return verifier.verify(data, sig)\n\n\ndef _pem_format(key):\n    return '\\n'.join([\n        '-----BEGIN PUBLIC KEY-----',\n        '\\n'.join(_chunks(key, 64)),\n        '-----END PUBLIC KEY-----'\n    ])\n\n\ndef _chunks(s, n):\n    for start in range(0, len(s), n):\n        yield s[start:start+n]\n```\n\n\n먼저 스토어에서 발급받은 공개키가 필요하다. 이 키를 이용해 넘어온 데이터가 유효한지 여부를 판단할 수 있다.\n1. RSA 암호 방식으로 암호화가 되어 있기 때문에 PUBLIC KEY 를 이용해 key객체를 생성한다.\n2. PKCS(Public Key Cryptography Standard)를 이용해서 암호화된 영수증을 검증 할것이다. 1번에서 만들어진 key를 이용해 verifier 객체를 생성하자.\n3. SHA(Secure Hash Algorithm)으로 된 signed_data를 객체로 생성한다.\n4. signature 를 decode 한다.\n5. 2번에서 생성한 verifier를 통해 data 와 sig 의 유효성을 판단한다. 유효한 영수증은 True 그렇지 않으면 False 를 반환한다.\n이 부분에 대해서는 좀 더 공부가 필요해 보인다.. 현재는 암호화에 대한 꼭지들이 의미하는 바를 인지해야겠지만 이들이 어떤 작업을 하는지에 대한 공부도 반드시 필요할 것이다.\n코드 내용이 그리 간단하지는 않지만 비교적 빠르게 구글 영수증 검증을 할 수 있었다. 구글의 개발자 사이트를 들어가 이런 저런 글도 읽오보고 여러 포스팅을 찾아보면서 여러가지 자료를 봐왔었는데 stackoverflow 에서 찾은 글들을 추려 간단하게 메소드로 정리했다. 내가 여기서 삽질 했던 부분은 대체 signed_data 와 signature 가 무엇을 뜻하는지 알 수가 없었다는 점이였다. 대부분의 자료들에서는 저 둘이 무엇을 의미하는지 자세히 기술을 해놓지 않거나 아예 어떤 값을 의미하는지를 써놓지 않은 글들이 많았다. 나도 처음에는 이리저리 고민을 해보다가 일단 맨땅에 헤딩을 하고보자는 마음으로 여러 땅에 삽집을 하다가 찾은 결과물이다.\n\n\n2. iOS in-app purchase\n이번에는 iOS결제 영수증 검증을 해보도록 하자. apple은 구글과는 다르게 결제 서버에 영수증을 보내서 넘어온 값을 통해 영수증의 유효성을 판단한다. 직접 apple의 결제 api를 호출해서 검증을 해도 되지만 역시나 Python은 있을만하다고 생각하는 라이브러리는 이미 존재하거나 누군가가 만들어 놨다. 우리는 이 라이브러리를 만든분 께 감사를 드리며 코드를 받아가도록 하자.\n\n```\npip install itunes-iap\n```\n\nitunes-iap를 설치하면 의존성 라이브러리들이 이것저것 왕창 설치된다. 궁금하면 ($pip list 를 통해 확인해볼것)\n이번에는 iOS 영수증 검증 코드를 보도록 하자. 이 때 transaction_id 는 결제 당시 결과값으로 오는 구매 영수증 id이고, raw_data는 암호화된 영수증 문자열이다. \n\n```\nimport itunesiap\n\ndef _verify_for_ios(transaction_id: str, raw_data: str):\n    \"\"\"\n    seeAlso : https://developer.apple.com/library/ios/releasenotes/General/ValidateAppStoreReceipt/Chapters/ValidateRemotely.html\n    :param transaction_id: 결제 transaction_id\n    :param raw_data: base64-encoded data\n    :return: boolean\n    :raises: Otherwise raise a request exception (RuntimeError, itunesiap.exc.InvalidReceipt)\n    \"\"\"\n    try:\n        # for sandbox environment.\n        #     with itunesiap.env.sandbox:\n        #         response = itunesiap.verify(raw_data)\n\n        # for production environment. (default)\n        response = itunesiap.verify(raw_data)  # base64-encoded data\n\n        def _get_key(re):\n            \"\"\" 영수증리스트에서 비교 키를 반환합니다. \"\"\"\n            return re.purchase_date_ms\n\n        # 넘어온 in_app 영수증 리스트에서 구매 시각이 가장 마지막인 영수증을 가져와서 transaction_id를 비교한다.\n        # 오름 차순으로 정렬해서 구매시각이 가장 마지막 영수증을 가져옵니다.\n        receipts = sorted(response.receipt.in_app, key=_get_key)\n        last_receipt = receipts[len(receipts) - 1]\n        if last_receipt.transaction_id != transaction_id:\n            #  구매시각이 가장 마지막인 영수증의 transaction_id 가 일치 하지 않는다.\n            return False\n\n        return response.status == 0\n```\n\niOS 영수증 유효성 검증은 간단하다. itunesiap.verify 메소드를 통해 iOS에서 넘어온 데이터를 넣고 호출하면 복호화된 영수증 데이터가 나온다. 이 때 status 값이 0 이라면 유효한 영수증이라고 판단한다. 뭔가 apple다운 api라고 생각한다. 처음 iOS영수증 검증을 할 당시엔 verify 메소드만 호출하고 그 뒤에 넘어온 데이터의 status 값만 확인하고 유효성을 검증했다. \n여기서 나의 삽질이 시작되었다. \n\n1. 일단 주석에서 보는것과 같이 sandbox환경과 real환경일 때에 호출하는 api가 다르다. itunesiap의 환경을 설정을 해주는 방법은 여러가지가 있다. 각자 개발환경에서 영수증 유효성을 검사할 때엔 sandbox와 real환경을 잘 구분해서 api를 호출해주도록 하자. 아무리 유효한 영수증이라 할지라도 틀린 환경의 api를 호출하면 유효하지 않다고 판단하기 때문이다. \n\n2. 보통 verify 메소드를 호출하면 receipt 값 안에 하나의 영수증 정보만 가져온다. 하지만 특정 상황의 경우 receipt 데이터 안에 1개 이상의 영수증 정보가 딸려 오는 경우가 있다. 이 때에 한가지 데이터만이 유효한 영수증 값이다. 이 중에서 한가지 영수증만을 가지고 검증을 해야 하는데 여러 삽질 후에 깨달은 바는 receipt 안의 데이터들의 purchase_date_ms 값을 이용해 가장 마지막에 결제된 영수증 정보가 파라메터로 넘어온 transaction_id 와 동일하다는 점을 알게 되었다. 그래서 _get_key 메소드를 통해 receipt 리스트를 정렬하고, 그 중에 가장 마지막 영수증 정보를 뽑아 transaction_id 가 같은지 여부를 판단한다. \n\n자 이제 우리는 python을 이용해서 android, iOS의 영수증을 검증할 수 있게 되었다. 간단하지도 복잡하지도 않고, 몰랐을 때는 어려워 난해했지만 알고나니 더 난해한 비교적 간단하게 할 수 있는 파트였다. 이제 어디가서 이 두 플랫폼의 결제 영수증쯤은 아무렇지도 않게 검증 할 수 있다고 당당히 얘기하자.\n\n\n","slug":"store-inapp-in-python","published":1,"updated":"2018-04-15T08:09:17.935Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjq98soqb000l8ghhmyi5g4z2","content":"<p>Django framework를 이용해서 프로젝트를 만들면서 했던 여러가지 삽질들과 넘어야했던 많은 산들과 몰랐던 부분들에 대해서 내 나름 공부 겸 기록을 위해 남겨둬야 겠다는 생각이 들었다. 프로젝트로 한창 바빴던 시기에는 당장 앞에 놓여진 일들에 치여 이런 생각을 못하고 있다가 지금은 조금 여유가 되어 그 때 있었던 일들에 대한 나름의 경험을 기록해보고자 한다.</p>\n<p>그 중에 한가지가 인앱 아이템 결제하기 였다. 나는 예전에 cocos2d-x로 게임을 개발했던 시절엔 결제 프로세스를 클라이언트(단말기)사이드만 알고 있었고 서버사이드의 로직은 전혀 모르고 있었는데, 오히려 이번에 서버 로직을 구현하면서 그 때 그 시절의 경험이 많은 도움이 되었다. 앱 내에 아이템을 구매하고 구매한 아이템을 유저에게 잘 넣어주는 로직이야 구현방식도 다양하고 여러 기교들이 들어가 있는데 오늘은 그 중에서 나름 간단한(?) 파트인 두 플랫폼의 결제 영수증 검증 로직의 삽질 경험을 적어보고자 한다.</p>\n<p>이번에 대응했던 클라이언트는 google play store와 iOS app store 두개의 플랫폼이다. 차례차례 훑어보자.<br>\n각 플랫폼별 스토어의 앱 등록과 각종 키발급 같은 내용은 다루지 않고 순수하게 영수증 검증만을 볼 것이다.</p>\n<ol>\n<li>google In-app billing<br>\n구글 결제 영수증 검증의 경우 생각보다 단순해서 처음에는 이게 맞나? 싶었다. 일반적으로 생각하기에는 구글의 결제서버에 영수증 정보를 넘겨 유효한 영수증인지 여부를 판단해서 진행이 되는줄 알았는데(이렇게 하는 방법도 있다고 한다.), 훨씬 간단한 방법이 있었다. 암호화된 영수증 정보를 클라이언트로 부터 받아와서 local에서 검증하는 방식이다.</li>\n</ol>\n<p>일단 pip를 이용해서 Crypto 라이브러리를 설치하도록 하자.</p>\n<figure class=\"highlight cmake\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">pip <span class=\"keyword\">install</span> pycrypto</span><br></pre></td></tr></table></figure>\n<p>다음은 영수증 검증 코드이다. signed_data 는 안드로이드 결제완료시 넘어온 암호화된 영수증 문자열이고 signature는 클라이언트와 약속된 특정 문자열이다. 안드로이드에서 결제를 요청할 당시 이 값을 함께 넘겨주면 signed_data 내부에 이 signature 값이 심어들어가게 되고, 복호화를 하면 이 값이 풀어져 나와 영수증 검증을 할 수 있다.</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> base64 <span class=\"keyword\">import</span> b64decode</span><br><span class=\"line\"><span class=\"keyword\">from</span> Crypto.Hash <span class=\"keyword\">import</span> SHA</span><br><span class=\"line\"><span class=\"keyword\">from</span> Crypto.PublicKey <span class=\"keyword\">import</span> RSA</span><br><span class=\"line\"><span class=\"keyword\">from</span> Crypto.Signature <span class=\"keyword\">import</span> PKCS1_v1_5</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># Your base64 encoded public key from Google Play.</span></span><br><span class=\"line\">PUBLIC_KEY_BASE64 = <span class=\"string\">'YOUR_PUBLIC_KEY_BASE64'</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">verify_for_google</span><span class=\"params\">(signed_data, signature)</span>:</span></span><br><span class=\"line\">    <span class=\"string\">\"\"\"Returns whether the given data was signed with the private key.\"\"\"</span></span><br><span class=\"line\">    key = RSA.importKey(_pem_format(PUBLIC_KEY_BASE64))</span><br><span class=\"line\">    verifier = PKCS1_v1_5.new(key)</span><br><span class=\"line\">    data = SHA.new(signed_data.encode(<span class=\"string\">'utf8'</span>))</span><br><span class=\"line\">    sig = b64decode(signature)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> verifier.verify(data, sig)</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">_pem_format</span><span class=\"params\">(key)</span>:</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">'\\n'</span>.join([</span><br><span class=\"line\">        <span class=\"string\">'-----BEGIN PUBLIC KEY-----'</span>,</span><br><span class=\"line\">        <span class=\"string\">'\\n'</span>.join(_chunks(key, <span class=\"number\">64</span>)),</span><br><span class=\"line\">        <span class=\"string\">'-----END PUBLIC KEY-----'</span></span><br><span class=\"line\">    ])</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">_chunks</span><span class=\"params\">(s, n)</span>:</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> start <span class=\"keyword\">in</span> range(<span class=\"number\">0</span>, len(s), n):</span><br><span class=\"line\">        <span class=\"keyword\">yield</span> s[start:start+n]</span><br></pre></td></tr></table></figure>\n<p>먼저 스토어에서 발급받은 공개키가 필요하다. 이 키를 이용해 넘어온 데이터가 유효한지 여부를 판단할 수 있다.</p>\n<ol>\n<li>RSA 암호 방식으로 암호화가 되어 있기 때문에 PUBLIC KEY 를 이용해 key객체를 생성한다.</li>\n<li>PKCS(Public Key Cryptography Standard)를 이용해서 암호화된 영수증을 검증 할것이다. 1번에서 만들어진 key를 이용해 verifier 객체를 생성하자.</li>\n<li>SHA(Secure Hash Algorithm)으로 된 signed_data를 객체로 생성한다.</li>\n<li>signature 를 decode 한다.</li>\n<li>2번에서 생성한 verifier를 통해 data 와 sig 의 유효성을 판단한다. 유효한 영수증은 True 그렇지 않으면 False 를 반환한다.<br>\n이 부분에 대해서는 좀 더 공부가 필요해 보인다… 현재는 암호화에 대한 꼭지들이 의미하는 바를 인지해야겠지만 이들이 어떤 작업을 하는지에 대한 공부도 반드시 필요할 것이다.<br>\n코드 내용이 그리 간단하지는 않지만 비교적 빠르게 구글 영수증 검증을 할 수 있었다. 구글의 개발자 사이트를 들어가 이런 저런 글도 읽오보고 여러 포스팅을 찾아보면서 여러가지 자료를 봐왔었는데 stackoverflow 에서 찾은 글들을 추려 간단하게 메소드로 정리했다. 내가 여기서 삽질 했던 부분은 대체 signed_data 와 signature 가 무엇을 뜻하는지 알 수가 없었다는 점이였다. 대부분의 자료들에서는 저 둘이 무엇을 의미하는지 자세히 기술을 해놓지 않거나 아예 어떤 값을 의미하는지를 써놓지 않은 글들이 많았다. 나도 처음에는 이리저리 고민을 해보다가 일단 맨땅에 헤딩을 하고보자는 마음으로 여러 땅에 삽집을 하다가 찾은 결과물이다.</li>\n</ol>\n<ol start=\"2\">\n<li>iOS in-app purchase<br>\n이번에는 iOS결제 영수증 검증을 해보도록 하자. apple은 구글과는 다르게 결제 서버에 영수증을 보내서 넘어온 값을 통해 영수증의 유효성을 판단한다. 직접 apple의 결제 api를 호출해서 검증을 해도 되지만 역시나 Python은 있을만하다고 생각하는 라이브러리는 이미 존재하거나 누군가가 만들어 놨다. 우리는 이 라이브러리를 만든분 께 감사를 드리며 코드를 받아가도록 하자.</li>\n</ol>\n<figure class=\"highlight cmake\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">pip <span class=\"keyword\">install</span> itunes-iap</span><br></pre></td></tr></table></figure>\n<p>itunes-iap를 설치하면 의존성 라이브러리들이 이것저것 왕창 설치된다. 궁금하면 ($pip list 를 통해 확인해볼것)<br>\n이번에는 iOS 영수증 검증 코드를 보도록 하자. 이 때 transaction_id 는 결제 당시 결과값으로 오는 구매 영수증 id이고, raw_data는 암호화된 영수증 문자열이다.</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> itunesiap</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">_verify_for_ios</span><span class=\"params\">(transaction_id: str, raw_data: str)</span>:</span></span><br><span class=\"line\">    <span class=\"string\">\"\"\"</span></span><br><span class=\"line\"><span class=\"string\">    seeAlso : https://developer.apple.com/library/ios/releasenotes/General/ValidateAppStoreReceipt/Chapters/ValidateRemotely.html</span></span><br><span class=\"line\"><span class=\"string\">    :param transaction_id: 결제 transaction_id</span></span><br><span class=\"line\"><span class=\"string\">    :param raw_data: base64-encoded data</span></span><br><span class=\"line\"><span class=\"string\">    :return: boolean</span></span><br><span class=\"line\"><span class=\"string\">    :raises: Otherwise raise a request exception (RuntimeError, itunesiap.exc.InvalidReceipt)</span></span><br><span class=\"line\"><span class=\"string\">    \"\"\"</span></span><br><span class=\"line\">    <span class=\"keyword\">try</span>:</span><br><span class=\"line\">        <span class=\"comment\"># for sandbox environment.</span></span><br><span class=\"line\">        <span class=\"comment\">#     with itunesiap.env.sandbox:</span></span><br><span class=\"line\">        <span class=\"comment\">#         response = itunesiap.verify(raw_data)</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\"># for production environment. (default)</span></span><br><span class=\"line\">        response = itunesiap.verify(raw_data)  <span class=\"comment\"># base64-encoded data</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">_get_key</span><span class=\"params\">(re)</span>:</span></span><br><span class=\"line\">            <span class=\"string\">\"\"\" 영수증리스트에서 비교 키를 반환합니다. \"\"\"</span></span><br><span class=\"line\">            <span class=\"keyword\">return</span> re.purchase_date_ms</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\"># 넘어온 in_app 영수증 리스트에서 구매 시각이 가장 마지막인 영수증을 가져와서 transaction_id를 비교한다.</span></span><br><span class=\"line\">        <span class=\"comment\"># 오름 차순으로 정렬해서 구매시각이 가장 마지막 영수증을 가져옵니다.</span></span><br><span class=\"line\">        receipts = sorted(response.receipt.in_app, key=_get_key)</span><br><span class=\"line\">        last_receipt = receipts[len(receipts) - <span class=\"number\">1</span>]</span><br><span class=\"line\">        <span class=\"keyword\">if</span> last_receipt.transaction_id != transaction_id:</span><br><span class=\"line\">            <span class=\"comment\">#  구매시각이 가장 마지막인 영수증의 transaction_id 가 일치 하지 않는다.</span></span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">False</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> response.status == <span class=\"number\">0</span></span><br></pre></td></tr></table></figure>\n<p>iOS 영수증 유효성 검증은 간단하다. itunesiap.verify 메소드를 통해 iOS에서 넘어온 데이터를 넣고 호출하면 복호화된 영수증 데이터가 나온다. 이 때 status 값이 0 이라면 유효한 영수증이라고 판단한다. 뭔가 apple다운 api라고 생각한다. 처음 iOS영수증 검증을 할 당시엔 verify 메소드만 호출하고 그 뒤에 넘어온 데이터의 status 값만 확인하고 유효성을 검증했다.<br>\n여기서 나의 삽질이 시작되었다.</p>\n<ol>\n<li>\n<p>일단 주석에서 보는것과 같이 sandbox환경과 real환경일 때에 호출하는 api가 다르다. itunesiap의 환경을 설정을 해주는 방법은 여러가지가 있다. 각자 개발환경에서 영수증 유효성을 검사할 때엔 sandbox와 real환경을 잘 구분해서 api를 호출해주도록 하자. 아무리 유효한 영수증이라 할지라도 틀린 환경의 api를 호출하면 유효하지 않다고 판단하기 때문이다.</p>\n</li>\n<li>\n<p>보통 verify 메소드를 호출하면 receipt 값 안에 하나의 영수증 정보만 가져온다. 하지만 특정 상황의 경우 receipt 데이터 안에 1개 이상의 영수증 정보가 딸려 오는 경우가 있다. 이 때에 한가지 데이터만이 유효한 영수증 값이다. 이 중에서 한가지 영수증만을 가지고 검증을 해야 하는데 여러 삽질 후에 깨달은 바는 receipt 안의 데이터들의 purchase_date_ms 값을 이용해 가장 마지막에 결제된 영수증 정보가 파라메터로 넘어온 transaction_id 와 동일하다는 점을 알게 되었다. 그래서 _get_key 메소드를 통해 receipt 리스트를 정렬하고, 그 중에 가장 마지막 영수증 정보를 뽑아 transaction_id 가 같은지 여부를 판단한다.</p>\n</li>\n</ol>\n<p>자 이제 우리는 python을 이용해서 android, iOS의 영수증을 검증할 수 있게 되었다. 간단하지도 복잡하지도 않고, 몰랐을 때는 어려워 난해했지만 알고나니 더 난해한 비교적 간단하게 할 수 있는 파트였다. 이제 어디가서 이 두 플랫폼의 결제 영수증쯤은 아무렇지도 않게 검증 할 수 있다고 당당히 얘기하자.</p>\n","site":{"data":{}},"excerpt":"","more":"<p>Django framework를 이용해서 프로젝트를 만들면서 했던 여러가지 삽질들과 넘어야했던 많은 산들과 몰랐던 부분들에 대해서 내 나름 공부 겸 기록을 위해 남겨둬야 겠다는 생각이 들었다. 프로젝트로 한창 바빴던 시기에는 당장 앞에 놓여진 일들에 치여 이런 생각을 못하고 있다가 지금은 조금 여유가 되어 그 때 있었던 일들에 대한 나름의 경험을 기록해보고자 한다.</p>\n<p>그 중에 한가지가 인앱 아이템 결제하기 였다. 나는 예전에 cocos2d-x로 게임을 개발했던 시절엔 결제 프로세스를 클라이언트(단말기)사이드만 알고 있었고 서버사이드의 로직은 전혀 모르고 있었는데, 오히려 이번에 서버 로직을 구현하면서 그 때 그 시절의 경험이 많은 도움이 되었다. 앱 내에 아이템을 구매하고 구매한 아이템을 유저에게 잘 넣어주는 로직이야 구현방식도 다양하고 여러 기교들이 들어가 있는데 오늘은 그 중에서 나름 간단한(?) 파트인 두 플랫폼의 결제 영수증 검증 로직의 삽질 경험을 적어보고자 한다.</p>\n<p>이번에 대응했던 클라이언트는 google play store와 iOS app store 두개의 플랫폼이다. 차례차례 훑어보자.<br>\n각 플랫폼별 스토어의 앱 등록과 각종 키발급 같은 내용은 다루지 않고 순수하게 영수증 검증만을 볼 것이다.</p>\n<ol>\n<li>google In-app billing<br>\n구글 결제 영수증 검증의 경우 생각보다 단순해서 처음에는 이게 맞나? 싶었다. 일반적으로 생각하기에는 구글의 결제서버에 영수증 정보를 넘겨 유효한 영수증인지 여부를 판단해서 진행이 되는줄 알았는데(이렇게 하는 방법도 있다고 한다.), 훨씬 간단한 방법이 있었다. 암호화된 영수증 정보를 클라이언트로 부터 받아와서 local에서 검증하는 방식이다.</li>\n</ol>\n<p>일단 pip를 이용해서 Crypto 라이브러리를 설치하도록 하자.</p>\n<figure class=\"highlight cmake\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">pip <span class=\"keyword\">install</span> pycrypto</span><br></pre></td></tr></table></figure>\n<p>다음은 영수증 검증 코드이다. signed_data 는 안드로이드 결제완료시 넘어온 암호화된 영수증 문자열이고 signature는 클라이언트와 약속된 특정 문자열이다. 안드로이드에서 결제를 요청할 당시 이 값을 함께 넘겨주면 signed_data 내부에 이 signature 값이 심어들어가게 되고, 복호화를 하면 이 값이 풀어져 나와 영수증 검증을 할 수 있다.</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> base64 <span class=\"keyword\">import</span> b64decode</span><br><span class=\"line\"><span class=\"keyword\">from</span> Crypto.Hash <span class=\"keyword\">import</span> SHA</span><br><span class=\"line\"><span class=\"keyword\">from</span> Crypto.PublicKey <span class=\"keyword\">import</span> RSA</span><br><span class=\"line\"><span class=\"keyword\">from</span> Crypto.Signature <span class=\"keyword\">import</span> PKCS1_v1_5</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># Your base64 encoded public key from Google Play.</span></span><br><span class=\"line\">PUBLIC_KEY_BASE64 = <span class=\"string\">'YOUR_PUBLIC_KEY_BASE64'</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">verify_for_google</span><span class=\"params\">(signed_data, signature)</span>:</span></span><br><span class=\"line\">    <span class=\"string\">\"\"\"Returns whether the given data was signed with the private key.\"\"\"</span></span><br><span class=\"line\">    key = RSA.importKey(_pem_format(PUBLIC_KEY_BASE64))</span><br><span class=\"line\">    verifier = PKCS1_v1_5.new(key)</span><br><span class=\"line\">    data = SHA.new(signed_data.encode(<span class=\"string\">'utf8'</span>))</span><br><span class=\"line\">    sig = b64decode(signature)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> verifier.verify(data, sig)</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">_pem_format</span><span class=\"params\">(key)</span>:</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">'\\n'</span>.join([</span><br><span class=\"line\">        <span class=\"string\">'-----BEGIN PUBLIC KEY-----'</span>,</span><br><span class=\"line\">        <span class=\"string\">'\\n'</span>.join(_chunks(key, <span class=\"number\">64</span>)),</span><br><span class=\"line\">        <span class=\"string\">'-----END PUBLIC KEY-----'</span></span><br><span class=\"line\">    ])</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">_chunks</span><span class=\"params\">(s, n)</span>:</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> start <span class=\"keyword\">in</span> range(<span class=\"number\">0</span>, len(s), n):</span><br><span class=\"line\">        <span class=\"keyword\">yield</span> s[start:start+n]</span><br></pre></td></tr></table></figure>\n<p>먼저 스토어에서 발급받은 공개키가 필요하다. 이 키를 이용해 넘어온 데이터가 유효한지 여부를 판단할 수 있다.</p>\n<ol>\n<li>RSA 암호 방식으로 암호화가 되어 있기 때문에 PUBLIC KEY 를 이용해 key객체를 생성한다.</li>\n<li>PKCS(Public Key Cryptography Standard)를 이용해서 암호화된 영수증을 검증 할것이다. 1번에서 만들어진 key를 이용해 verifier 객체를 생성하자.</li>\n<li>SHA(Secure Hash Algorithm)으로 된 signed_data를 객체로 생성한다.</li>\n<li>signature 를 decode 한다.</li>\n<li>2번에서 생성한 verifier를 통해 data 와 sig 의 유효성을 판단한다. 유효한 영수증은 True 그렇지 않으면 False 를 반환한다.<br>\n이 부분에 대해서는 좀 더 공부가 필요해 보인다… 현재는 암호화에 대한 꼭지들이 의미하는 바를 인지해야겠지만 이들이 어떤 작업을 하는지에 대한 공부도 반드시 필요할 것이다.<br>\n코드 내용이 그리 간단하지는 않지만 비교적 빠르게 구글 영수증 검증을 할 수 있었다. 구글의 개발자 사이트를 들어가 이런 저런 글도 읽오보고 여러 포스팅을 찾아보면서 여러가지 자료를 봐왔었는데 stackoverflow 에서 찾은 글들을 추려 간단하게 메소드로 정리했다. 내가 여기서 삽질 했던 부분은 대체 signed_data 와 signature 가 무엇을 뜻하는지 알 수가 없었다는 점이였다. 대부분의 자료들에서는 저 둘이 무엇을 의미하는지 자세히 기술을 해놓지 않거나 아예 어떤 값을 의미하는지를 써놓지 않은 글들이 많았다. 나도 처음에는 이리저리 고민을 해보다가 일단 맨땅에 헤딩을 하고보자는 마음으로 여러 땅에 삽집을 하다가 찾은 결과물이다.</li>\n</ol>\n<ol start=\"2\">\n<li>iOS in-app purchase<br>\n이번에는 iOS결제 영수증 검증을 해보도록 하자. apple은 구글과는 다르게 결제 서버에 영수증을 보내서 넘어온 값을 통해 영수증의 유효성을 판단한다. 직접 apple의 결제 api를 호출해서 검증을 해도 되지만 역시나 Python은 있을만하다고 생각하는 라이브러리는 이미 존재하거나 누군가가 만들어 놨다. 우리는 이 라이브러리를 만든분 께 감사를 드리며 코드를 받아가도록 하자.</li>\n</ol>\n<figure class=\"highlight cmake\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">pip <span class=\"keyword\">install</span> itunes-iap</span><br></pre></td></tr></table></figure>\n<p>itunes-iap를 설치하면 의존성 라이브러리들이 이것저것 왕창 설치된다. 궁금하면 ($pip list 를 통해 확인해볼것)<br>\n이번에는 iOS 영수증 검증 코드를 보도록 하자. 이 때 transaction_id 는 결제 당시 결과값으로 오는 구매 영수증 id이고, raw_data는 암호화된 영수증 문자열이다.</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> itunesiap</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">_verify_for_ios</span><span class=\"params\">(transaction_id: str, raw_data: str)</span>:</span></span><br><span class=\"line\">    <span class=\"string\">\"\"\"</span></span><br><span class=\"line\"><span class=\"string\">    seeAlso : https://developer.apple.com/library/ios/releasenotes/General/ValidateAppStoreReceipt/Chapters/ValidateRemotely.html</span></span><br><span class=\"line\"><span class=\"string\">    :param transaction_id: 결제 transaction_id</span></span><br><span class=\"line\"><span class=\"string\">    :param raw_data: base64-encoded data</span></span><br><span class=\"line\"><span class=\"string\">    :return: boolean</span></span><br><span class=\"line\"><span class=\"string\">    :raises: Otherwise raise a request exception (RuntimeError, itunesiap.exc.InvalidReceipt)</span></span><br><span class=\"line\"><span class=\"string\">    \"\"\"</span></span><br><span class=\"line\">    <span class=\"keyword\">try</span>:</span><br><span class=\"line\">        <span class=\"comment\"># for sandbox environment.</span></span><br><span class=\"line\">        <span class=\"comment\">#     with itunesiap.env.sandbox:</span></span><br><span class=\"line\">        <span class=\"comment\">#         response = itunesiap.verify(raw_data)</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\"># for production environment. (default)</span></span><br><span class=\"line\">        response = itunesiap.verify(raw_data)  <span class=\"comment\"># base64-encoded data</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">_get_key</span><span class=\"params\">(re)</span>:</span></span><br><span class=\"line\">            <span class=\"string\">\"\"\" 영수증리스트에서 비교 키를 반환합니다. \"\"\"</span></span><br><span class=\"line\">            <span class=\"keyword\">return</span> re.purchase_date_ms</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\"># 넘어온 in_app 영수증 리스트에서 구매 시각이 가장 마지막인 영수증을 가져와서 transaction_id를 비교한다.</span></span><br><span class=\"line\">        <span class=\"comment\"># 오름 차순으로 정렬해서 구매시각이 가장 마지막 영수증을 가져옵니다.</span></span><br><span class=\"line\">        receipts = sorted(response.receipt.in_app, key=_get_key)</span><br><span class=\"line\">        last_receipt = receipts[len(receipts) - <span class=\"number\">1</span>]</span><br><span class=\"line\">        <span class=\"keyword\">if</span> last_receipt.transaction_id != transaction_id:</span><br><span class=\"line\">            <span class=\"comment\">#  구매시각이 가장 마지막인 영수증의 transaction_id 가 일치 하지 않는다.</span></span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">False</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> response.status == <span class=\"number\">0</span></span><br></pre></td></tr></table></figure>\n<p>iOS 영수증 유효성 검증은 간단하다. itunesiap.verify 메소드를 통해 iOS에서 넘어온 데이터를 넣고 호출하면 복호화된 영수증 데이터가 나온다. 이 때 status 값이 0 이라면 유효한 영수증이라고 판단한다. 뭔가 apple다운 api라고 생각한다. 처음 iOS영수증 검증을 할 당시엔 verify 메소드만 호출하고 그 뒤에 넘어온 데이터의 status 값만 확인하고 유효성을 검증했다.<br>\n여기서 나의 삽질이 시작되었다.</p>\n<ol>\n<li>\n<p>일단 주석에서 보는것과 같이 sandbox환경과 real환경일 때에 호출하는 api가 다르다. itunesiap의 환경을 설정을 해주는 방법은 여러가지가 있다. 각자 개발환경에서 영수증 유효성을 검사할 때엔 sandbox와 real환경을 잘 구분해서 api를 호출해주도록 하자. 아무리 유효한 영수증이라 할지라도 틀린 환경의 api를 호출하면 유효하지 않다고 판단하기 때문이다.</p>\n</li>\n<li>\n<p>보통 verify 메소드를 호출하면 receipt 값 안에 하나의 영수증 정보만 가져온다. 하지만 특정 상황의 경우 receipt 데이터 안에 1개 이상의 영수증 정보가 딸려 오는 경우가 있다. 이 때에 한가지 데이터만이 유효한 영수증 값이다. 이 중에서 한가지 영수증만을 가지고 검증을 해야 하는데 여러 삽질 후에 깨달은 바는 receipt 안의 데이터들의 purchase_date_ms 값을 이용해 가장 마지막에 결제된 영수증 정보가 파라메터로 넘어온 transaction_id 와 동일하다는 점을 알게 되었다. 그래서 _get_key 메소드를 통해 receipt 리스트를 정렬하고, 그 중에 가장 마지막 영수증 정보를 뽑아 transaction_id 가 같은지 여부를 판단한다.</p>\n</li>\n</ol>\n<p>자 이제 우리는 python을 이용해서 android, iOS의 영수증을 검증할 수 있게 되었다. 간단하지도 복잡하지도 않고, 몰랐을 때는 어려워 난해했지만 알고나니 더 난해한 비교적 간단하게 할 수 있는 파트였다. 이제 어디가서 이 두 플랫폼의 결제 영수증쯤은 아무렇지도 않게 검증 할 수 있다고 당당히 얘기하자.</p>\n"},{"title":"Spring boot 에서 gradle 에 정의되어있는 정보 가져오기","catalog":true,"date":"2018-05-20T08:07:49.000Z","subtitle":null,"header-img":"/img/header_img/bg.png","_content":"\n### 버전을 알고 싶다\n사내에서 서비스 하고 있는 프로젝트에서 버그가 발견되었다. 그런데 이 버그는 원래는 없었는데 어느 순간부터 갑자기 등장했다. 그렇다면 어느 순간에 추가된 코드에 내재되어 있는 버그라는 이야기 인데 이를 추적하기 위해서는 커밋 로그를 모두 찾아야 한다. 로그에 버전 정보를 심을 수 있다면 특정 버전부터 발생했는지 여부를 쉽게 알 수 있을 것이다. 버전은 하루에도 몇번씩 올라갈 수 있기 때문에 버그가 발생한 최초 버전을 파악할 수 있으면 좀 더 유연한 대처가 가능하겠다.  \n\n### 더 많은 정보를 알 수는 없을까?\n사내에서 사용하고 있는 spring-boot proejct 는 multi project 로써 사용하고 있고 각 팀별로 module name 을 갖고 있다. 특정 모듈들은 공통으로 사용하고 있기 때문에 (mysql, util, redis 등) 내가 쏘아올린 작은 공이 언제 어느 프로젝트에서 영향을 줄지 금방 파악하기 힘들다. 이전에 작성했던 [ Spring-boot Actuator 포스팅](https://nevercaution.github.io/2018/03/24/spring-boot-actuator/) 을 이용해 git 정보를 특정 endpoint 로 제공하는 기능을 만들어서 사내에서 유용하게 사용하고 있는데, 이와같이 각 팀별로 사용하고 있는 프로젝트에 정보들을 내가 마음대로 사용할 수 있으면 좋을 것 같다.  \n\n### Gradle ext info\n우리는 내부적으로 약속된 값을 통해 각 팀별로 특정 정보들을 사용한다.  \n\n`build.gradle`  \n\n```\next {\n    appVersion = '1.0.1-SNAPSHOT'\n    projectName = \"teddy.bear\"\n}\n```\n사내에서 장애 알림은 [sentry](https://sentry.io/) 를 사용하는데, 어떤 에러가 발생했을 때 현재 배포되어 있는 버전을 함께 표시해주면 해당 에러가 어떤 버전에서 최초 발생했는지 추적이 가능하다. (장애상황에서도 활용이 가능하지만 필요에 따라 gradle 의 정보를 마음대로 사용할 수 있으면 상황에 따라 장점이 있다고 생각한다.)  \n\n### Shut up and code\n공식문서의 [Automatic Property Expansion Using Gradle](https://docs.spring.io/spring-boot/docs/current/reference/html/howto-properties-and-configuration.html#howto-automatic-expansion-gradle) 부분을 참고해서 만들었다. 잘 동작한다. :)  \n`build.gradle` 에 정의되어 있는 값들을 사용하기 위해선 다음과 같이 설정해주면 된다. 공식문서에서 주석을 달아놓은 부분이 있는데, `SimpleTemplateEngine` 에서는 `$` 를 파싱하는 부분에서 충돌이 발생할 수 있어 별도의 처리를 해야 한다고 명시되어 있다. 참고로 이 부분에서 실제 프로젝트에 적용시킬 때 문제가 조금 있었는데, 단순히 `expand(project.properties)` 만 하게 되면 모든 설정파일을 가져가게 된다. 파일들에 `$` 를 사용했다면 파싱을 하다가 깨질 수 있으니 escape 처리를 해주어야 하는데, 현재 상황은 내가 필요한 설정 파일만 가져가면 되기 때문에 내가 원하는 파일들만 expand 하도록 하자. 별도의 처리를 하지 않으면 에러를 내며 `processResources` 에서 작업이 멈춘다.  \n\n```bash\n:processResources FAILED\n\nFAILURE: Build failed with an exception.\n\n* What went wrong:\nExecution failed for task ':processResources'.\n> Could not copy file '/path/to/file/error.ftl' to '/path/to/file/build/resources/main/error.ftl'.\n```\n\n`filesMatching` 로 원하는 파일 포멧만 하도록 감싸주자. (실제 이 부분에서 적용하다가 에러를 발생해서 모든 `$` 에 escape 처리를 할까 하다가 그건 좀 아닌것 같아 아래와 같이 처리했다.)    \n\n`build.gradle`  \n\n```\nprocessResources {\n    filesMatching('**/application.yml') {\n        expand(project.properties)\n    }\n}\n```\n\n`application.yml`  \n\n```yml\next.appVersion: ${ext.appVersion}\next.projectName: ${ext.projectName}\n```\n\n`Info.class`  \n\n```java\n@Value(\"${ext.appVersion}\")\nprivate String appVersion;\n\n@Value(\"${ext.projectName}\")\nprivate String projectName;\n```\n\n```bash\n$ curl localhost:8081/main\n\nproject name : teddy.bear, version : 1.0.1-SNAPSHOT\n```\n\n설정과 사용방법은 간단하다. 그렇다면 어떻게 이게 가능한지 조금만 더 살펴보자.   \n핵심은 `build.gradle` 에서 명시해준 `expand(project.properties)` 의 동작인데 build 를 하게 되면 다음의 동작을 수행한다.  \n\n```bash\n$ ./build\nExecuting task 'build'...\n\n:bootBuildInfo\n:compileJava\n:processResources   <- here!\n:classes\n:bootJar\n:jar SKIPPED\n:assemble\n:compileTestJava\n:processTestResources NO-SOURCE\n:testClasses\n:test\n:check\n:build\n```\n빌드 동작에서 컴파일을 하고 resources 파일들을 말아서(?) 만들어 주는데, `application.xml` 에 명시 되어 있는 `ext` 관련 값들의 매핑을 시켜줄 때 `gradle` 에 명시 되어 있는 값들로 채워준다. 빌드가 완료된 후 `build/resources/main/application.xml` 파일을 보면 매핑된 값들로 채워져 있는 것을 볼 수 있다.  \n\n`application.xml`  \n\n```xml\next.appVersion: 1.0.1-SNAPSHOT\next.projectName: teddy.bear\n```\n\n저 위에서 작성한 코드가 위와 같이 바뀌어 있음을 확인할 수 있다.  \n\n\n### 결론\n구글링을 조금 해보니 gradle 의 명시되어 있는 정보들을 다양하게 활용할 수 있었다. 회사에서 급한 마음에 이리저리 해볼 때는 잘 안되더니 카페에 와 여유롭게 마음 잡고 해봐야지 했더니 30분만에 해결되어서 조금 당황했었다(..) 이 예제 코드 전체는 [예제 코드](https://github.com/nevercaution/gradle_info) 에서 확인할 수 있다. 앞으로는 경건한 마음으로 차분하게 살펴보도록 노력하자. \n\n\n\n\n\n\n\n\n\n\n","source":"_posts/spring-boot-use-gradle-value.md","raw":"---\ntitle: Spring boot 에서 gradle 에 정의되어있는 정보 가져오기  \ncatalog: true\ndate: 2018-05-20 17:07:49\nsubtitle:\nheader-img: \"/img/header_img/bg.png\"\ntags:\n- gradle\n- springboot\n- logging\n---\n\n### 버전을 알고 싶다\n사내에서 서비스 하고 있는 프로젝트에서 버그가 발견되었다. 그런데 이 버그는 원래는 없었는데 어느 순간부터 갑자기 등장했다. 그렇다면 어느 순간에 추가된 코드에 내재되어 있는 버그라는 이야기 인데 이를 추적하기 위해서는 커밋 로그를 모두 찾아야 한다. 로그에 버전 정보를 심을 수 있다면 특정 버전부터 발생했는지 여부를 쉽게 알 수 있을 것이다. 버전은 하루에도 몇번씩 올라갈 수 있기 때문에 버그가 발생한 최초 버전을 파악할 수 있으면 좀 더 유연한 대처가 가능하겠다.  \n\n### 더 많은 정보를 알 수는 없을까?\n사내에서 사용하고 있는 spring-boot proejct 는 multi project 로써 사용하고 있고 각 팀별로 module name 을 갖고 있다. 특정 모듈들은 공통으로 사용하고 있기 때문에 (mysql, util, redis 등) 내가 쏘아올린 작은 공이 언제 어느 프로젝트에서 영향을 줄지 금방 파악하기 힘들다. 이전에 작성했던 [ Spring-boot Actuator 포스팅](https://nevercaution.github.io/2018/03/24/spring-boot-actuator/) 을 이용해 git 정보를 특정 endpoint 로 제공하는 기능을 만들어서 사내에서 유용하게 사용하고 있는데, 이와같이 각 팀별로 사용하고 있는 프로젝트에 정보들을 내가 마음대로 사용할 수 있으면 좋을 것 같다.  \n\n### Gradle ext info\n우리는 내부적으로 약속된 값을 통해 각 팀별로 특정 정보들을 사용한다.  \n\n`build.gradle`  \n\n```\next {\n    appVersion = '1.0.1-SNAPSHOT'\n    projectName = \"teddy.bear\"\n}\n```\n사내에서 장애 알림은 [sentry](https://sentry.io/) 를 사용하는데, 어떤 에러가 발생했을 때 현재 배포되어 있는 버전을 함께 표시해주면 해당 에러가 어떤 버전에서 최초 발생했는지 추적이 가능하다. (장애상황에서도 활용이 가능하지만 필요에 따라 gradle 의 정보를 마음대로 사용할 수 있으면 상황에 따라 장점이 있다고 생각한다.)  \n\n### Shut up and code\n공식문서의 [Automatic Property Expansion Using Gradle](https://docs.spring.io/spring-boot/docs/current/reference/html/howto-properties-and-configuration.html#howto-automatic-expansion-gradle) 부분을 참고해서 만들었다. 잘 동작한다. :)  \n`build.gradle` 에 정의되어 있는 값들을 사용하기 위해선 다음과 같이 설정해주면 된다. 공식문서에서 주석을 달아놓은 부분이 있는데, `SimpleTemplateEngine` 에서는 `$` 를 파싱하는 부분에서 충돌이 발생할 수 있어 별도의 처리를 해야 한다고 명시되어 있다. 참고로 이 부분에서 실제 프로젝트에 적용시킬 때 문제가 조금 있었는데, 단순히 `expand(project.properties)` 만 하게 되면 모든 설정파일을 가져가게 된다. 파일들에 `$` 를 사용했다면 파싱을 하다가 깨질 수 있으니 escape 처리를 해주어야 하는데, 현재 상황은 내가 필요한 설정 파일만 가져가면 되기 때문에 내가 원하는 파일들만 expand 하도록 하자. 별도의 처리를 하지 않으면 에러를 내며 `processResources` 에서 작업이 멈춘다.  \n\n```bash\n:processResources FAILED\n\nFAILURE: Build failed with an exception.\n\n* What went wrong:\nExecution failed for task ':processResources'.\n> Could not copy file '/path/to/file/error.ftl' to '/path/to/file/build/resources/main/error.ftl'.\n```\n\n`filesMatching` 로 원하는 파일 포멧만 하도록 감싸주자. (실제 이 부분에서 적용하다가 에러를 발생해서 모든 `$` 에 escape 처리를 할까 하다가 그건 좀 아닌것 같아 아래와 같이 처리했다.)    \n\n`build.gradle`  \n\n```\nprocessResources {\n    filesMatching('**/application.yml') {\n        expand(project.properties)\n    }\n}\n```\n\n`application.yml`  \n\n```yml\next.appVersion: ${ext.appVersion}\next.projectName: ${ext.projectName}\n```\n\n`Info.class`  \n\n```java\n@Value(\"${ext.appVersion}\")\nprivate String appVersion;\n\n@Value(\"${ext.projectName}\")\nprivate String projectName;\n```\n\n```bash\n$ curl localhost:8081/main\n\nproject name : teddy.bear, version : 1.0.1-SNAPSHOT\n```\n\n설정과 사용방법은 간단하다. 그렇다면 어떻게 이게 가능한지 조금만 더 살펴보자.   \n핵심은 `build.gradle` 에서 명시해준 `expand(project.properties)` 의 동작인데 build 를 하게 되면 다음의 동작을 수행한다.  \n\n```bash\n$ ./build\nExecuting task 'build'...\n\n:bootBuildInfo\n:compileJava\n:processResources   <- here!\n:classes\n:bootJar\n:jar SKIPPED\n:assemble\n:compileTestJava\n:processTestResources NO-SOURCE\n:testClasses\n:test\n:check\n:build\n```\n빌드 동작에서 컴파일을 하고 resources 파일들을 말아서(?) 만들어 주는데, `application.xml` 에 명시 되어 있는 `ext` 관련 값들의 매핑을 시켜줄 때 `gradle` 에 명시 되어 있는 값들로 채워준다. 빌드가 완료된 후 `build/resources/main/application.xml` 파일을 보면 매핑된 값들로 채워져 있는 것을 볼 수 있다.  \n\n`application.xml`  \n\n```xml\next.appVersion: 1.0.1-SNAPSHOT\next.projectName: teddy.bear\n```\n\n저 위에서 작성한 코드가 위와 같이 바뀌어 있음을 확인할 수 있다.  \n\n\n### 결론\n구글링을 조금 해보니 gradle 의 명시되어 있는 정보들을 다양하게 활용할 수 있었다. 회사에서 급한 마음에 이리저리 해볼 때는 잘 안되더니 카페에 와 여유롭게 마음 잡고 해봐야지 했더니 30분만에 해결되어서 조금 당황했었다(..) 이 예제 코드 전체는 [예제 코드](https://github.com/nevercaution/gradle_info) 에서 확인할 수 있다. 앞으로는 경건한 마음으로 차분하게 살펴보도록 노력하자. \n\n\n\n\n\n\n\n\n\n\n","slug":"spring-boot-use-gradle-value","published":1,"updated":"2018-06-07T07:47:27.858Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjq98soqd000n8ghhlx19wmt1","content":"<h3><span id=\"버전을-알고-싶다\">버전을 알고 싶다</span></h3>\n<p>사내에서 서비스 하고 있는 프로젝트에서 버그가 발견되었다. 그런데 이 버그는 원래는 없었는데 어느 순간부터 갑자기 등장했다. 그렇다면 어느 순간에 추가된 코드에 내재되어 있는 버그라는 이야기 인데 이를 추적하기 위해서는 커밋 로그를 모두 찾아야 한다. 로그에 버전 정보를 심을 수 있다면 특정 버전부터 발생했는지 여부를 쉽게 알 수 있을 것이다. 버전은 하루에도 몇번씩 올라갈 수 있기 때문에 버그가 발생한 최초 버전을 파악할 수 있으면 좀 더 유연한 대처가 가능하겠다.</p>\n<h3><span id=\"더-많은-정보를-알-수는-없을까\">더 많은 정보를 알 수는 없을까?</span></h3>\n<p>사내에서 사용하고 있는 spring-boot proejct 는 multi project 로써 사용하고 있고 각 팀별로 module name 을 갖고 있다. 특정 모듈들은 공통으로 사용하고 있기 때문에 (mysql, util, redis 등) 내가 쏘아올린 작은 공이 언제 어느 프로젝트에서 영향을 줄지 금방 파악하기 힘들다. 이전에 작성했던 <a href=\"https://nevercaution.github.io/2018/03/24/spring-boot-actuator/\"> Spring-boot Actuator 포스팅</a> 을 이용해 git 정보를 특정 endpoint 로 제공하는 기능을 만들어서 사내에서 유용하게 사용하고 있는데, 이와같이 각 팀별로 사용하고 있는 프로젝트에 정보들을 내가 마음대로 사용할 수 있으면 좋을 것 같다.</p>\n<h3><span id=\"gradle-ext-info\">Gradle ext info</span></h3>\n<p>우리는 내부적으로 약속된 값을 통해 각 팀별로 특정 정보들을 사용한다.</p>\n<p><code>build.gradle</code></p>\n<figure class=\"highlight nginx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"section\">ext</span> &#123;</span><br><span class=\"line\">    <span class=\"attribute\">appVersion</span> = <span class=\"string\">'1.0.1-SNAPSHOT'</span></span><br><span class=\"line\">    projectName = <span class=\"string\">\"teddy.bear\"</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>사내에서 장애 알림은 <a href=\"https://sentry.io/\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">sentry</a> 를 사용하는데, 어떤 에러가 발생했을 때 현재 배포되어 있는 버전을 함께 표시해주면 해당 에러가 어떤 버전에서 최초 발생했는지 추적이 가능하다. (장애상황에서도 활용이 가능하지만 필요에 따라 gradle 의 정보를 마음대로 사용할 수 있으면 상황에 따라 장점이 있다고 생각한다.)</p>\n<h3><span id=\"shut-up-and-code\">Shut up and code</span></h3>\n<p>공식문서의 <a href=\"https://docs.spring.io/spring-boot/docs/current/reference/html/howto-properties-and-configuration.html#howto-automatic-expansion-gradle\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">Automatic Property Expansion Using Gradle</a> 부분을 참고해서 만들었다. 잘 동작한다. :)<br>\n<code>build.gradle</code> 에 정의되어 있는 값들을 사용하기 위해선 다음과 같이 설정해주면 된다. 공식문서에서 주석을 달아놓은 부분이 있는데, <code>SimpleTemplateEngine</code> 에서는 <code>$</code> 를 파싱하는 부분에서 충돌이 발생할 수 있어 별도의 처리를 해야 한다고 명시되어 있다. 참고로 이 부분에서 실제 프로젝트에 적용시킬 때 문제가 조금 있었는데, 단순히 <code>expand(project.properties)</code> 만 하게 되면 모든 설정파일을 가져가게 된다. 파일들에 <code>$</code> 를 사용했다면 파싱을 하다가 깨질 수 있으니 escape 처리를 해주어야 하는데, 현재 상황은 내가 필요한 설정 파일만 가져가면 되기 때문에 내가 원하는 파일들만 expand 하도록 하자. 별도의 처리를 하지 않으면 에러를 내며 <code>processResources</code> 에서 작업이 멈춘다.</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">:processResources FAILED</span><br><span class=\"line\"></span><br><span class=\"line\">FAILURE: Build failed with an exception.</span><br><span class=\"line\"></span><br><span class=\"line\">* What went wrong:</span><br><span class=\"line\">Execution failed <span class=\"keyword\">for</span> task <span class=\"string\">':processResources'</span>.</span><br><span class=\"line\">&gt; Could not copy file <span class=\"string\">'/path/to/file/error.ftl'</span> to <span class=\"string\">'/path/to/file/build/resources/main/error.ftl'</span>.</span><br></pre></td></tr></table></figure>\n<p><code>filesMatching</code> 로 원하는 파일 포멧만 하도록 감싸주자. (실제 이 부분에서 적용하다가 에러를 발생해서 모든 <code>$</code> 에 escape 처리를 할까 하다가 그건 좀 아닌것 같아 아래와 같이 처리했다.)</p>\n<p><code>build.gradle</code></p>\n<figure class=\"highlight less\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-tag\">processResources</span> &#123;</span><br><span class=\"line\">    <span class=\"selector-tag\">filesMatching</span>(<span class=\"string\">'**/application.yml'</span>) &#123;</span><br><span class=\"line\">        <span class=\"selector-tag\">expand</span>(project.properties)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><code>application.yml</code></p>\n<figure class=\"highlight yml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">ext.appVersion:</span> <span class=\"string\">$&#123;ext.appVersion&#125;</span></span><br><span class=\"line\"><span class=\"string\">ext.projectName:</span> <span class=\"string\">$&#123;ext.projectName&#125;</span></span><br></pre></td></tr></table></figure>\n<p><code>Info.class</code></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Value</span>(<span class=\"string\">\"$&#123;ext.appVersion&#125;\"</span>)</span><br><span class=\"line\"><span class=\"keyword\">private</span> String appVersion;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Value</span>(<span class=\"string\">\"$&#123;ext.projectName&#125;\"</span>)</span><br><span class=\"line\"><span class=\"keyword\">private</span> String projectName;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ curl localhost:8081/main</span><br><span class=\"line\"></span><br><span class=\"line\">project name : teddy.bear, version : 1.0.1-SNAPSHOT</span><br></pre></td></tr></table></figure>\n<p>설정과 사용방법은 간단하다. 그렇다면 어떻게 이게 가능한지 조금만 더 살펴보자.<br>\n핵심은 <code>build.gradle</code> 에서 명시해준 <code>expand(project.properties)</code> 의 동작인데 build 를 하게 되면 다음의 동작을 수행한다.</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ ./build</span><br><span class=\"line\">Executing task <span class=\"string\">'build'</span>...</span><br><span class=\"line\"></span><br><span class=\"line\">:bootBuildInfo</span><br><span class=\"line\">:compileJava</span><br><span class=\"line\">:processResources   &lt;- here!</span><br><span class=\"line\">:classes</span><br><span class=\"line\">:bootJar</span><br><span class=\"line\">:jar SKIPPED</span><br><span class=\"line\">:assemble</span><br><span class=\"line\">:compileTestJava</span><br><span class=\"line\">:processTestResources NO-SOURCE</span><br><span class=\"line\">:testClasses</span><br><span class=\"line\">:<span class=\"built_in\">test</span></span><br><span class=\"line\">:check</span><br><span class=\"line\">:build</span><br></pre></td></tr></table></figure>\n<p>빌드 동작에서 컴파일을 하고 resources 파일들을 말아서(?) 만들어 주는데, <code>application.xml</code> 에 명시 되어 있는 <code>ext</code> 관련 값들의 매핑을 시켜줄 때 <code>gradle</code> 에 명시 되어 있는 값들로 채워준다. 빌드가 완료된 후 <code>build/resources/main/application.xml</code> 파일을 보면 매핑된 값들로 채워져 있는 것을 볼 수 있다.</p>\n<p><code>application.xml</code></p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ext.appVersion: 1.0.1-SNAPSHOT</span><br><span class=\"line\">ext.projectName: teddy.bear</span><br></pre></td></tr></table></figure>\n<p>저 위에서 작성한 코드가 위와 같이 바뀌어 있음을 확인할 수 있다.</p>\n<h3><span id=\"결론\">결론</span></h3>\n<p>구글링을 조금 해보니 gradle 의 명시되어 있는 정보들을 다양하게 활용할 수 있었다. 회사에서 급한 마음에 이리저리 해볼 때는 잘 안되더니 카페에 와 여유롭게 마음 잡고 해봐야지 했더니 30분만에 해결되어서 조금 당황했었다(…) 이 예제 코드 전체는 <a href=\"https://github.com/nevercaution/gradle_info\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">예제 코드</a> 에서 확인할 수 있다. 앞으로는 경건한 마음으로 차분하게 살펴보도록 노력하자.</p>\n","site":{"data":{}},"excerpt":"","more":"<h3>버전을 알고 싶다</h3>\n<p>사내에서 서비스 하고 있는 프로젝트에서 버그가 발견되었다. 그런데 이 버그는 원래는 없었는데 어느 순간부터 갑자기 등장했다. 그렇다면 어느 순간에 추가된 코드에 내재되어 있는 버그라는 이야기 인데 이를 추적하기 위해서는 커밋 로그를 모두 찾아야 한다. 로그에 버전 정보를 심을 수 있다면 특정 버전부터 발생했는지 여부를 쉽게 알 수 있을 것이다. 버전은 하루에도 몇번씩 올라갈 수 있기 때문에 버그가 발생한 최초 버전을 파악할 수 있으면 좀 더 유연한 대처가 가능하겠다.</p>\n<h3>더 많은 정보를 알 수는 없을까?</h3>\n<p>사내에서 사용하고 있는 spring-boot proejct 는 multi project 로써 사용하고 있고 각 팀별로 module name 을 갖고 있다. 특정 모듈들은 공통으로 사용하고 있기 때문에 (mysql, util, redis 등) 내가 쏘아올린 작은 공이 언제 어느 프로젝트에서 영향을 줄지 금방 파악하기 힘들다. 이전에 작성했던 <a href=\"https://nevercaution.github.io/2018/03/24/spring-boot-actuator/\"> Spring-boot Actuator 포스팅</a> 을 이용해 git 정보를 특정 endpoint 로 제공하는 기능을 만들어서 사내에서 유용하게 사용하고 있는데, 이와같이 각 팀별로 사용하고 있는 프로젝트에 정보들을 내가 마음대로 사용할 수 있으면 좋을 것 같다.</p>\n<h3>Gradle ext info</h3>\n<p>우리는 내부적으로 약속된 값을 통해 각 팀별로 특정 정보들을 사용한다.</p>\n<p><code>build.gradle</code></p>\n<figure class=\"highlight nginx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"section\">ext</span> &#123;</span><br><span class=\"line\">    <span class=\"attribute\">appVersion</span> = <span class=\"string\">'1.0.1-SNAPSHOT'</span></span><br><span class=\"line\">    projectName = <span class=\"string\">\"teddy.bear\"</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>사내에서 장애 알림은 <a href=\"https://sentry.io/\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">sentry</a> 를 사용하는데, 어떤 에러가 발생했을 때 현재 배포되어 있는 버전을 함께 표시해주면 해당 에러가 어떤 버전에서 최초 발생했는지 추적이 가능하다. (장애상황에서도 활용이 가능하지만 필요에 따라 gradle 의 정보를 마음대로 사용할 수 있으면 상황에 따라 장점이 있다고 생각한다.)</p>\n<h3>Shut up and code</h3>\n<p>공식문서의 <a href=\"https://docs.spring.io/spring-boot/docs/current/reference/html/howto-properties-and-configuration.html#howto-automatic-expansion-gradle\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">Automatic Property Expansion Using Gradle</a> 부분을 참고해서 만들었다. 잘 동작한다. :)<br>\n<code>build.gradle</code> 에 정의되어 있는 값들을 사용하기 위해선 다음과 같이 설정해주면 된다. 공식문서에서 주석을 달아놓은 부분이 있는데, <code>SimpleTemplateEngine</code> 에서는 <code>$</code> 를 파싱하는 부분에서 충돌이 발생할 수 있어 별도의 처리를 해야 한다고 명시되어 있다. 참고로 이 부분에서 실제 프로젝트에 적용시킬 때 문제가 조금 있었는데, 단순히 <code>expand(project.properties)</code> 만 하게 되면 모든 설정파일을 가져가게 된다. 파일들에 <code>$</code> 를 사용했다면 파싱을 하다가 깨질 수 있으니 escape 처리를 해주어야 하는데, 현재 상황은 내가 필요한 설정 파일만 가져가면 되기 때문에 내가 원하는 파일들만 expand 하도록 하자. 별도의 처리를 하지 않으면 에러를 내며 <code>processResources</code> 에서 작업이 멈춘다.</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">:processResources FAILED</span><br><span class=\"line\"></span><br><span class=\"line\">FAILURE: Build failed with an exception.</span><br><span class=\"line\"></span><br><span class=\"line\">* What went wrong:</span><br><span class=\"line\">Execution failed <span class=\"keyword\">for</span> task <span class=\"string\">':processResources'</span>.</span><br><span class=\"line\">&gt; Could not copy file <span class=\"string\">'/path/to/file/error.ftl'</span> to <span class=\"string\">'/path/to/file/build/resources/main/error.ftl'</span>.</span><br></pre></td></tr></table></figure>\n<p><code>filesMatching</code> 로 원하는 파일 포멧만 하도록 감싸주자. (실제 이 부분에서 적용하다가 에러를 발생해서 모든 <code>$</code> 에 escape 처리를 할까 하다가 그건 좀 아닌것 같아 아래와 같이 처리했다.)</p>\n<p><code>build.gradle</code></p>\n<figure class=\"highlight less\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-tag\">processResources</span> &#123;</span><br><span class=\"line\">    <span class=\"selector-tag\">filesMatching</span>(<span class=\"string\">'**/application.yml'</span>) &#123;</span><br><span class=\"line\">        <span class=\"selector-tag\">expand</span>(project.properties)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><code>application.yml</code></p>\n<figure class=\"highlight yml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">ext.appVersion:</span> <span class=\"string\">$&#123;ext.appVersion&#125;</span></span><br><span class=\"line\"><span class=\"string\">ext.projectName:</span> <span class=\"string\">$&#123;ext.projectName&#125;</span></span><br></pre></td></tr></table></figure>\n<p><code>Info.class</code></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Value</span>(<span class=\"string\">\"$&#123;ext.appVersion&#125;\"</span>)</span><br><span class=\"line\"><span class=\"keyword\">private</span> String appVersion;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Value</span>(<span class=\"string\">\"$&#123;ext.projectName&#125;\"</span>)</span><br><span class=\"line\"><span class=\"keyword\">private</span> String projectName;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ curl localhost:8081/main</span><br><span class=\"line\"></span><br><span class=\"line\">project name : teddy.bear, version : 1.0.1-SNAPSHOT</span><br></pre></td></tr></table></figure>\n<p>설정과 사용방법은 간단하다. 그렇다면 어떻게 이게 가능한지 조금만 더 살펴보자.<br>\n핵심은 <code>build.gradle</code> 에서 명시해준 <code>expand(project.properties)</code> 의 동작인데 build 를 하게 되면 다음의 동작을 수행한다.</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ ./build</span><br><span class=\"line\">Executing task <span class=\"string\">'build'</span>...</span><br><span class=\"line\"></span><br><span class=\"line\">:bootBuildInfo</span><br><span class=\"line\">:compileJava</span><br><span class=\"line\">:processResources   &lt;- here!</span><br><span class=\"line\">:classes</span><br><span class=\"line\">:bootJar</span><br><span class=\"line\">:jar SKIPPED</span><br><span class=\"line\">:assemble</span><br><span class=\"line\">:compileTestJava</span><br><span class=\"line\">:processTestResources NO-SOURCE</span><br><span class=\"line\">:testClasses</span><br><span class=\"line\">:<span class=\"built_in\">test</span></span><br><span class=\"line\">:check</span><br><span class=\"line\">:build</span><br></pre></td></tr></table></figure>\n<p>빌드 동작에서 컴파일을 하고 resources 파일들을 말아서(?) 만들어 주는데, <code>application.xml</code> 에 명시 되어 있는 <code>ext</code> 관련 값들의 매핑을 시켜줄 때 <code>gradle</code> 에 명시 되어 있는 값들로 채워준다. 빌드가 완료된 후 <code>build/resources/main/application.xml</code> 파일을 보면 매핑된 값들로 채워져 있는 것을 볼 수 있다.</p>\n<p><code>application.xml</code></p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ext.appVersion: 1.0.1-SNAPSHOT</span><br><span class=\"line\">ext.projectName: teddy.bear</span><br></pre></td></tr></table></figure>\n<p>저 위에서 작성한 코드가 위와 같이 바뀌어 있음을 확인할 수 있다.</p>\n<h3>결론</h3>\n<p>구글링을 조금 해보니 gradle 의 명시되어 있는 정보들을 다양하게 활용할 수 있었다. 회사에서 급한 마음에 이리저리 해볼 때는 잘 안되더니 카페에 와 여유롭게 마음 잡고 해봐야지 했더니 30분만에 해결되어서 조금 당황했었다(…) 이 예제 코드 전체는 <a href=\"https://github.com/nevercaution/gradle_info\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">예제 코드</a> 에서 확인할 수 있다. 앞으로는 경건한 마음으로 차분하게 살펴보도록 노력하자.</p>\n"}],"PostAsset":[],"PostCategory":[],"PostTag":[{"post_id":"cjq98sooy00018ghhbaqhoqz1","tag_id":"cjq98sopd00058ghhtgobnmzd","_id":"cjq98soqb000k8ghh58wmorup"},{"post_id":"cjq98sooy00018ghhbaqhoqz1","tag_id":"cjq98sopo00098ghhvgubxwxm","_id":"cjq98soqd000m8ghhektih9wi"},{"post_id":"cjq98sooy00018ghhbaqhoqz1","tag_id":"cjq98sops000c8ghh6hn5w245","_id":"cjq98soqf000p8ghhgxh3wrxt"},{"post_id":"cjq98sooy00018ghhbaqhoqz1","tag_id":"cjq98sopx000f8ghhc11u4msg","_id":"cjq98soqf000q8ghh8kdixm4t"},{"post_id":"cjq98sop700038ghhbv67eoui","tag_id":"cjq98soq7000i8ghhiddx9vm8","_id":"cjq98soqj000u8ghhdffjg3mc"},{"post_id":"cjq98sop700038ghhbv67eoui","tag_id":"cjq98soqf000o8ghhtpr8kj0w","_id":"cjq98soqj000v8ghhm92m291g"},{"post_id":"cjq98sop700038ghhbv67eoui","tag_id":"cjq98soqh000r8ghhxt3r7v3f","_id":"cjq98soqk000x8ghh9nkg0l88"},{"post_id":"cjq98sop700038ghhbv67eoui","tag_id":"cjq98soqh000s8ghh4za7sr2e","_id":"cjq98soqk000y8ghhtta6oe3o"},{"post_id":"cjq98sopg00068ghh02qeqedo","tag_id":"cjq98soqf000o8ghhtpr8kj0w","_id":"cjq98soqk00108ghhkh59zpn9"},{"post_id":"cjq98sopg00068ghh02qeqedo","tag_id":"cjq98soqj000w8ghhyfalun5e","_id":"cjq98soqk00118ghh5490x5bc"},{"post_id":"cjq98sopj00078ghhw3vpyg60","tag_id":"cjq98soqf000o8ghhtpr8kj0w","_id":"cjq98soql00148ghhydzqj940"},{"post_id":"cjq98sopj00078ghhw3vpyg60","tag_id":"cjq98soqk00128ghhuqn9o532","_id":"cjq98soql00158ghhc7g887oq"},{"post_id":"cjq98sopl00088ghh9207svub","tag_id":"cjq98sopo00098ghhvgubxwxm","_id":"cjq98soqn001b8ghheg0umhba"},{"post_id":"cjq98sopl00088ghh9207svub","tag_id":"cjq98soql00168ghhs0f2t3br","_id":"cjq98soqn001c8ghhxgxa1j1o"},{"post_id":"cjq98sopl00088ghh9207svub","tag_id":"cjq98soql00178ghh7r1u1lw4","_id":"cjq98soqn001e8ghh76bgpeuc"},{"post_id":"cjq98sopl00088ghh9207svub","tag_id":"cjq98soqm00188ghhrzvwcnmz","_id":"cjq98soqn001f8ghhlro0xq10"},{"post_id":"cjq98sopl00088ghh9207svub","tag_id":"cjq98soqm00198ghh2on5ytfs","_id":"cjq98soqn001h8ghhsb7zui4v"},{"post_id":"cjq98sopo000a8ghhjpjxbn1g","tag_id":"cjq98soql00168ghhs0f2t3br","_id":"cjq98soqo001l8ghhu42gncxy"},{"post_id":"cjq98sopo000a8ghhjpjxbn1g","tag_id":"cjq98soqn001d8ghhp86zr5wk","_id":"cjq98soqo001m8ghhe1yfpluo"},{"post_id":"cjq98sopo000a8ghhjpjxbn1g","tag_id":"cjq98soqn001g8ghhwvl46ros","_id":"cjq98soqo001o8ghhc5ob14lk"},{"post_id":"cjq98sopo000a8ghhjpjxbn1g","tag_id":"cjq98soqn001i8ghh6ooh1w5k","_id":"cjq98soqp001p8ghh88n70aro"},{"post_id":"cjq98sopo000a8ghhjpjxbn1g","tag_id":"cjq98soqo001j8ghhjndvtoqq","_id":"cjq98soqp001r8ghhgvr4usvj"},{"post_id":"cjq98sopr000b8ghhhl71adgs","tag_id":"cjq98sopo00098ghhvgubxwxm","_id":"cjq98soqp001t8ghhnr4ies9x"},{"post_id":"cjq98sopr000b8ghhhl71adgs","tag_id":"cjq98soqo001k8ghh4490pvcb","_id":"cjq98soqq001u8ghhnhhrmsnq"},{"post_id":"cjq98sopr000b8ghhhl71adgs","tag_id":"cjq98soqo001n8ghh6qbk0ykz","_id":"cjq98soqr001w8ghhylhsdsp3"},{"post_id":"cjq98sopr000b8ghhhl71adgs","tag_id":"cjq98soqp001q8ghh1yj9j0qy","_id":"cjq98soqr001x8ghh82k4xm5j"},{"post_id":"cjq98sopt000d8ghh3hn5kl9t","tag_id":"cjq98soqp001s8ghh2rfbbzlo","_id":"cjq98soqv00208ghht9y0pcs3"},{"post_id":"cjq98sopt000d8ghh3hn5kl9t","tag_id":"cjq98soql00168ghhs0f2t3br","_id":"cjq98soqv00218ghhrf1dshfp"},{"post_id":"cjq98sopt000d8ghh3hn5kl9t","tag_id":"cjq98soqr001y8ghhnn86w3xq","_id":"cjq98soqw00238ghh8wjxuei9"},{"post_id":"cjq98sopv000e8ghh26s3af46","tag_id":"cjq98sopo00098ghhvgubxwxm","_id":"cjq98soqx00258ghhm64mwaba"},{"post_id":"cjq98sopv000e8ghh26s3af46","tag_id":"cjq98soqo001j8ghhjndvtoqq","_id":"cjq98soqx00268ghhfrz732ei"},{"post_id":"cjq98sopv000e8ghh26s3af46","tag_id":"cjq98soqv00228ghhj70mqq1z","_id":"cjq98soqx00288ghh25zii9wi"},{"post_id":"cjq98sopy000g8ghh2cm6cwsx","tag_id":"cjq98sopo00098ghhvgubxwxm","_id":"cjq98soqx002a8ghhpwuvtsn7"},{"post_id":"cjq98sopy000g8ghh2cm6cwsx","tag_id":"cjq98soqw00248ghha5ppdt9i","_id":"cjq98soqx002b8ghhhhd9ysv3"},{"post_id":"cjq98sopy000g8ghh2cm6cwsx","tag_id":"cjq98soqx00278ghh6cxsvqy4","_id":"cjq98soqy002d8ghhxavunzfr"},{"post_id":"cjq98soq2000h8ghhh0mew9nt","tag_id":"cjq98sopo00098ghhvgubxwxm","_id":"cjq98soqz002g8ghh0jth1j53"},{"post_id":"cjq98soq2000h8ghhh0mew9nt","tag_id":"cjq98soqx00298ghh5q27n8ei","_id":"cjq98soqz002h8ghhtfdkgutg"},{"post_id":"cjq98soq2000h8ghhh0mew9nt","tag_id":"cjq98soqy002c8ghh60l0q0mk","_id":"cjq98sor0002j8ghhbo1p5dgl"},{"post_id":"cjq98soq2000h8ghhh0mew9nt","tag_id":"cjq98soqo001j8ghhjndvtoqq","_id":"cjq98sor0002k8ghh3nwc4ua7"},{"post_id":"cjq98soq8000j8ghhgeheffcp","tag_id":"cjq98soqy002f8ghh4d9houq0","_id":"cjq98sor2002o8ghh7c3dsrkl"},{"post_id":"cjq98soq8000j8ghhgeheffcp","tag_id":"cjq98sor0002i8ghhkewqkxwz","_id":"cjq98sor2002p8ghhlhhkdhbf"},{"post_id":"cjq98soq8000j8ghhgeheffcp","tag_id":"cjq98sopo00098ghhvgubxwxm","_id":"cjq98sor2002r8ghhf80omc2d"},{"post_id":"cjq98soq8000j8ghhgeheffcp","tag_id":"cjq98sor0002l8ghhtaqucjaj","_id":"cjq98sor2002s8ghhc80ucn1a"},{"post_id":"cjq98soq8000j8ghhgeheffcp","tag_id":"cjq98sor1002m8ghht4vrc72h","_id":"cjq98sor2002u8ghhy4j6kjfu"},{"post_id":"cjq98soqb000l8ghhmyi5g4z2","tag_id":"cjq98soq7000i8ghhiddx9vm8","_id":"cjq98sor3002w8ghhzydms63n"},{"post_id":"cjq98soqb000l8ghhmyi5g4z2","tag_id":"cjq98sor1002n8ghh24hh7u9z","_id":"cjq98sor3002x8ghhbahxb7s9"},{"post_id":"cjq98soqb000l8ghhmyi5g4z2","tag_id":"cjq98sor2002q8ghhl4glvy2r","_id":"cjq98sor3002z8ghhh3nuycrw"},{"post_id":"cjq98soqb000l8ghhmyi5g4z2","tag_id":"cjq98sor2002t8ghhn6qx7ezo","_id":"cjq98sor300308ghhj5z04ul7"},{"post_id":"cjq98soqd000n8ghhlx19wmt1","tag_id":"cjq98soqo001j8ghhjndvtoqq","_id":"cjq98sor300318ghh1qptk9ih"},{"post_id":"cjq98soqd000n8ghhlx19wmt1","tag_id":"cjq98sopo00098ghhvgubxwxm","_id":"cjq98sor300328ghhewt40zr7"},{"post_id":"cjq98soqd000n8ghhlx19wmt1","tag_id":"cjq98sor3002y8ghhfiwsv2gy","_id":"cjq98sor300338ghhp1pp8nn5"}],"Tag":[{"name":"netflix-zuul","_id":"cjq98sopd00058ghhtgobnmzd"},{"name":"springboot","_id":"cjq98sopo00098ghhvgubxwxm"},{"name":"spring-cloud","_id":"cjq98sops000c8ghh6hn5w245"},{"name":"api-gateway","_id":"cjq98sopx000f8ghhc11u4msg"},{"name":"python","_id":"cjq98soq7000i8ghhiddx9vm8"},{"name":"django","_id":"cjq98soqf000o8ghhtpr8kj0w"},{"name":"orm","_id":"cjq98soqh000r8ghhxt3r7v3f"},{"name":"docker","_id":"cjq98soqh000s8ghh4za7sr2e"},{"name":"ajax","_id":"cjq98soqj000w8ghhyfalun5e"},{"name":"sso","_id":"cjq98soqk00128ghhuqn9o532"},{"name":"elasticsearch","_id":"cjq98soql00168ghhs0f2t3br"},{"name":"restclient","_id":"cjq98soql00178ghh7r1u1lw4"},{"name":"javaclient","_id":"cjq98soqm00188ghhrzvwcnmz"},{"name":"transportlyer","_id":"cjq98soqm00198ghh2on5ytfs"},{"name":"resthighlevelclient","_id":"cjq98soqn001d8ghhp86zr5wk"},{"name":"sptingboot","_id":"cjq98soqn001g8ghhwvl46ros"},{"name":"webflux","_id":"cjq98soqn001i8ghh6ooh1w5k"},{"name":"gradle","_id":"cjq98soqo001j8ghhjndvtoqq"},{"name":"retrofit2","_id":"cjq98soqo001k8ghh4490pvcb"},{"name":"okhttp3","_id":"cjq98soqo001n8ghh6qbk0ykz"},{"name":"async","_id":"cjq98soqp001q8ghh1yj9j0qy"},{"name":"kakaopage","_id":"cjq98soqp001s8ghh2rfbbzlo"},{"name":"은전한닢","_id":"cjq98soqr001y8ghhnn86w3xq"},{"name":"spring-boot-actuator","_id":"cjq98soqv00228ghhj70mqq1z"},{"name":"annotation","_id":"cjq98soqw00248ghha5ppdt9i"},{"name":"argumentresolver","_id":"cjq98soqx00278ghh6cxsvqy4"},{"name":"jsp","_id":"cjq98soqx00298ghh5q27n8ei"},{"name":"freemarker","_id":"cjq98soqy002c8ghh60l0q0mk"},{"name":"redis","_id":"cjq98soqy002f8ghh4d9houq0"},{"name":"pubsub","_id":"cjq98sor0002i8ghhkewqkxwz"},{"name":"dynamicConfiguration","_id":"cjq98sor0002l8ghhtaqucjaj"},{"name":"lettuce","_id":"cjq98sor1002m8ghht4vrc72h"},{"name":"ios","_id":"cjq98sor1002n8ghh24hh7u9z"},{"name":"android","_id":"cjq98sor2002q8ghhl4glvy2r"},{"name":"inapp","_id":"cjq98sor2002t8ghhn6qx7ezo"},{"name":"logging","_id":"cjq98sor3002y8ghhfiwsv2gy"}]}}