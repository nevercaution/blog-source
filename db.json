{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"source/CNAME","path":"CNAME","modified":0,"renderable":0},{"_id":"source/img/icon_wechat.png","path":"img/icon_wechat.png","modified":0,"renderable":0},{"_id":"source/img/404-bg.jpg","path":"img/404-bg.jpg","modified":0,"renderable":0},{"_id":"themes/beantech/source/css/archive.styl","path":"css/archive.styl","modified":0,"renderable":1},{"_id":"themes/beantech/source/css/beantech.css","path":"css/beantech.css","modified":0,"renderable":1},{"_id":"themes/beantech/source/css/beantech.min.css","path":"css/beantech.min.css","modified":0,"renderable":1},{"_id":"themes/beantech/source/css/highlight.styl","path":"css/highlight.styl","modified":0,"renderable":1},{"_id":"themes/beantech/source/css/hux-blog.min.css","path":"css/hux-blog.min.css","modified":0,"renderable":1},{"_id":"themes/beantech/source/css/rocket.styl","path":"css/rocket.styl","modified":0,"renderable":1},{"_id":"themes/beantech/source/css/signature.styl","path":"css/signature.styl","modified":0,"renderable":1},{"_id":"themes/beantech/source/css/widget.styl","path":"css/widget.styl","modified":0,"renderable":1},{"_id":"themes/beantech/source/css/toc.styl","path":"css/toc.styl","modified":0,"renderable":1},{"_id":"themes/beantech/source/fonts/glyphicons-halflings-regular.eot","path":"fonts/glyphicons-halflings-regular.eot","modified":0,"renderable":1},{"_id":"themes/beantech/source/fonts/glyphicons-halflings-regular.ttf","path":"fonts/glyphicons-halflings-regular.ttf","modified":0,"renderable":1},{"_id":"themes/beantech/source/fonts/glyphicons-halflings-regular.woff","path":"fonts/glyphicons-halflings-regular.woff","modified":0,"renderable":1},{"_id":"themes/beantech/source/fonts/glyphicons-halflings-regular.woff2","path":"fonts/glyphicons-halflings-regular.woff2","modified":0,"renderable":1},{"_id":"themes/beantech/source/js/hux-blog.js","path":"js/hux-blog.js","modified":0,"renderable":1},{"_id":"themes/beantech/source/js/bootstrap.min.js","path":"js/bootstrap.min.js","modified":0,"renderable":1},{"_id":"themes/beantech/source/js/hux-blog.min.js","path":"js/hux-blog.min.js","modified":0,"renderable":1},{"_id":"themes/beantech/source/js/jquery.nav.js","path":"js/jquery.nav.js","modified":0,"renderable":1},{"_id":"themes/beantech/source/js/jquery.tagcloud.js","path":"js/jquery.tagcloud.js","modified":0,"renderable":1},{"_id":"themes/beantech/source/js/toc.js","path":"js/toc.js","modified":0,"renderable":1},{"_id":"themes/beantech/source/js/totop.js","path":"js/totop.js","modified":0,"renderable":1},{"_id":"source/img/header_img/Iron-Man-3.jpg","path":"img/header_img/Iron-Man-3.jpg","modified":0,"renderable":0},{"_id":"source/img/ironman-draw.png","path":"img/ironman-draw.png","modified":0,"renderable":0},{"_id":"themes/beantech/source/css/bootstrap.min.css","path":"css/bootstrap.min.css","modified":0,"renderable":1},{"_id":"themes/beantech/source/fonts/glyphicons-halflings-regular.svg","path":"fonts/glyphicons-halflings-regular.svg","modified":0,"renderable":1},{"_id":"themes/beantech/source/js/bootstrap.js","path":"js/bootstrap.js","modified":0,"renderable":1},{"_id":"themes/beantech/source/js/jquery.min.js","path":"js/jquery.min.js","modified":0,"renderable":1},{"_id":"source/img/contact-bg.jpg","path":"img/contact-bg.jpg","modified":0,"renderable":0},{"_id":"source/img/signature/BeanTechSign-white.png","path":"img/signature/BeanTechSign-white.png","modified":0,"renderable":0},{"_id":"themes/beantech/source/css/images/ironman.png","path":"css/images/ironman.png","modified":0,"renderable":1},{"_id":"themes/beantech/source/css/bootstrap.css","path":"css/bootstrap.css","modified":0,"renderable":1},{"_id":"themes/beantech/source/css/images/rocket.png","path":"css/images/rocket.png","modified":0,"renderable":1},{"_id":"source/img/header_img/tf-logo-dark.png","path":"img/header_img/tf-logo-dark.png","modified":0,"renderable":0},{"_id":"source/img/signature/BeanTechSign-black.png","path":"img/signature/BeanTechSign-black.png","modified":0,"renderable":0},{"_id":"themes/beantech/source/js/jquery.js","path":"js/jquery.js","modified":0,"renderable":1},{"_id":"source/img/beantech-desktop.png","path":"img/beantech-desktop.png","modified":0,"renderable":0},{"_id":"source/img/header_img/tag-bg.png","path":"img/header_img/tag-bg.png","modified":0,"renderable":0},{"_id":"source/img/header_img/home-bg-2-dark.png","path":"img/header_img/home-bg-2-dark.png","modified":0,"renderable":0},{"_id":"source/img/header_img/home-bg-o.png","path":"img/header_img/home-bg-o.png","modified":0,"renderable":0},{"_id":"source/img/header_img/archive-bg.png","path":"img/header_img/archive-bg.png","modified":0,"renderable":0}],"Cache":[{"_id":"source/404.md","hash":"83c2c6d587beaa967a976e5969d60fa97fcdbe55","modified":1496992978000},{"_id":"source/.DS_Store","hash":"2c307321bd71797b746a3d6d0a5aa1d8d5f885be","modified":1496995103000},{"_id":"source/CNAME","hash":"55d5b0b4757a7d65ee4966dd161f394d06d257b7","modified":1496992978000},{"_id":"themes/beantech/LICENSE","hash":"2b209f06bebeb2a8c2b7e187e436f3e1e1fbc8a7","modified":1496992979000},{"_id":"themes/beantech/_config.yml","hash":"927cbb17035d04647c9d7b8c377db3c936c4835e","modified":1496994382000},{"_id":"source/_posts/.DS_Store","hash":"d2cf00878feba59cce38168f10bcee04554dec6b","modified":1497079590000},{"_id":"source/_posts/django-ajax.md","hash":"17d8495e1a697bdc6aa5c1ec1381265b9963f041","modified":1497081381000},{"_id":"source/_posts/django-sso.md","hash":"d99c2965de8f910fbd9b8e82a2f80adb8b93021b","modified":1497083149000},{"_id":"source/_posts/store-inapp-in-python.md","hash":"1548e50a1d4579a697984bd3466addd17ced6399","modified":1496994349000},{"_id":"source/about/index.md","hash":"ebca34cfe8d13ec641d17fcfec0127a966338f8e","modified":1496992978000},{"_id":"source/archive/index.md","hash":"279ff19668395f5c6b26417da99d2c1f3ecd5886","modified":1496992978000},{"_id":"source/img/.DS_Store","hash":"ffd08ba3a921e83ef0780d5100093badab4538c8","modified":1496995114000},{"_id":"source/img/icon_wechat.png","hash":"4188058026609de06c6cac88b349a2da831a1783","modified":1496992979000},{"_id":"themes/beantech/languages_to_be_added/default.yml","hash":"97326c9e6518d9f379778178b3b8f9a58434725d","modified":1496992979000},{"_id":"source/tags/index.md","hash":"9d558ce28d0d44c3463517088689bbca44bbb364","modified":1496992979000},{"_id":"themes/beantech/languages_to_be_added/de.yml","hash":"424a9c1e6ab69334d7873f6574da02ca960aa572","modified":1496992979000},{"_id":"themes/beantech/languages_to_be_added/en.yml","hash":"97326c9e6518d9f379778178b3b8f9a58434725d","modified":1496992979000},{"_id":"themes/beantech/languages_to_be_added/es.yml","hash":"cb4eeca0ed3768a77e0cd216300f2b2549628b1b","modified":1496992979000},{"_id":"themes/beantech/languages_to_be_added/no.yml","hash":"8ca475a3b4f8efe6603030f0013aae39668230e1","modified":1496992979000},{"_id":"themes/beantech/languages_to_be_added/pl.yml","hash":"de7eb5850ae65ba7638e907c805fea90617a988c","modified":1496992979000},{"_id":"themes/beantech/languages_to_be_added/ru.yml","hash":"42df7afeb7a35dc46d272b7f4fb880a9d9ebcaa5","modified":1496992979000},{"_id":"themes/beantech/languages_to_be_added/zh-CN.yml","hash":"7bfcb0b8e97d7e5edcfca8ab26d55d9da2573c1c","modified":1496992979000},{"_id":"themes/beantech/languages_to_be_added/zh-TW.yml","hash":"9acac6cc4f8002c3fa53ff69fb8cf66c915bd016","modified":1496992979000},{"_id":"themes/beantech/layout/404.ejs","hash":"a4d73541a53e56b7dd46249c6d27cb59f4d97422","modified":1496992979000},{"_id":"themes/beantech/layout/about.ejs","hash":"edcf8fa3bf7093c974d418ffef42ac89c19af128","modified":1496992979000},{"_id":"themes/beantech/layout/archive.ejs","hash":"72a150c8dff0031a9107d12eaa7c2e6c6ce950d2","modified":1496992979000},{"_id":"themes/beantech/layout/index.ejs","hash":"dc8a6eaa00d1e7c33a40979afe0953ed5d7b512e","modified":1496992979000},{"_id":"themes/beantech/layout/layout.ejs","hash":"a5af5b99ac3456ab5da1a319455904b979b91601","modified":1496992979000},{"_id":"themes/beantech/layout/keynote.ejs","hash":"f5689862281e34dbe8402b0e72f632902e53e88b","modified":1496992979000},{"_id":"themes/beantech/layout/page.ejs","hash":"c90797e4394c5cb63c2515109480e766d04e486e","modified":1496992979000},{"_id":"themes/beantech/layout/tags.ejs","hash":"2c72eb2e89130658aa068d80d27b561b509c5dcd","modified":1496992979000},{"_id":"themes/beantech/layout/post.ejs","hash":"2d55684fc539dc281f9e2ec0409f09ea6ca43949","modified":1496992979000},{"_id":"source/img/404-bg.jpg","hash":"68f7d525269a94287e0ad18713ae232fb59dcf71","modified":1496992978000},{"_id":"themes/beantech/layout/_partial/footer.ejs","hash":"c31863b1fa66fd915bc4913440be6c610d12af80","modified":1496992979000},{"_id":"themes/beantech/layout/_partial/head.ejs","hash":"3542d15bdf73aa59f05f566b7ecd2255e83ee370","modified":1496992979000},{"_id":"themes/beantech/layout/_partial/header.ejs","hash":"aafb744601042f0270d2e6595129ac8a73ad2608","modified":1496992979000},{"_id":"themes/beantech/layout/_partial/nav.ejs","hash":"4c905166c960852e9b9a3c9d5c680091e37b481f","modified":1496992979000},{"_id":"themes/beantech/layout/_partial/pagination.ejs","hash":"557d6bb069a1d48af49ae912994653f44b32a570","modified":1496992979000},{"_id":"themes/beantech/layout/_partial/sidebar.ejs","hash":"2e4e528a555917b2a267da4db2440bcc4a7a65ab","modified":1496992979000},{"_id":"themes/beantech/layout/_partial/toc.ejs","hash":"837f01e8a20e5023b4b292d1b3141a399567da65","modified":1496992979000},{"_id":"themes/beantech/layout/_widget/category.ejs","hash":"1cf485def07dc06e870dc9613767c6c614bcf428","modified":1496992979000},{"_id":"themes/beantech/layout/_widget/archive.ejs","hash":"7594929d472806ca4c64d9906d9903a96de111a0","modified":1496992979000},{"_id":"themes/beantech/layout/_widget/featured-tags.ejs","hash":"0c9ce1942f1943dc8891a9302a922ef1ffe300c5","modified":1496992979000},{"_id":"themes/beantech/layout/_widget/friends-blog.ejs","hash":"734d3775017aedac185028924baf890a71a74548","modified":1496992979000},{"_id":"themes/beantech/layout/_widget/recent-posts.ejs","hash":"e08ab8ba60e31638006acf27f066b989a0a3c433","modified":1496992979000},{"_id":"themes/beantech/layout/_widget/short-about.ejs","hash":"3b10bd768f6ef30a42b1703fbc9a88627f9bfdf1","modified":1496992979000},{"_id":"themes/beantech/source/css/archive.styl","hash":"715bcbd085eb95ec26c9805c11c374919cde971c","modified":1496992979000},{"_id":"themes/beantech/source/css/beantech.css","hash":"4c361354fd8e9851923fb21a620bc079380ebcd8","modified":1496992979000},{"_id":"themes/beantech/source/css/beantech.min.css","hash":"05a06230b1a9eca0b30cece54a397008cb77dc50","modified":1496992979000},{"_id":"themes/beantech/source/css/highlight.styl","hash":"e842080e6d580f0f70a7df71fbde3c4e49463c19","modified":1496992979000},{"_id":"themes/beantech/source/css/hux-blog.min.css","hash":"1baef04de262aeb7023d835429b49a805ac4ab40","modified":1496992979000},{"_id":"themes/beantech/source/css/rocket.styl","hash":"e15c51c8566ecd943112e57592888dd318b6fa6a","modified":1496992979000},{"_id":"themes/beantech/source/css/signature.styl","hash":"88159b31c59d59c01a0b534af57242662a2a3969","modified":1496992979000},{"_id":"themes/beantech/source/css/widget.styl","hash":"7a9f735f5ef323dc2950fbd9d76daa16c9a0f1a9","modified":1496992979000},{"_id":"themes/beantech/source/css/toc.styl","hash":"9e959cebf9aef87ecac0ea20db7ee96ea1c26b38","modified":1496992979000},{"_id":"themes/beantech/source/fonts/glyphicons-halflings-regular.eot","hash":"86b6f62b7853e67d3e635f6512a5a5efc58ea3c3","modified":1496992979000},{"_id":"themes/beantech/source/fonts/glyphicons-halflings-regular.ttf","hash":"44bc1850f570972267b169ae18f1cb06b611ffa2","modified":1496992979000},{"_id":"themes/beantech/source/fonts/glyphicons-halflings-regular.woff","hash":"278e49a86e634da6f2a02f3b47dd9d2a8f26210f","modified":1496992979000},{"_id":"themes/beantech/source/fonts/glyphicons-halflings-regular.woff2","hash":"ca35b697d99cae4d1b60f2d60fcd37771987eb07","modified":1496992979000},{"_id":"themes/beantech/source/js/hux-blog.js","hash":"4b4d3c557405d04c3087d36c13e2834fe05c0f73","modified":1496992979000},{"_id":"themes/beantech/source/js/bootstrap.min.js","hash":"b3f2ef9f985e7906c9360756b73cd64bf7733647","modified":1496992979000},{"_id":"themes/beantech/source/js/hux-blog.min.js","hash":"1563e7f70550ac6b30803d6f449719b853200e35","modified":1496992979000},{"_id":"themes/beantech/source/js/jquery.nav.js","hash":"ef2160a456176a4d09cc0b95d52b27dfbbadf2d8","modified":1496992979000},{"_id":"themes/beantech/source/js/jquery.tagcloud.js","hash":"4e5fd0b07f3bd935f2e603710447e039e3677211","modified":1496992979000},{"_id":"themes/beantech/source/js/toc.js","hash":"41e52551731854224c249d53010c1bae5aa92ffa","modified":1496992979000},{"_id":"themes/beantech/source/js/totop.js","hash":"c05360f6fc699ac12e794b1764b4a952713a3017","modified":1496992979000},{"_id":"source/img/header_img/Iron-Man-3.jpg","hash":"62a9a76854503c327990cc8d10de293ab6e9588f","modified":1496992978000},{"_id":"source/img/ironman-draw.png","hash":"7d6a06b4b544ab146c3b3e8474edc33f14ac6e4d","modified":1496992979000},{"_id":"themes/beantech/source/css/bootstrap.min.css","hash":"fec7b176a4b9a67c0eb5d184f57b84297efc23aa","modified":1496992979000},{"_id":"themes/beantech/source/fonts/glyphicons-halflings-regular.svg","hash":"de51a8494180a6db074af2dee2383f0a363c5b08","modified":1496992979000},{"_id":"themes/beantech/source/js/bootstrap.js","hash":"f8752e9ae24daec0a0baffd7819122f8c6fd9103","modified":1496992979000},{"_id":"themes/beantech/source/js/jquery.min.js","hash":"41b4bfbaa96be6d1440db6e78004ade1c134e276","modified":1496992979000},{"_id":"source/img/contact-bg.jpg","hash":"6af63305c923899017e727b5ca968a2703bc08cf","modified":1496992978000},{"_id":"source/img/signature/BeanTechSign-white.png","hash":"34289ed41cf9ddac2d56be46fbb1515b7d5913cd","modified":1496992979000},{"_id":"themes/beantech/source/css/images/ironman.png","hash":"2f0db0ab15d466c4065d9f6102fdf829726d9e3f","modified":1496992979000},{"_id":"themes/beantech/source/css/bootstrap.css","hash":"41c54bf695145ae0b4d9020a1da308ceb05dcaf3","modified":1496992979000},{"_id":"themes/beantech/source/css/images/rocket.png","hash":"6dee0406955aa9b7a261161d30f2538a671e806b","modified":1496992979000},{"_id":"source/img/header_img/tf-logo-dark.png","hash":"5c7bf8ade9de134f8c77a3c59e575abe9fc6cdd4","modified":1496992979000},{"_id":"source/img/signature/BeanTechSign-black.png","hash":"94b7102e819fd6ee082d3fb0166f4de7458c22ff","modified":1496992979000},{"_id":"themes/beantech/source/js/jquery.js","hash":"1852661bd11a09ca9b9cb63d1aa6ff390fffaf4e","modified":1496992979000},{"_id":"source/img/beantech-desktop.png","hash":"4a8f8b209c9db8fd5209f15b8e4590525e258b0f","modified":1496992978000},{"_id":"source/img/header_img/tag-bg.png","hash":"e83cd7b04ff85bcbc9bd3ebf5e57a55166e82568","modified":1496992979000},{"_id":"source/img/header_img/home-bg-2-dark.png","hash":"da6a3d5ca787bdc25e69655abd879b4f821aeb30","modified":1496992978000},{"_id":"source/img/header_img/home-bg-o.png","hash":"134ece4cb4c49c7ca1403a5afe7f46d0e2f9ecbb","modified":1496992978000},{"_id":"source/img/header_img/archive-bg.png","hash":"6bf9c224543ec54e250309db89cbdf46e0c4b5ba","modified":1496992978000},{"_id":"public/post-sitemap.xml","hash":"765d5e2c7eb9f07968adb1dd5c99a08801005782","modified":1497083154362},{"_id":"public/page-sitemap.xml","hash":"08c6a56840ed60167e66b06a759f630e26c9ed43","modified":1497083037875},{"_id":"public/tag-sitemap.xml","hash":"f90afbe336093a4802e3eea3a971cc904cebfa7a","modified":1497083154505},{"_id":"public/sitemap.xsl","hash":"4321fa69dc1b8811d32b7a1478e5603e038cea1a","modified":1497083037971},{"_id":"public/sitemap.xml","hash":"94f481731a233bb2e870e47923a36c974bfcd856","modified":1497083154569},{"_id":"public/404.html","hash":"b1ca0f278176f4e3f67c184129feb6ebb1ceeba8","modified":1497083038029},{"_id":"public/about/index.html","hash":"7a00a9da97ace5bbd416df7ca35bdc749371515b","modified":1497083038044},{"_id":"public/archives/index.html","hash":"b81a13e890c05b5e9c49c8665a03c9fd11a502f8","modified":1497083038051},{"_id":"public/archives/2016/index.html","hash":"962cc005b518053d8c95a7571c2d87922c26094b","modified":1497083038052},{"_id":"public/archives/2016/03/index.html","hash":"e9360c6cdeb5a670e6cd15e22d1ab5f4a063e969","modified":1497083038052},{"_id":"public/tags/django/index.html","hash":"039d1b6337c5066935f6d3ea0e6c97ae6c129903","modified":1497083038053},{"_id":"public/tags/ajax/index.html","hash":"fe0083e91fd0b92d66fd9481a1758f507e8836a5","modified":1497083038053},{"_id":"public/tags/python/index.html","hash":"934aacbe6e40f5f41054d783de188a275712a45a","modified":1497083038053},{"_id":"public/tags/ios/index.html","hash":"56e80f3a2e62b008ba774d6ccf22df6ec4e5c8d0","modified":1497083038053},{"_id":"public/tags/android/index.html","hash":"3f844060dba85a2f8a987333a6eada54d0b55599","modified":1497083038053},{"_id":"public/tags/inapp/index.html","hash":"c84a20dda689020a9718ef84f675fbae66c86b41","modified":1497083038053},{"_id":"public/tags/index.html","hash":"dcdb29a1df2e8240a09420712d8983bbd3d40f2f","modified":1497083038053},{"_id":"public/2016/03/27/django-ajax/index.html","hash":"8733e9a60d4f7f6f78369330051ede8e45e0c609","modified":1497083038053},{"_id":"public/2016/03/11/store-inapp-in-python/index.html","hash":"f75d23084da8107981016103dcfa274c53f2b8f8","modified":1497083038053},{"_id":"public/archive/index.html","hash":"786cedc0f6f0f14fd0d1092bffe605c67336eca5","modified":1497083038053},{"_id":"public/index.html","hash":"773c6204733182627523d2fec280826ac16a4553","modified":1497083038054},{"_id":"public/archives/2016/05/index.html","hash":"39c75ca5c43a42f97e93ebb9058f801f300c5f24","modified":1497083038077},{"_id":"public/tags/sso/index.html","hash":"5563f4b6497a20a4f105bd228b3d1a5000cab4ff","modified":1497083038077},{"_id":"public/2016/05/06/django-sso/index.html","hash":"191bece2150efafcb9c52d376f591abc65f965fa","modified":1497083154583},{"_id":"public/CNAME","hash":"55d5b0b4757a7d65ee4966dd161f394d06d257b7","modified":1497083038085},{"_id":"public/img/icon_wechat.png","hash":"4188058026609de06c6cac88b349a2da831a1783","modified":1497083038085},{"_id":"public/fonts/glyphicons-halflings-regular.eot","hash":"86b6f62b7853e67d3e635f6512a5a5efc58ea3c3","modified":1497083038085},{"_id":"public/fonts/glyphicons-halflings-regular.ttf","hash":"44bc1850f570972267b169ae18f1cb06b611ffa2","modified":1497083038085},{"_id":"public/fonts/glyphicons-halflings-regular.woff","hash":"278e49a86e634da6f2a02f3b47dd9d2a8f26210f","modified":1497083038085},{"_id":"public/fonts/glyphicons-halflings-regular.woff2","hash":"ca35b697d99cae4d1b60f2d60fcd37771987eb07","modified":1497083038085},{"_id":"public/css/images/ironman.png","hash":"2f0db0ab15d466c4065d9f6102fdf829726d9e3f","modified":1497083038085},{"_id":"public/css/images/rocket.png","hash":"6dee0406955aa9b7a261161d30f2538a671e806b","modified":1497083038085},{"_id":"public/img/header_img/Iron-Man-3.jpg","hash":"62a9a76854503c327990cc8d10de293ab6e9588f","modified":1497083038722},{"_id":"public/fonts/glyphicons-halflings-regular.svg","hash":"de51a8494180a6db074af2dee2383f0a363c5b08","modified":1497083038724},{"_id":"public/css/archive.css","hash":"8db895ebaeff19ac145c961abcfd5d4a8d67a8ea","modified":1497083038736},{"_id":"public/css/highlight.css","hash":"8bc5e670b028eda8097f58bdc85269c5124c2951","modified":1497083038736},{"_id":"public/css/rocket.css","hash":"9456fd92f729e09d6de8cda70f95d78e0d789c70","modified":1497083038736},{"_id":"public/css/signature.css","hash":"820fa4743cea34a61808cd8f7de528605c32d7e3","modified":1497083038736},{"_id":"public/css/widget.css","hash":"da95ad3f1938f24d20f1fa77d7a38f0c392b5ec8","modified":1497083038736},{"_id":"public/css/toc.css","hash":"4a892d4d00d85f984c6aeba44a34648bb98f1861","modified":1497083038736},{"_id":"public/js/hux-blog.js","hash":"4b4d3c557405d04c3087d36c13e2834fe05c0f73","modified":1497083038736},{"_id":"public/js/hux-blog.min.js","hash":"1563e7f70550ac6b30803d6f449719b853200e35","modified":1497083038737},{"_id":"public/js/jquery.nav.js","hash":"ef2160a456176a4d09cc0b95d52b27dfbbadf2d8","modified":1497083038737},{"_id":"public/js/jquery.tagcloud.js","hash":"4e5fd0b07f3bd935f2e603710447e039e3677211","modified":1497083038737},{"_id":"public/js/toc.js","hash":"41e52551731854224c249d53010c1bae5aa92ffa","modified":1497083038737},{"_id":"public/js/totop.js","hash":"c05360f6fc699ac12e794b1764b4a952713a3017","modified":1497083038737},{"_id":"public/css/beantech.min.css","hash":"05a06230b1a9eca0b30cece54a397008cb77dc50","modified":1497083038737},{"_id":"public/css/beantech.css","hash":"4c361354fd8e9851923fb21a620bc079380ebcd8","modified":1497083038737},{"_id":"public/css/hux-blog.min.css","hash":"1baef04de262aeb7023d835429b49a805ac4ab40","modified":1497083038737},{"_id":"public/js/bootstrap.min.js","hash":"b3f2ef9f985e7906c9360756b73cd64bf7733647","modified":1497083038737},{"_id":"public/css/bootstrap.min.css","hash":"fec7b176a4b9a67c0eb5d184f57b84297efc23aa","modified":1497083038737},{"_id":"public/js/bootstrap.js","hash":"f8752e9ae24daec0a0baffd7819122f8c6fd9103","modified":1497083038737},{"_id":"public/js/jquery.min.js","hash":"41b4bfbaa96be6d1440db6e78004ade1c134e276","modified":1497083038738},{"_id":"public/css/bootstrap.css","hash":"41c54bf695145ae0b4d9020a1da308ceb05dcaf3","modified":1497083038738},{"_id":"public/js/jquery.js","hash":"1852661bd11a09ca9b9cb63d1aa6ff390fffaf4e","modified":1497083038738},{"_id":"public/img/404-bg.jpg","hash":"68f7d525269a94287e0ad18713ae232fb59dcf71","modified":1497083038738},{"_id":"public/img/signature/BeanTechSign-white.png","hash":"34289ed41cf9ddac2d56be46fbb1515b7d5913cd","modified":1497083038738},{"_id":"public/img/ironman-draw.png","hash":"7d6a06b4b544ab146c3b3e8474edc33f14ac6e4d","modified":1497083038740},{"_id":"public/img/header_img/tf-logo-dark.png","hash":"5c7bf8ade9de134f8c77a3c59e575abe9fc6cdd4","modified":1497083038741},{"_id":"public/img/signature/BeanTechSign-black.png","hash":"94b7102e819fd6ee082d3fb0166f4de7458c22ff","modified":1497083038741},{"_id":"public/img/contact-bg.jpg","hash":"6af63305c923899017e727b5ca968a2703bc08cf","modified":1497083038749},{"_id":"public/img/header_img/tag-bg.png","hash":"e83cd7b04ff85bcbc9bd3ebf5e57a55166e82568","modified":1497083038813},{"_id":"public/img/beantech-desktop.png","hash":"4a8f8b209c9db8fd5209f15b8e4590525e258b0f","modified":1497083038818},{"_id":"public/img/header_img/home-bg-o.png","hash":"134ece4cb4c49c7ca1403a5afe7f46d0e2f9ecbb","modified":1497083038834},{"_id":"public/img/header_img/home-bg-2-dark.png","hash":"da6a3d5ca787bdc25e69655abd879b4f821aeb30","modified":1497083038834},{"_id":"public/img/header_img/archive-bg.png","hash":"6bf9c224543ec54e250309db89cbdf46e0c4b5ba","modified":1497083038857}],"Category":[],"Data":[],"Page":[{"layout":"404","description":"你来到了没有知识的荒原 :(","header-img":"img/404-bg.jpg","_content":"","source":"404.md","raw":"---\nlayout: 404\ndescription: \"你来到了没有知识的荒原 :(\"\nheader-img: \"img/404-bg.jpg\"\n---\n","date":"2017-06-09T07:22:58.000Z","updated":"2017-06-09T07:22:58.000Z","path":"404.html","title":"","comments":1,"_id":"cj3r0l3gh00009fhh4zfvtdce","content":"","site":{"data":{}},"excerpt":"","more":""},{"layout":"about","title":"About","date":"2016-04-20T19:48:33.000Z","description":"Wish for the Best, Prepare for the Worst","header-img":"img/header_img/Iron-Man-3.jpg","comments":1,"_content":"\n> 光有好奇心而不去實踐，等於自願放棄成功機會\n> 別為自己畫地自限，Just Do It！！\n","source":"about/index.md","raw":"---\nlayout: \"about\"\ntitle: \"About\"\ndate: 2016-04-21 04:48:33\ndescription: \"Wish for the Best, Prepare for the Worst\"\nheader-img: \"img/header_img/Iron-Man-3.jpg\"\ncomments: true\n---\n\n> 光有好奇心而不去實踐，等於自願放棄成功機會\n> 別為自己畫地自限，Just Do It！！\n","updated":"2017-06-09T07:22:58.000Z","path":"about/index.html","_id":"cj3r0l3he00029fhhah2bpz3a","content":"<blockquote>\n<p>光有好奇心而不去實踐，等於自願放棄成功機會<br>\n別為自己畫地自限，Just Do It！！</p>\n</blockquote>\n","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p>光有好奇心而不去實踐，等於自願放棄成功機會<br>\n別為自己畫地自限，Just Do It！！</p>\n</blockquote>\n"},{"layout":"archive","title":"Archives","header-img":"img/header_img/archive-bg.png","comments":0,"date":"2017-03-20T11:49:56.000Z","description":"Hey, this is archives","_content":"","source":"archive/index.md","raw":"---\nlayout: \"archive\"\ntitle: \"Archives\"\nheader-img: \"img/header_img/archive-bg.png\"\ncomments: false\ndate: 2017-03-20 20:49:56\ndescription: \"Hey, this is archives\"\n---\n","updated":"2017-06-09T07:22:58.000Z","path":"archive/index.html","_id":"cj3r0l3hl00049fhh2txxfw4u","content":"","site":{"data":{}},"excerpt":"","more":""},{"layout":"tags","title":"Tags","description":"Hey, this is Tags.","header-img":"img/header_img/tag-bg.png","_content":"","source":"tags/index.md","raw":"---\nlayout: \"tags\"\ntitle: \"Tags\"\ndescription: \"Hey, this is Tags.\"\nheader-img: \"img/header_img/tag-bg.png\"\n---\n","date":"2017-06-09T07:22:59.000Z","updated":"2017-06-09T07:22:59.000Z","path":"tags/index.html","comments":1,"_id":"cj3r0l3ig000m9fhhyb8da25y","content":"","site":{"data":{}},"excerpt":"","more":""}],"Post":[{"title":"Django에서 ajax요청하기","catalog":true,"date":"2016-03-27T07:08:12.000Z","subtitle":null,"header-img":null,"_content":"View에서 get, post요청을 할 때 template단에서 ajax요청을 날려야할 때가 있다.\nAPIVIew, View 두개의 경우를 살펴보자.\n1.APIView ↔ ajax (post, get)\n(post의 케이스로 설명을 하였지만 get도 동일한 방식이다.)\n가장 빈번하게 사용하는 케이스이다. template 에서 버튼을 눌러 요청을 ajax로 날려 결과값을 받아와서 전체 화면을 다시 그리지 않고 필요한 부분만 갱신해줄 수 있다.\n\n- template.html\n\n~~~\n$.ajax({\n    url: \"{% url 'request:url' %}\",\n    type: 'POST',\n    data: {\n        'user_id': user_id\n    },\n    success: function (response) {\n        // TODO: do something.\n    },\n    error: function (err) {\n        console.log(err);\n    }\n});\n~~~\n\n\n\n- url.py\n\n ```\nurl(r'^request/url$', views.TestView.as_view(), name='url'),\n  ```\n\n- view.py\n\n``` \nclass TestView(APIView):\n    def post(self, request):\n        user_id = request.POST.get('user_id')\n      # do something\n       return Response()\n```\n  \n  \nView class를 상속받고 post 메소드로 받는다면 ajax 요청시 csrf 토큰이 없다고 하면서 403에러가 발생한다.\n이를 해결해주기 위해 APIView를 상속받아서 처리하면 csrf 인증을 피해갈 수 있다.  (피해간다기보단 이미 인증이 되어있는 요청이라고 판단하는 것이지만)\n이는 APIView의 as_view() 메소드를 보면 알 수 있는데\n\n- api_view.py\n\n```\ndef as_view(cls, **initkwargs):\n    \"\"\"\n    Store the original class on the view function.\n \n    This allows us to discover information about the view when we do URL\n    reverse lookups.  Used for breadcrumb generation.\n    \"\"\"\n    if isinstance(getattr(cls, 'queryset', None), models.query.QuerySet):\n        def force_evaluation():\n            raise RuntimeError(\n                'Do not evaluate the `.queryset` attribute directly, '\n                'as the result will be cached and reused between requests. '\n                'Use `.all()` or call `.get_queryset()` instead.'\n            )\n        cls.queryset._fetch_all = force_evaluation\n        cls.queryset._result_iter = force_evaluation  # Django <= 1.5\n \n    view = super(APIView, cls).as_view(**initkwargs)\n    view.cls = cls\n \n    # Note: session based authentication is explicitly CSRF validated,\n    # all other authentication is CSRF exempt.\n    return csrf_exempt(view)\n```\n\n마지막 라인에 csrf_exempt로 view를 감싸준다. 이는 해당 API요청이 csrf 인증이 되어있다고 명시해주는 것이다.\n그리고, 내부로 파고 들어가면  APIView에서 authentication_classes = api_settings.DEFAULT_AUTHENTICATION_CLASSES 로 설정이 되어있는데, restframework의 setting을 살펴보면 아래와 같이 정의가 되어있음을 알 수 있다.\n  \n- api_settings.py\n\n```\n'DEFAULT_AUTHENTICATION_CLASSES': (\n    'rest_framework.authentication.SessionAuthentication',\n    'rest_framework.authentication.BasicAuthentication'\n),\n  \n# Authentication\n'UNAUTHENTICATED_USER': 'django.contrib.auth.models.AnonymousUser',\n'UNAUTHENTICATED_TOKEN': None,\n```\n\n인증 처리를 rest_framework의 SessionAuthentication으로 하겠다는 내용과 인증 유저를 AnonymousUser 로 설정을 해준다.\n기존의 인증절차에서 default인증 객체를 검사하게 되는데, 이 때 user객체의 active를 검사할 때 이 객체가 유효하지 않으면 unauthenticated_user로 AnonymousUser객체를 생성하게 된다. 접근 허용 체크를 할 때는 APIView에 정의된 permission class로 체크를 하는데 아래와 같다.\n  \n- api_settings.py\n\n``` \n'DEFAULT_PERMISSION_CLASSES': (\n    'rest_framework.permissions.AllowAny',\n),\n```\n\nAllowAny Class는 permission요청에 대해 무조건 True를 반환해주므로, APIView의 check_permissions 메소드에서 권한 체크를 할 때 권한이 있다고 판단을 한다.\n  \n- permissions.py\n\n``` \nclass AllowAny(BasePermission):\n    \"\"\"\n    Allow any access.\n    This isn't strictly required, since you could use an empty\n    permission_classes list, but it's useful because it makes the intention\n    more explicit.\n    \"\"\"\n    def has_permission(self, request, view):\n        return True\n```\n \n즉, APIView는 기존의 django 에서 체크하고 있는 csrf 공격방어에 대한 인증을 제외하고 따로 인증절차를 진행하게되는데, 인증 유저를 익명유저로 설정하여 유저에 대한 권한검사를 하지 않고 default로 설정이 된 권한체크 클래스로 검사를 한다.\nAllowAny는 접근 허용여부를 모두 True로 반환하여 접근에 대해 유효하다고 판단하여 csrf토큰 없이 요청 수행이 가능한 것이다.\n데이터를 모두 처리하고 나서의 응답값은 Response 객체를 반환함으로서 처리한다.\n\n2.View ↔ ajax (post, get)\najax를 통해 View class에 메소드를 호출하는 경우는 많지는 않았는데, 이유는 굳이 ajax로 호출하지 않아도 할 수 있는 방법들이 있었기 때문이었다.\n하지만 종종 사용해야할 경우가 있었는데, 이를테면 내부 검색창에서 검색결과를 내부 포멧에 맞게 내용을 채워줘야 하는데 그 template가 별도의 파일로 있는 경우였다.\n  \n  \n- template.html\n\n~~~\n$(\"#searchFrom\").submit(function () {\n    var user_id = $(\"input[name=user_id]\").val();\n \n    $.ajax({\n        url: \"{% url 'user:search' %}\",\n        type: \"POST\",\n        data: {\n            \"csrfmiddlewaretoken\": \"\\{\\{ csrf_token \\}\\}\",\n            'user_id': user_id,\n        },\n        success: function (response) {\n            $('#user_list tbody').html(response);\n        },\n        error: function (err) {\n            console.log(err);\n        }\n    });\n \n    return false;\n});\n~~~\n\n{% raw %}\n위의 tempalate에서 입력받은 데이터를 통해 ajax로 호출을 한다. 이 때 호출되는 class는 View를 상속받은 class 이다. form의 submit으로 호출을 한 경우인데 form에 {% csrf_token %}이 들어가있기 때문에 post요청을 날릴 경우엔 403이 떨어진다.(get요청은 안넣어도 상관없다.)\n이런 경우를 방지하기 위해 data필드에 csrf token 을 넣어준다.\n{% endraw %}\n\n~~~\n\"csrfmiddlewaretoken\": \"{{ csrf_token }}\",\n~~~\n\n요청을 받고 데이터를 만들고 나면 TemplateResponse를 사용하여 분리되어 생성된 페이지를 반환하게 된다. \n  \n- view.py\n\n```\nclass UserSearchView(View):\n    def post(self, request):\n        user_id = request.POST.get('user_id')\n        user_list = service.search_user(user_id)\n        context = {\n            'user_list': user_list\n        }\n        return TemplateResponse(request, 'user/user_list.html', context)\n```\n\n다시 template에서는 넘어온 html덩어리를 미리 정의해둔 위치에 그대로 붙여줌으로서 화면을 다시 그리지 않고, 필요한 부분만 넣어줄 수 있다. \n(APIView등을 통해 데이터만 받아와 다시 그리는 방법도 있지만 성격이 맞지 않는다고 생각하였고, 일반 호출을 하게 되면 페이지로딩을 다시 하므로 그 방법은 피했다)\n\n\n","source":"_posts/django-ajax.md","raw":"---\ntitle: \"Django에서 ajax요청하기\"\ncatalog: true\ndate: 2016-03-27 16:08:12\nsubtitle:\nheader-img:\ntags:\n- django\n- ajax\n---\nView에서 get, post요청을 할 때 template단에서 ajax요청을 날려야할 때가 있다.\nAPIVIew, View 두개의 경우를 살펴보자.\n1.APIView ↔ ajax (post, get)\n(post의 케이스로 설명을 하였지만 get도 동일한 방식이다.)\n가장 빈번하게 사용하는 케이스이다. template 에서 버튼을 눌러 요청을 ajax로 날려 결과값을 받아와서 전체 화면을 다시 그리지 않고 필요한 부분만 갱신해줄 수 있다.\n\n- template.html\n\n~~~\n$.ajax({\n    url: \"{% url 'request:url' %}\",\n    type: 'POST',\n    data: {\n        'user_id': user_id\n    },\n    success: function (response) {\n        // TODO: do something.\n    },\n    error: function (err) {\n        console.log(err);\n    }\n});\n~~~\n\n\n\n- url.py\n\n ```\nurl(r'^request/url$', views.TestView.as_view(), name='url'),\n  ```\n\n- view.py\n\n``` \nclass TestView(APIView):\n    def post(self, request):\n        user_id = request.POST.get('user_id')\n      # do something\n       return Response()\n```\n  \n  \nView class를 상속받고 post 메소드로 받는다면 ajax 요청시 csrf 토큰이 없다고 하면서 403에러가 발생한다.\n이를 해결해주기 위해 APIView를 상속받아서 처리하면 csrf 인증을 피해갈 수 있다.  (피해간다기보단 이미 인증이 되어있는 요청이라고 판단하는 것이지만)\n이는 APIView의 as_view() 메소드를 보면 알 수 있는데\n\n- api_view.py\n\n```\ndef as_view(cls, **initkwargs):\n    \"\"\"\n    Store the original class on the view function.\n \n    This allows us to discover information about the view when we do URL\n    reverse lookups.  Used for breadcrumb generation.\n    \"\"\"\n    if isinstance(getattr(cls, 'queryset', None), models.query.QuerySet):\n        def force_evaluation():\n            raise RuntimeError(\n                'Do not evaluate the `.queryset` attribute directly, '\n                'as the result will be cached and reused between requests. '\n                'Use `.all()` or call `.get_queryset()` instead.'\n            )\n        cls.queryset._fetch_all = force_evaluation\n        cls.queryset._result_iter = force_evaluation  # Django <= 1.5\n \n    view = super(APIView, cls).as_view(**initkwargs)\n    view.cls = cls\n \n    # Note: session based authentication is explicitly CSRF validated,\n    # all other authentication is CSRF exempt.\n    return csrf_exempt(view)\n```\n\n마지막 라인에 csrf_exempt로 view를 감싸준다. 이는 해당 API요청이 csrf 인증이 되어있다고 명시해주는 것이다.\n그리고, 내부로 파고 들어가면  APIView에서 authentication_classes = api_settings.DEFAULT_AUTHENTICATION_CLASSES 로 설정이 되어있는데, restframework의 setting을 살펴보면 아래와 같이 정의가 되어있음을 알 수 있다.\n  \n- api_settings.py\n\n```\n'DEFAULT_AUTHENTICATION_CLASSES': (\n    'rest_framework.authentication.SessionAuthentication',\n    'rest_framework.authentication.BasicAuthentication'\n),\n  \n# Authentication\n'UNAUTHENTICATED_USER': 'django.contrib.auth.models.AnonymousUser',\n'UNAUTHENTICATED_TOKEN': None,\n```\n\n인증 처리를 rest_framework의 SessionAuthentication으로 하겠다는 내용과 인증 유저를 AnonymousUser 로 설정을 해준다.\n기존의 인증절차에서 default인증 객체를 검사하게 되는데, 이 때 user객체의 active를 검사할 때 이 객체가 유효하지 않으면 unauthenticated_user로 AnonymousUser객체를 생성하게 된다. 접근 허용 체크를 할 때는 APIView에 정의된 permission class로 체크를 하는데 아래와 같다.\n  \n- api_settings.py\n\n``` \n'DEFAULT_PERMISSION_CLASSES': (\n    'rest_framework.permissions.AllowAny',\n),\n```\n\nAllowAny Class는 permission요청에 대해 무조건 True를 반환해주므로, APIView의 check_permissions 메소드에서 권한 체크를 할 때 권한이 있다고 판단을 한다.\n  \n- permissions.py\n\n``` \nclass AllowAny(BasePermission):\n    \"\"\"\n    Allow any access.\n    This isn't strictly required, since you could use an empty\n    permission_classes list, but it's useful because it makes the intention\n    more explicit.\n    \"\"\"\n    def has_permission(self, request, view):\n        return True\n```\n \n즉, APIView는 기존의 django 에서 체크하고 있는 csrf 공격방어에 대한 인증을 제외하고 따로 인증절차를 진행하게되는데, 인증 유저를 익명유저로 설정하여 유저에 대한 권한검사를 하지 않고 default로 설정이 된 권한체크 클래스로 검사를 한다.\nAllowAny는 접근 허용여부를 모두 True로 반환하여 접근에 대해 유효하다고 판단하여 csrf토큰 없이 요청 수행이 가능한 것이다.\n데이터를 모두 처리하고 나서의 응답값은 Response 객체를 반환함으로서 처리한다.\n\n2.View ↔ ajax (post, get)\najax를 통해 View class에 메소드를 호출하는 경우는 많지는 않았는데, 이유는 굳이 ajax로 호출하지 않아도 할 수 있는 방법들이 있었기 때문이었다.\n하지만 종종 사용해야할 경우가 있었는데, 이를테면 내부 검색창에서 검색결과를 내부 포멧에 맞게 내용을 채워줘야 하는데 그 template가 별도의 파일로 있는 경우였다.\n  \n  \n- template.html\n\n~~~\n$(\"#searchFrom\").submit(function () {\n    var user_id = $(\"input[name=user_id]\").val();\n \n    $.ajax({\n        url: \"{% url 'user:search' %}\",\n        type: \"POST\",\n        data: {\n            \"csrfmiddlewaretoken\": \"\\{\\{ csrf_token \\}\\}\",\n            'user_id': user_id,\n        },\n        success: function (response) {\n            $('#user_list tbody').html(response);\n        },\n        error: function (err) {\n            console.log(err);\n        }\n    });\n \n    return false;\n});\n~~~\n\n{% raw %}\n위의 tempalate에서 입력받은 데이터를 통해 ajax로 호출을 한다. 이 때 호출되는 class는 View를 상속받은 class 이다. form의 submit으로 호출을 한 경우인데 form에 {% csrf_token %}이 들어가있기 때문에 post요청을 날릴 경우엔 403이 떨어진다.(get요청은 안넣어도 상관없다.)\n이런 경우를 방지하기 위해 data필드에 csrf token 을 넣어준다.\n{% endraw %}\n\n~~~\n\"csrfmiddlewaretoken\": \"{{ csrf_token }}\",\n~~~\n\n요청을 받고 데이터를 만들고 나면 TemplateResponse를 사용하여 분리되어 생성된 페이지를 반환하게 된다. \n  \n- view.py\n\n```\nclass UserSearchView(View):\n    def post(self, request):\n        user_id = request.POST.get('user_id')\n        user_list = service.search_user(user_id)\n        context = {\n            'user_list': user_list\n        }\n        return TemplateResponse(request, 'user/user_list.html', context)\n```\n\n다시 template에서는 넘어온 html덩어리를 미리 정의해둔 위치에 그대로 붙여줌으로서 화면을 다시 그리지 않고, 필요한 부분만 넣어줄 수 있다. \n(APIView등을 통해 데이터만 받아와 다시 그리는 방법도 있지만 성격이 맞지 않는다고 생각하였고, 일반 호출을 하게 되면 페이지로딩을 다시 하므로 그 방법은 피했다)\n\n\n","slug":"django-ajax","published":1,"updated":"2017-06-10T07:56:21.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj3r0l3h900019fhhq4vnfsz3","content":"<p>View에서 get, post요청을 할 때 template단에서 ajax요청을 날려야할 때가 있다.<br>\nAPIVIew, View 두개의 경우를 살펴보자.<br>\n1.APIView ↔ ajax (post, get)<br>\n(post의 케이스로 설명을 하였지만 get도 동일한 방식이다.)<br>\n가장 빈번하게 사용하는 케이스이다. template 에서 버튼을 눌러 요청을 ajax로 날려 결과값을 받아와서 전체 화면을 다시 그리지 않고 필요한 부분만 갱신해줄 수 있다.</p>\n<ul>\n<li>template.html</li>\n</ul>\n<figure class=\"highlight lua\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\">$.ajax(&#123;</div><div class=\"line\">    url: <span class=\"string\">\"&#123;% url 'request:url' %&#125;\"</span>,</div><div class=\"line\">    <span class=\"built_in\">type</span>: <span class=\"string\">'POST'</span>,</div><div class=\"line\">    data: &#123;</div><div class=\"line\">        <span class=\"string\">'user_id'</span>: user_id</div><div class=\"line\">    &#125;,</div><div class=\"line\">    success: <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"params\">(response)</span></span> &#123;</div><div class=\"line\">        // TODO: <span class=\"keyword\">do</span> something.</div><div class=\"line\">    &#125;,</div><div class=\"line\">    <span class=\"built_in\">error</span>: <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"params\">(err)</span></span> &#123;</div><div class=\"line\">        console.<span class=\"built_in\">log</span>(err);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>\n<ul>\n<li><a href=\"http://url.py\" target=\"_blank\" rel=\"external\">url.py</a></li>\n</ul>\n <figure class=\"highlight awk\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">url(<span class=\"string\">r'^request/url$'</span>, views.TestView.as_view(), name=<span class=\"string\">'url'</span>),</div></pre></td></tr></table></figure>\n<ul>\n<li><a href=\"http://view.py\" target=\"_blank\" rel=\"external\">view.py</a></li>\n</ul>\n<figure class=\"highlight ruby\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">TestView</span>(<span class=\"title\">APIView</span>):</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">post</span><span class=\"params\">(<span class=\"keyword\">self</span>, request)</span></span>:</div><div class=\"line\">        user_id = request.POST.get(<span class=\"string\">'user_id'</span>)</div><div class=\"line\">      <span class=\"comment\"># do something</span></div><div class=\"line\">       <span class=\"keyword\">return</span> Response()</div></pre></td></tr></table></figure>\n<p>View class를 상속받고 post 메소드로 받는다면 ajax 요청시 csrf 토큰이 없다고 하면서 403에러가 발생한다.<br>\n이를 해결해주기 위해 APIView를 상속받아서 처리하면 csrf 인증을 피해갈 수 있다.  (피해간다기보단 이미 인증이 되어있는 요청이라고 판단하는 것이지만)<br>\n이는 APIView의 as_view() 메소드를 보면 알 수 있는데</p>\n<ul>\n<li>api_view.py</li>\n</ul>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">as_view</span><span class=\"params\">(cls, **initkwargs)</span>:</span></div><div class=\"line\">    <span class=\"string\">\"\"\"</span></div><div class=\"line\">    Store the original class on the view function.</div><div class=\"line\"> </div><div class=\"line\">    This allows us to discover information about the view when we do URL</div><div class=\"line\">    reverse lookups.  Used for breadcrumb generation.</div><div class=\"line\">    \"\"\"</div><div class=\"line\">    <span class=\"keyword\">if</span> isinstance(getattr(cls, <span class=\"string\">'queryset'</span>, <span class=\"keyword\">None</span>), models.query.QuerySet):</div><div class=\"line\">        <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">force_evaluation</span><span class=\"params\">()</span>:</span></div><div class=\"line\">            <span class=\"keyword\">raise</span> RuntimeError(</div><div class=\"line\">                <span class=\"string\">'Do not evaluate the `.queryset` attribute directly, '</span></div><div class=\"line\">                <span class=\"string\">'as the result will be cached and reused between requests. '</span></div><div class=\"line\">                <span class=\"string\">'Use `.all()` or call `.get_queryset()` instead.'</span></div><div class=\"line\">            )</div><div class=\"line\">        cls.queryset._fetch_all = force_evaluation</div><div class=\"line\">        cls.queryset._result_iter = force_evaluation  <span class=\"comment\"># Django &lt;= 1.5</span></div><div class=\"line\"> </div><div class=\"line\">    view = super(APIView, cls).as_view(**initkwargs)</div><div class=\"line\">    view.cls = cls</div><div class=\"line\"> </div><div class=\"line\">    <span class=\"comment\"># <span class=\"doctag\">Note:</span> session based authentication is explicitly CSRF validated,</span></div><div class=\"line\">    <span class=\"comment\"># all other authentication is CSRF exempt.</span></div><div class=\"line\">    <span class=\"keyword\">return</span> csrf_exempt(view)</div></pre></td></tr></table></figure>\n<p>마지막 라인에 csrf_exempt로 view를 감싸준다. 이는 해당 API요청이 csrf 인증이 되어있다고 명시해주는 것이다.<br>\n그리고, 내부로 파고 들어가면  APIView에서 authentication_classes = api_settings.DEFAULT_AUTHENTICATION_CLASSES 로 설정이 되어있는데, restframework의 setting을 살펴보면 아래와 같이 정의가 되어있음을 알 수 있다.</p>\n<ul>\n<li>api_settings.py</li>\n</ul>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"string\">'DEFAULT_AUTHENTICATION_CLASSES'</span>: (</div><div class=\"line\">    <span class=\"string\">'rest_framework.authentication.SessionAuthentication'</span>,</div><div class=\"line\">    <span class=\"string\">'rest_framework.authentication.BasicAuthentication'</span></div><div class=\"line\">),</div><div class=\"line\">  </div><div class=\"line\"><span class=\"comment\"># Authentication</span></div><div class=\"line\"><span class=\"string\">'UNAUTHENTICATED_USER'</span>: <span class=\"string\">'django.contrib.auth.models.AnonymousUser'</span>,</div><div class=\"line\"><span class=\"string\">'UNAUTHENTICATED_TOKEN'</span>: <span class=\"keyword\">None</span>,</div></pre></td></tr></table></figure>\n<p>인증 처리를 rest_framework의 SessionAuthentication으로 하겠다는 내용과 인증 유저를 AnonymousUser 로 설정을 해준다.<br>\n기존의 인증절차에서 default인증 객체를 검사하게 되는데, 이 때 user객체의 active를 검사할 때 이 객체가 유효하지 않으면 unauthenticated_user로 AnonymousUser객체를 생성하게 된다. 접근 허용 체크를 할 때는 APIView에 정의된 permission class로 체크를 하는데 아래와 같다.</p>\n<ul>\n<li>api_settings.py</li>\n</ul>\n<figure class=\"highlight 1c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">'DEFAULT_PERMISSION_CLASSES': (</div><div class=\"line\">    'rest_framework.permissions.AllowAny',</div><div class=\"line\">),</div></pre></td></tr></table></figure>\n<p>AllowAny Class는 permission요청에 대해 무조건 True를 반환해주므로, APIView의 check_permissions 메소드에서 권한 체크를 할 때 권한이 있다고 판단을 한다.</p>\n<ul>\n<li><a href=\"http://permissions.py\" target=\"_blank\" rel=\"external\">permissions.py</a></li>\n</ul>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">AllowAny</span><span class=\"params\">(BasePermission)</span>:</span></div><div class=\"line\">    <span class=\"string\">\"\"\"</span></div><div class=\"line\">    Allow any access.</div><div class=\"line\">    This isn't strictly required, since you could use an empty</div><div class=\"line\">    permission_classes list, but it's useful because it makes the intention</div><div class=\"line\">    more explicit.</div><div class=\"line\">    \"\"\"</div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">has_permission</span><span class=\"params\">(self, request, view)</span>:</span></div><div class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">True</span></div></pre></td></tr></table></figure>\n<p>즉, APIView는 기존의 django 에서 체크하고 있는 csrf 공격방어에 대한 인증을 제외하고 따로 인증절차를 진행하게되는데, 인증 유저를 익명유저로 설정하여 유저에 대한 권한검사를 하지 않고 default로 설정이 된 권한체크 클래스로 검사를 한다.<br>\nAllowAny는 접근 허용여부를 모두 True로 반환하여 접근에 대해 유효하다고 판단하여 csrf토큰 없이 요청 수행이 가능한 것이다.<br>\n데이터를 모두 처리하고 나서의 응답값은 Response 객체를 반환함으로서 처리한다.</p>\n<p>2.View ↔ ajax (post, get)<br>\najax를 통해 View class에 메소드를 호출하는 경우는 많지는 않았는데, 이유는 굳이 ajax로 호출하지 않아도 할 수 있는 방법들이 있었기 때문이었다.<br>\n하지만 종종 사용해야할 경우가 있었는데, 이를테면 내부 검색창에서 검색결과를 내부 포멧에 맞게 내용을 채워줘야 하는데 그 template가 별도의 파일로 있는 경우였다.</p>\n<ul>\n<li>template.html</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div></pre></td><td class=\"code\"><pre><div class=\"line\">$(<span class=\"string\">\"#searchFrom\"</span>).submit(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">var</span> user_id = $(<span class=\"string\">\"input[name=user_id]\"</span>).val();</div><div class=\"line\"> </div><div class=\"line\">    $.ajax(&#123;</div><div class=\"line\">        <span class=\"attr\">url</span>: <span class=\"string\">\"&#123;% url 'user:search' %&#125;\"</span>,</div><div class=\"line\">        <span class=\"attr\">type</span>: <span class=\"string\">\"POST\"</span>,</div><div class=\"line\">        <span class=\"attr\">data</span>: &#123;</div><div class=\"line\">            <span class=\"string\">\"csrfmiddlewaretoken\"</span>: <span class=\"string\">\"\\&#123;\\&#123; csrf_token \\&#125;\\&#125;\"</span>,</div><div class=\"line\">            <span class=\"string\">'user_id'</span>: user_id,</div><div class=\"line\">        &#125;,</div><div class=\"line\">        <span class=\"attr\">success</span>: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">response</span>) </span>&#123;</div><div class=\"line\">            $(<span class=\"string\">'#user_list tbody'</span>).html(response);</div><div class=\"line\">        &#125;,</div><div class=\"line\">        <span class=\"attr\">error</span>: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">err</span>) </span>&#123;</div><div class=\"line\">            <span class=\"built_in\">console</span>.log(err);</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;);</div><div class=\"line\"> </div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>\n\n위의 tempalate에서 입력받은 데이터를 통해 ajax로 호출을 한다. 이 때 호출되는 class는 View를 상속받은 class 이다. form의 submit으로 호출을 한 경우인데 form에 {% csrf_token %}이 들어가있기 때문에 post요청을 날릴 경우엔 403이 떨어진다.(get요청은 안넣어도 상관없다.)\n이런 경우를 방지하기 위해 data필드에 csrf token 을 넣어준다.\n\n<figure class=\"highlight 1c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"string\">\"csrfmiddlewaretoken\"</span>: <span class=\"string\">\"&#123;&#123; csrf_token &#125;&#125;\"</span>,</div></pre></td></tr></table></figure>\n<p>요청을 받고 데이터를 만들고 나면 TemplateResponse를 사용하여 분리되어 생성된 페이지를 반환하게 된다.</p>\n<ul>\n<li><a href=\"http://view.py\" target=\"_blank\" rel=\"external\">view.py</a></li>\n</ul>\n<figure class=\"highlight ruby\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">UserSearchView</span>(<span class=\"title\">View</span>):</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">post</span><span class=\"params\">(<span class=\"keyword\">self</span>, request)</span></span>:</div><div class=\"line\">        user_id = request.POST.get(<span class=\"string\">'user_id'</span>)</div><div class=\"line\">        user_list = service.search_user(user_id)</div><div class=\"line\">        context = &#123;</div><div class=\"line\">            <span class=\"string\">'user_list'</span>: user_list</div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"keyword\">return</span> TemplateResponse(request, <span class=\"string\">'user/user_list.html'</span>, context)</div></pre></td></tr></table></figure>\n<p>다시 template에서는 넘어온 html덩어리를 미리 정의해둔 위치에 그대로 붙여줌으로서 화면을 다시 그리지 않고, 필요한 부분만 넣어줄 수 있다.<br>\n(APIView등을 통해 데이터만 받아와 다시 그리는 방법도 있지만 성격이 맞지 않는다고 생각하였고, 일반 호출을 하게 되면 페이지로딩을 다시 하므로 그 방법은 피했다)</p>\n","site":{"data":{}},"excerpt":"","more":"<p>View에서 get, post요청을 할 때 template단에서 ajax요청을 날려야할 때가 있다.<br>\nAPIVIew, View 두개의 경우를 살펴보자.<br>\n1.APIView ↔ ajax (post, get)<br>\n(post의 케이스로 설명을 하였지만 get도 동일한 방식이다.)<br>\n가장 빈번하게 사용하는 케이스이다. template 에서 버튼을 눌러 요청을 ajax로 날려 결과값을 받아와서 전체 화면을 다시 그리지 않고 필요한 부분만 갱신해줄 수 있다.</p>\n<ul>\n<li>template.html</li>\n</ul>\n<figure class=\"highlight lua\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\">$.ajax(&#123;</div><div class=\"line\">    url: <span class=\"string\">\"&#123;% url 'request:url' %&#125;\"</span>,</div><div class=\"line\">    <span class=\"built_in\">type</span>: <span class=\"string\">'POST'</span>,</div><div class=\"line\">    data: &#123;</div><div class=\"line\">        <span class=\"string\">'user_id'</span>: user_id</div><div class=\"line\">    &#125;,</div><div class=\"line\">    success: <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"params\">(response)</span></span> &#123;</div><div class=\"line\">        // TODO: <span class=\"keyword\">do</span> something.</div><div class=\"line\">    &#125;,</div><div class=\"line\">    <span class=\"built_in\">error</span>: <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"params\">(err)</span></span> &#123;</div><div class=\"line\">        console.<span class=\"built_in\">log</span>(err);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>\n<ul>\n<li><a href=\"http://url.py\" target=\"_blank\" rel=\"external\">url.py</a></li>\n</ul>\n <figure class=\"highlight awk\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">url(<span class=\"string\">r'^request/url$'</span>, views.TestView.as_view(), name=<span class=\"string\">'url'</span>),</div></pre></td></tr></table></figure>\n<ul>\n<li><a href=\"http://view.py\" target=\"_blank\" rel=\"external\">view.py</a></li>\n</ul>\n<figure class=\"highlight ruby\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">TestView</span>(<span class=\"title\">APIView</span>):</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">post</span><span class=\"params\">(<span class=\"keyword\">self</span>, request)</span></span>:</div><div class=\"line\">        user_id = request.POST.get(<span class=\"string\">'user_id'</span>)</div><div class=\"line\">      <span class=\"comment\"># do something</span></div><div class=\"line\">       <span class=\"keyword\">return</span> Response()</div></pre></td></tr></table></figure>\n<p>View class를 상속받고 post 메소드로 받는다면 ajax 요청시 csrf 토큰이 없다고 하면서 403에러가 발생한다.<br>\n이를 해결해주기 위해 APIView를 상속받아서 처리하면 csrf 인증을 피해갈 수 있다.  (피해간다기보단 이미 인증이 되어있는 요청이라고 판단하는 것이지만)<br>\n이는 APIView의 as_view() 메소드를 보면 알 수 있는데</p>\n<ul>\n<li>api_view.py</li>\n</ul>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">as_view</span><span class=\"params\">(cls, **initkwargs)</span>:</span></div><div class=\"line\">    <span class=\"string\">\"\"\"</span></div><div class=\"line\">    Store the original class on the view function.</div><div class=\"line\"> </div><div class=\"line\">    This allows us to discover information about the view when we do URL</div><div class=\"line\">    reverse lookups.  Used for breadcrumb generation.</div><div class=\"line\">    \"\"\"</div><div class=\"line\">    <span class=\"keyword\">if</span> isinstance(getattr(cls, <span class=\"string\">'queryset'</span>, <span class=\"keyword\">None</span>), models.query.QuerySet):</div><div class=\"line\">        <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">force_evaluation</span><span class=\"params\">()</span>:</span></div><div class=\"line\">            <span class=\"keyword\">raise</span> RuntimeError(</div><div class=\"line\">                <span class=\"string\">'Do not evaluate the `.queryset` attribute directly, '</span></div><div class=\"line\">                <span class=\"string\">'as the result will be cached and reused between requests. '</span></div><div class=\"line\">                <span class=\"string\">'Use `.all()` or call `.get_queryset()` instead.'</span></div><div class=\"line\">            )</div><div class=\"line\">        cls.queryset._fetch_all = force_evaluation</div><div class=\"line\">        cls.queryset._result_iter = force_evaluation  <span class=\"comment\"># Django &lt;= 1.5</span></div><div class=\"line\"> </div><div class=\"line\">    view = super(APIView, cls).as_view(**initkwargs)</div><div class=\"line\">    view.cls = cls</div><div class=\"line\"> </div><div class=\"line\">    <span class=\"comment\"># <span class=\"doctag\">Note:</span> session based authentication is explicitly CSRF validated,</span></div><div class=\"line\">    <span class=\"comment\"># all other authentication is CSRF exempt.</span></div><div class=\"line\">    <span class=\"keyword\">return</span> csrf_exempt(view)</div></pre></td></tr></table></figure>\n<p>마지막 라인에 csrf_exempt로 view를 감싸준다. 이는 해당 API요청이 csrf 인증이 되어있다고 명시해주는 것이다.<br>\n그리고, 내부로 파고 들어가면  APIView에서 authentication_classes = api_settings.DEFAULT_AUTHENTICATION_CLASSES 로 설정이 되어있는데, restframework의 setting을 살펴보면 아래와 같이 정의가 되어있음을 알 수 있다.</p>\n<ul>\n<li>api_settings.py</li>\n</ul>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"string\">'DEFAULT_AUTHENTICATION_CLASSES'</span>: (</div><div class=\"line\">    <span class=\"string\">'rest_framework.authentication.SessionAuthentication'</span>,</div><div class=\"line\">    <span class=\"string\">'rest_framework.authentication.BasicAuthentication'</span></div><div class=\"line\">),</div><div class=\"line\">  </div><div class=\"line\"><span class=\"comment\"># Authentication</span></div><div class=\"line\"><span class=\"string\">'UNAUTHENTICATED_USER'</span>: <span class=\"string\">'django.contrib.auth.models.AnonymousUser'</span>,</div><div class=\"line\"><span class=\"string\">'UNAUTHENTICATED_TOKEN'</span>: <span class=\"keyword\">None</span>,</div></pre></td></tr></table></figure>\n<p>인증 처리를 rest_framework의 SessionAuthentication으로 하겠다는 내용과 인증 유저를 AnonymousUser 로 설정을 해준다.<br>\n기존의 인증절차에서 default인증 객체를 검사하게 되는데, 이 때 user객체의 active를 검사할 때 이 객체가 유효하지 않으면 unauthenticated_user로 AnonymousUser객체를 생성하게 된다. 접근 허용 체크를 할 때는 APIView에 정의된 permission class로 체크를 하는데 아래와 같다.</p>\n<ul>\n<li>api_settings.py</li>\n</ul>\n<figure class=\"highlight 1c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">'DEFAULT_PERMISSION_CLASSES': (</div><div class=\"line\">    'rest_framework.permissions.AllowAny',</div><div class=\"line\">),</div></pre></td></tr></table></figure>\n<p>AllowAny Class는 permission요청에 대해 무조건 True를 반환해주므로, APIView의 check_permissions 메소드에서 권한 체크를 할 때 권한이 있다고 판단을 한다.</p>\n<ul>\n<li><a href=\"http://permissions.py\" target=\"_blank\" rel=\"external\">permissions.py</a></li>\n</ul>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">AllowAny</span><span class=\"params\">(BasePermission)</span>:</span></div><div class=\"line\">    <span class=\"string\">\"\"\"</span></div><div class=\"line\">    Allow any access.</div><div class=\"line\">    This isn't strictly required, since you could use an empty</div><div class=\"line\">    permission_classes list, but it's useful because it makes the intention</div><div class=\"line\">    more explicit.</div><div class=\"line\">    \"\"\"</div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">has_permission</span><span class=\"params\">(self, request, view)</span>:</span></div><div class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">True</span></div></pre></td></tr></table></figure>\n<p>즉, APIView는 기존의 django 에서 체크하고 있는 csrf 공격방어에 대한 인증을 제외하고 따로 인증절차를 진행하게되는데, 인증 유저를 익명유저로 설정하여 유저에 대한 권한검사를 하지 않고 default로 설정이 된 권한체크 클래스로 검사를 한다.<br>\nAllowAny는 접근 허용여부를 모두 True로 반환하여 접근에 대해 유효하다고 판단하여 csrf토큰 없이 요청 수행이 가능한 것이다.<br>\n데이터를 모두 처리하고 나서의 응답값은 Response 객체를 반환함으로서 처리한다.</p>\n<p>2.View ↔ ajax (post, get)<br>\najax를 통해 View class에 메소드를 호출하는 경우는 많지는 않았는데, 이유는 굳이 ajax로 호출하지 않아도 할 수 있는 방법들이 있었기 때문이었다.<br>\n하지만 종종 사용해야할 경우가 있었는데, 이를테면 내부 검색창에서 검색결과를 내부 포멧에 맞게 내용을 채워줘야 하는데 그 template가 별도의 파일로 있는 경우였다.</p>\n<ul>\n<li>template.html</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div></pre></td><td class=\"code\"><pre><div class=\"line\">$(<span class=\"string\">\"#searchFrom\"</span>).submit(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">var</span> user_id = $(<span class=\"string\">\"input[name=user_id]\"</span>).val();</div><div class=\"line\"> </div><div class=\"line\">    $.ajax(&#123;</div><div class=\"line\">        <span class=\"attr\">url</span>: <span class=\"string\">\"&#123;% url 'user:search' %&#125;\"</span>,</div><div class=\"line\">        <span class=\"attr\">type</span>: <span class=\"string\">\"POST\"</span>,</div><div class=\"line\">        <span class=\"attr\">data</span>: &#123;</div><div class=\"line\">            <span class=\"string\">\"csrfmiddlewaretoken\"</span>: <span class=\"string\">\"\\&#123;\\&#123; csrf_token \\&#125;\\&#125;\"</span>,</div><div class=\"line\">            <span class=\"string\">'user_id'</span>: user_id,</div><div class=\"line\">        &#125;,</div><div class=\"line\">        <span class=\"attr\">success</span>: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">response</span>) </span>&#123;</div><div class=\"line\">            $(<span class=\"string\">'#user_list tbody'</span>).html(response);</div><div class=\"line\">        &#125;,</div><div class=\"line\">        <span class=\"attr\">error</span>: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">err</span>) </span>&#123;</div><div class=\"line\">            <span class=\"built_in\">console</span>.log(err);</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;);</div><div class=\"line\"> </div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>\n\n위의 tempalate에서 입력받은 데이터를 통해 ajax로 호출을 한다. 이 때 호출되는 class는 View를 상속받은 class 이다. form의 submit으로 호출을 한 경우인데 form에 {% csrf_token %}이 들어가있기 때문에 post요청을 날릴 경우엔 403이 떨어진다.(get요청은 안넣어도 상관없다.)\n이런 경우를 방지하기 위해 data필드에 csrf token 을 넣어준다.\n\n<figure class=\"highlight 1c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"string\">\"csrfmiddlewaretoken\"</span>: <span class=\"string\">\"&#123;&#123; csrf_token &#125;&#125;\"</span>,</div></pre></td></tr></table></figure>\n<p>요청을 받고 데이터를 만들고 나면 TemplateResponse를 사용하여 분리되어 생성된 페이지를 반환하게 된다.</p>\n<ul>\n<li><a href=\"http://view.py\" target=\"_blank\" rel=\"external\">view.py</a></li>\n</ul>\n<figure class=\"highlight ruby\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">UserSearchView</span>(<span class=\"title\">View</span>):</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">post</span><span class=\"params\">(<span class=\"keyword\">self</span>, request)</span></span>:</div><div class=\"line\">        user_id = request.POST.get(<span class=\"string\">'user_id'</span>)</div><div class=\"line\">        user_list = service.search_user(user_id)</div><div class=\"line\">        context = &#123;</div><div class=\"line\">            <span class=\"string\">'user_list'</span>: user_list</div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"keyword\">return</span> TemplateResponse(request, <span class=\"string\">'user/user_list.html'</span>, context)</div></pre></td></tr></table></figure>\n<p>다시 template에서는 넘어온 html덩어리를 미리 정의해둔 위치에 그대로 붙여줌으로서 화면을 다시 그리지 않고, 필요한 부분만 넣어줄 수 있다.<br>\n(APIView등을 통해 데이터만 받아와 다시 그리는 방법도 있지만 성격이 맞지 않는다고 생각하였고, 일반 호출을 하게 되면 페이지로딩을 다시 하므로 그 방법은 피했다)</p>\n"},{"title":"Django에서 SSO하기","catalog":true,"date":"2016-05-06T07:59:58.000Z","subtitle":null,"header-img":null,"_content":"\n회사에서 필요에 의해 [Single Sign On](https://ko.wikipedia.org/wiki/%ED%86%B5%ED%95%A9_%EC%9D%B8%EC%A6%9D, \"Single Sign On\")을 구현해야 할 일이 있었다. 3개의 독립된 사이트가 있었고, 각자 로그인을 따로 해야 한다는 점이 사용자 입장에서는 번거로운 일이 될 수 있다는 이유에서 였다. \n\n 3개의 사이트는 하나의 유저테이블을 바라보고 있었기 때문에 충분히 합당한 이유였다. 하지만 django에서 제공하는 기본 유저 테이블을 사용하지 않기 때문에 찾아봤었던 다른 인증 툴들은 그대로 사용하기 까다로워 보였다. 내가 구현해야 하는 상황에는 몇가지 제약사항이 있었다.  \n  \n1. 로그인을 시도할 때 기존에 제공되는 auth_user 테이블이 아닌 <U>별도의 user 테이블을 사용하고 있다.</U>\n  \n2. 기존에 제공되는 user 모델을 사용하지 않기 때문에 <U>reatframework 에서 기존에 제공하는 인증방식을 그대로 사용할 수 없었다.</U>\n  \n3. 이미 테이블이 존재하고 <U>django 프로젝트에서 migration 을 할 수 없는 상황이다.</U> 기존에 생성되어 있는 테이블들의 구성을 변경할 수는 있지만 그 과정과 절차가 까다롭고 (회사의 사정에 의해), 외래키를 사용하지 않았기 때문에 모델과 테이블간의 100% 싱크가 맞지 않는 상황이었다.\n  \n4. 위와 같은 이유로 찾아봤었던 [MamaCAS](https://github.com/jbittel/django-mama-cas, \"MamaCas\") 같은 외부 인증툴을 사용할 수 없었다. (migration을 할 수 없었기에 인증을 위해 별도의 테이블을 생성하기 까다로운 상황이었다.)\n  \n3개의 프로젝트들이 출시가 얼마 남지 않은 상황이고, 인증을 위해서 별도의 커다란 작업이 있는 것은 별로 좋은 선택이 아니였다. 물론 외부의 다른 툴들을 이용할 수도 있었지만, 단순 인증을 위해 외부툴을 사용하기엔 부담스러운 부분이 있었고, 볼륨을 크게 잡고 싶지 않았다. \n  \n여러 방법을 찾아보면서 몇가지 아이디어가 나왔었다.\n  \n1. [redis](https://redis.io/, \"redis\") 를 이용해서 인증 정보를 저장하는 방식\n  \n2. [jwt](https://jwt.io/, \"jwt\")를 이용해서 javascript 내부에서 localStorage 에 인증 정보를 저장하는 방식\n  \n3. cookie에 저장하는 방식\n  \n나는 일단 1번의 redis는 제외하기로 했다. 이미 각각의 프로젝트에서 redis를 사용하고 있었고, 인증을 위해 별도의 redis를 띄우는게 번거롭다고 생각했다. 그리고 2번의 localStorage 방식은 javascript에서 ajax통신을 각 페이지별로 날려 유효한 인증을 판단하는 방식이었는데, django 단에서 각 request마다 헤더에 인증 정보를 넣기가 까다로웠다. (하지만 jwt로 토큰을 암호화 하는건 괜찮은 방법이라 생각했다.) 3번의 cookie 방식은 별도의 작업 없이 구현이 가능했지만 3개의 사이트가 같은 메인 도메인 하에 있어야 가능했었다. 어차피 모든 사이트가 회사 내부에서 사용할 목적으로 만들어 지고 있는 프로젝트 였고 같은 메인 도메인만 사용하면 되었기 때문에 나는 3번째의 방법을 사용하기로 했다. \n  \n서론이 길었지만.. 그리하여 jwt와 cookie를 이용해서 sso를 구현해 보기로 했다.\n  \n여러 사이트가 있고 각각 로그인(유저 인증)이 필요하고 기능 마다 해당 유저가 접근할 수 있는(허가) 기능이 필요하다. \n  \n(single sign on 을 하다보니 authentication 과 permission 처리가 필요했다..)\n  \n여러 개의 사이트가 공유하는 유저 정보가 있고, 이 정보로 로그인을 하기 때문에 모든 사이트에서 한번의 로그인을 하면 되는 기능이 필요했다.추가적으로 각 사이트 별로는 각자의 허가 정보가 있으므로 이 정보는 공유하지 않고 각자 구현한다. (템플릿만 제공)\n  \n한마디로 요약하면 쿠키에 암호화된 토큰 정보를 도메인이 같은 사이트들끼리 로그인 정보를 공유를 해서 사용하는 방법이다. \n  \n## 예상 시나리오\n  \nalpha.mysite.com, beta.mysite.com, charlie.mysite.com 3개의 사이트가 있다.  \nbeta 에서 로그인을 하고 charlie 사이트에 접속할 경우 이미 로그인이 되어 있다.  \n3개의 사이트는 각자 permission 이 따로 존재한다.  \nalpha 에서 로그아웃을 할 경우, 나머지 사이트에서도 모두 로그아웃이 된다.  \n로그인 정보가 만료되었을 경우에도 로그아웃 처리된다.  \n  \n## 시나리오 순서 별 설명\n\n1. 로그인 시 : <U>jwt token</U> 을 발급해서 request cookie에 저장한다. (이 때, <U>cookie</U> 의 domain은 main domain 값을 넣어준다.<mysite.com>)  \n2. 인증이 필요한 페이지에 접속할 경우  \nrest framework 의 <U>authentication</U> class 에서 cookie 에 저장되어 있는 token 값의 유효성을 검사한다.  \nrest framework 의 <U>permission</U> class 에서 해당 유저가 기능에 접근 허가 여부를 판단한다.  \n3. 로그아웃 시 : cookie 의 token 값을 지워준다.  \n4. 추가 정보  \n\t* 인증에 실패한 경우 : cookie 값을 삭제하고 login 페이지로 보낸다.  \n\t* 기능 접근 허가가 거부된 경우 : block page 를 표시한다.  \n\t* 토큰이 만료된 경우 : cookie 값을 삭제하고 login 페이지로 보낸다.    \n5. 제약사항  \n\t* 메인 도메인이 동일해야한다.  \n\t* permission 정보는 공유하지 않기 때문에 각자 사이트에서 구현해야 한다.  \n\n## 환경 설정\n\n```\npython 3.4.3\ndjango 1.8.4\ndjangorestframework 3.3.0\n```\n  \n하나씩 시작해보자.  \n  \n### 패키지 추가하기\n\n```\n$ pip install djangorestframework-jwt\n```\n\n### 로그인 하기\n\n#### 토큰 생성하기\n\n유저 정보가 맞을 경우 이 정보를 토대로 jwt token을 생성해준다.  \njwt_util.py   \n \n```\nfrom calendar import timegm\nfrom datetime import datetime\n \nimport jwt\nfrom rest_framework_jwt.settings import api_settings\n \nfrom user.models.CustomUser import CustomUser\n \n \ndef obtain_token(user: CustomUser):\n    jwt_payload_handler = api_settings.JWT_PAYLOAD_HANDLER\n    jwt_encode_handler = api_settings.JWT_ENCODE_HANDLER\n \n    payload = jwt_payload_handler(user)\n \n    # Include original issued at time for a brand new token,\n    # to allow token refresh\n    if api_settings.JWT_ALLOW_REFRESH:\n        payload['orig_iat'] = timegm(\n            datetime.utcnow().utctimetuple()\n        )\n \n    return jwt_encode_handler(payload)\n```\n\njwt 변수들에 대한 자세한 설정은 Rest Framework JWT 에서 확인 할 수 있다. 그리고 default 로 설정된 변수들을 재선언 하고 싶다면 setting 에 해주면 된다.  \n\nsettings.py  \n\n``` \nJWT_AUTH = {\n    'JWT_EXPIRATION_DELTA': datetime.timedelta(hours=24),\n}\n```\n\n#### 쿠키에 저장하기\n\n사용자가 입력한 아이디와 암호가 맞을 경우 이 정보를 cookie 에 저장을 한다. 저장할 때 domain option 을 main domain(mysite.com) 로 설정해준다. domain 설정을 해주지 않을 경우 다른 사이트에서 쿠키정보를 공유할 수 없다.   \n  \n  \nview.py\n  \n``` \nclass LoginView(View):\n \n    def get(self, request):\n        return TemplateResponse(request, 'account/login.html')\n \n    def post(self, request):\n        username = request.POST.get('username')\n        password = request.POST.get('password')\n \n        try:\n            admin = CustomUser.objects.get(username=username)\n            # 유저 암호 검사하기.\n            if security.matches_password(password, admin.password):\n                # obtain jwt token\n                token = obtain_token(admin)\n \n                # set cookie\n                response = HttpResponseRedirect(reverse('root'))\n                response.set_cookie(key='token', value=token, domain=settings.COOKIE_DOMAIN)\n                return response\n            else:\n                context = {\n                    'error': '비밀번호가 일치하지 않습니다.'\n                }\n        except TAdmin.DoesNotExist:\n            context = {\n                'error': '존재하지 않는 ID입니다.'\n            }\n \n        return TemplateResponse(request, 'account/login.html', context)\n}\n```\n  \n공통으로 사용할 메인 도메인 이름은 각 사이트 마다 통일 해줘야 한다.  \n\nsettings.py  \n\n``` \nCOOKIE_DOMAIN = 'mysite.com'\n```\n\n쿠키에 토큰 값을 저장 했으므로 이제 각 사이트에 로그인 되었다고 할 수 있는 첫번 째 단계는 달성했다.  \n\n#### 페이지 인증정보 확인하기\n로그인이 되어 있어야 접근할 수 있는 페이지의 경우 로그인 정보를 확인한 후에 정보를 로드한다. RestFramework 에서 제공하는 APIView 를 사용해서 인증 정보를 확인한다.  \n\nview.py\n\n```\nclass RootView(APIView):\n    authentication_classes = (CustomAuthentication, )\n    def get(self, request):\n        \"\"\"\n        :param request:\n        :return:\n        \"\"\"\n        redirect_url = \"/home\"\n        return HttpResponseRedirect(redirect_url)\n\n}\n```\n\n 여기서 authentication class 를 명시적으로 선언해주었는데, 모든 APIView(인증과 허가가 필요한 페이지의 경우) 에 적용될 수 있도록 settings 에 선언해줄 수 있다.   \n\n(인증 실패나 허가 요청 실패시 처리해줄 수 있는 핸들러도 미리 추가해놓자.)  \n\nsettings.py  \n\n``` \nREST_FRAMEWORK = {\n    'DEFAULT_AUTHENTICATION_CLASSES': (\n        'common.utils.authentication.CustomAuthentication',\n    ),\n    'EXCEPTION_HANDLER': 'common.utils.custom_exception_handler.custom_exception_handler'\n}\n```\n\n인증 확인은 쿠키에 저장되어 있는 토큰 정보로 확인한다. 토큰으로 정상적인 유저를 가져올 수 있다면 유효한 유저라고 판단한다.  \n\nauthentication.py  \n\n```\nfrom rest_framework import authentication\n \nfrom common.utils.jwt_util import obtain_user\n \n \nclass CustomAuthentication(authentication.BaseAuthentication):\n    def authenticate(self, request):\n        \"\"\"\n        쿠키에 저장되어 있는 token 값으로 유저를 가져옵니다. 가져오는 상황에서 예외가 발생할 수 있으며 정상적으로 가져온 경우에는 인증된 유저라고 판단합니다.\n        :param request:\n        :return:\n        \"\"\"\n        token = request.COOKIES.get('token', None)\n        user = obtain_user(token)\n        return (user, None)\n```\n\n쿠키에 저장되어 있는 토큰을 decode 하여 유효한 정보인지를 판단한다.  \n\njwt_util.py  \n  \n``` \ndef obtain_user(token: str):\n    \"\"\"\n    payload = {'username': 'adm001', 'email': 'test@mysite.com', 'user_id': 1, 'exp': 1462187582}\n    :param token:\n    :return:\n    \"\"\"\n    jwt_decode_handler = api_settings.JWT_DECODE_HANDLER\n    jwt_get_username_from_payload = api_settings.JWT_PAYLOAD_GET_USERNAME_HANDLER\n \n    if not token or len(token) == 0:  # case1: 토큰을 분실 했을 경우\n        raise serializers.ValidationError('Invalid token header. Non credentials provided.')\n        # raise exceptions.AuthenticationFailed({'error': 'Invalid token header. No credentials provided.'})\n \n    try:\n        payload = jwt_decode_handler(token)\n \n    except jwt.ExpiredSignature:  # case2: 토큰이 만료되었을 경우\n        raise serializers.ValidationError('Signature has expired.')\n        # raise exceptions.AuthenticationFailed({'error': 'Signature has expired.'})\n    except jwt.DecodeError:  # case3: 디코드 실패\n        raise serializers.ValidationError('Error decoding signature.')\n        # raise exceptions.AuthenticationFailed({'error': 'Error decoding signature.'})\n \n    username = jwt_get_username_from_payload(payload)\n \n    if not username:  # case4: payload 가 잘못되어 username을 가져올 수 없는 경우\n        raise serializers.ValidationError('Invalid payload.')\n        # raise exceptions.AuthenticationFailed({'error': 'Invalid payload.'})\n \n    try:\n        user = CustomUser.objects.get(username=username)\n    except CustomUser.DoesNotExist:  # case5: 해당 유저가 존재하지 않는 경우\n        raise serializers.ValidationError(\"User doesn't exists.\")\n        # raise exceptions.AuthenticationFailed({'error': \"User doesn't exists.\"})\n \n    return user\n```\n    \n여러 이유로 인증에 실패할 경우엔 인증 실패 예외가 발생하게 되는데 이는 따로 핸들러로 처리해주어야 한다. (에러 정보는 response.data 에 담겨온다.)  \n(여기서는 인증 실패 예외가 발생할 경우 쿠키에 저장되어 있는 토큰값을 지워버리고 로그인 페이지로 보내버린다.)  \n\ncustom_exception_handler.py\n\n```\nfrom django.conf import settings\nfrom django.core.urlresolvers import reverse\nfrom django.http import HttpResponseRedirect\nfrom rest_framework import status\nfrom rest_framework.views import exception_handler\n \n \ndef custom_exception_handler(exc, context):\n    # 발생한 exception을 가져온다.\n    response = exception_handler(exc, context)\n \n    if response is not None:\n        # response_data = response.data['detail']\n        # print('response : ', response.__dict__)\n \n        # 예외가 발생할 경우엔 token쿠키를 지워준다\n        response.delete_cookie('token', domain=settings.COOKIE_DOMAIN)\n \n        return HttpResponseRedirect(reverse('login'))\n    else:\n        return None\n```\n\n#### 페이지 접근 허가 정보 확인하기\n접근하고자 하는 페이지가 각 유저별로 인증 정보가 필요하다면 유저의 인증 정보를 확인할 수 있어야 한다.  \n\npermission.py  \n\n```\nfrom rest_framework.permissions import BasePermission\n \n \nclass CustomPermission(BasePermission):\n    def has_permission(self, request, view):\n        # TODO: do something\n        print('CustomPermission user : ', request.user)\n        return True\n```\n\n(현재는 어떤 허가 정보도 판단하지 않지만 이 부분에서 유저 정보를 가지고 해당 페이지에 대한 허가 정보를 판단해서 boolean 값으로 반환해준다. True일 경우 허가된 경우고 False일 경우엔 허가되지 않는 유저이다.)  \n  \nAPIView 에서 허가 정보도 명시적으로 선언해서 확인할 수 있다.  \n\nview.py  \n\n```\nclass RootView(APIView):\n    authentication_classes = (CustomAuthentication, )\n    permission_classes = (CustomPermission, )\n    def get(self, request):\n        \"\"\"\n        :param request:\n        :return:\n        \"\"\"\n        redirect_url = \"/home\"\n        return HttpResponseRedirect(redirect_url)\n```\n\n마찬가지로 모든 APIView 에서 허가 정보를 확인해야 한다면 settings 에 설정해줄 수 있다. 좀 전에 인증 정보를 작성한 부분에 추가해주자.  \n  \nsettings.py\n\n```\nREST_FRAMEWORK = {\n    'DEFAULT_AUTHENTICATION_CLASSES': (\n        'common.utils.authentication.CustomAuthentication',\n    ),\n    'DEFAULT_PERMISSION_CLASSES': (\n        'common.utils.permission.CustomPermission',\n    ),\n    'EXCEPTION_HANDLER': 'common.utils.custom_exception_handler.custom_exception_handler'\n}\n```\n\n허가 요청에 대한 부분이 추가되었으므로 예외 처리 핸들러에서 이 부분에 대한 처리도 추가해줘야 한다. 요청이 실패할 경우 403 에러가 발생하는데 이 부분에 대한 처리를 해준다.  \n  \ncustom_exception_handler.py  \n\n```\nfrom django.conf import settings\nfrom django.core.urlresolvers import reverse\nfrom django.http import HttpResponseRedirect\nfrom rest_framework import status\nfrom rest_framework.views import exception_handler\n \n \ndef custom_exception_handler(exc, context):\n    # 발생한 exception을 가져온다.\n    response = exception_handler(exc, context)\n \n    if response is not None:\n        # response_data = response.data['detail']\n        # print('response : ', response.__dict__)\n \n        # permission 이 안되는 경우엔 block page 로 넘겨준다.\n        if response.status_code == status.HTTP_403_FORBIDDEN:\n            return HttpResponseRedirect(reverse('block'))\n \n        # 예외가 발생할 경우엔 token쿠키를 지워준다\n        response.delete_cookie('token', domain=settings.COOKIE_DOMAIN)\n \n        return HttpResponseRedirect(reverse('login'))\n    else:\n        return None\n```\n\n인증 실패인 경우에는 쿠키에서 토큰 정보를 삭제하고   \n로그인 페이지로 보내버리고,   \n허가 요청 거부일 경우에는 block 페이지로 보내버렸는데,   \n이 부분은 각 사이트의 상황에 맞게 처리해주면 된다.  \n  \n#### 로그아웃 하기\n로그아웃은 간단하다. 단지 쿠키에 저장되어 있는 토큰 값을 지워버리면 되기 때문이다.  \n\nview.py\n\n```\nclass LogoutView(View):\n \n    def get(self, request):\n        response = HttpResponseRedirect(reverse('login'))\n        response.delete_cookie('token', domain=settings.COOKIE_DOMAIN)\n        return response\n```\n\n#### 요약\n지금까지 추가된 파일들과 클래스를 정리하자면 다음과 같다.  \n\n```\ncommon/utils/custom_exception_handler.py\n    - custom_exception_handler\ncommon/utils/authentication.py\n    - CustomAuthentication\ncommon/utils/permission.py\n    - CustomerPermission\ncommon/utils/jwt_util.py\n    - obtain_token\n    - obtain_user\n```\n\n여기까지 따라왔다면 sso를 완성 할 수 있다. 하나의 사이트에서 동작하는지 여부를 검사하고 싶다면 hosts 에 도메인을 추가해서 테스트 해보자.  \n\n```\n$ sudo vim /etc/hosts\n```\n\n/etc/hosts  \n\n```\n127.0.0.1   alpha.mysite.com\n127.0.0.1   beta.mysite.com\n```\n\n위와 같이 추가하고 테스트를 해볼 수 있다.  \n\n## 결론\n\n유저의 로그인 검증 후 유저 정보를 jwt 를 이용해서 토큰을 생성한 후, 이 정보는 메인 도메인으로 쿠키에 저장을 한다. 인증이 필요한 페이지의 경우 cookie 에 저장되어 있는 토큰으로 인증된 유저인지 여부를 판단한다. 이 때, 이 토큰 값이 유효하지 않을 경우엔 강제로 로그아웃 처리를 한다. jwt 토큰의 만료 시간을 주어 일정 시간이 지나면 로그인이 풀리도록 했다. 메인 도메인 하위의 3개의 사이트중 하나의 사이트에서만 로그인을 하면 나머지 두개의 사이트에서도 로그인이 되어 있다(같은 쿠키의 토큰을 사용하기 때문)\n\n\n### 추신\n\n나름 간단하게 기능을 구현하고자 했는데 로그인 정보를 저장하고 그 토큰을 처리하기 위해 여러 처리가 붙었다. 그리고 토큰 값을 만들고 검증하고 이를 인증하는 코드들을 직접 쓰다보니 조금은 번거로운 작업들이 포함되어 있는 건 사실이다.. 때로는 오픈소스를 별다른 이해 없이 기능을 사용하기 위해 가져다 쓰는 것 보다 내부 로직을 이해하고 내가 필요한 부분들만 가져다 쓰는 작업을 하면 재미있기도 하고 후에 문제가 생기거나 기능 변경이 생겼을 때 대처가 빠르다. 물론 이런 방식이 정답을 아닐지는 몰라도 덕분에 재미있는 작업을 했다는 점에 만족한다.\n\n\n","source":"_posts/django-sso.md","raw":"---\ntitle: \"Django에서 SSO하기\"\ncatalog: true\ndate: 2016-05-06 16:59:58\nsubtitle:\nheader-img:\ntags:\n- django\n- sso\n\n---\n\n회사에서 필요에 의해 [Single Sign On](https://ko.wikipedia.org/wiki/%ED%86%B5%ED%95%A9_%EC%9D%B8%EC%A6%9D, \"Single Sign On\")을 구현해야 할 일이 있었다. 3개의 독립된 사이트가 있었고, 각자 로그인을 따로 해야 한다는 점이 사용자 입장에서는 번거로운 일이 될 수 있다는 이유에서 였다. \n\n 3개의 사이트는 하나의 유저테이블을 바라보고 있었기 때문에 충분히 합당한 이유였다. 하지만 django에서 제공하는 기본 유저 테이블을 사용하지 않기 때문에 찾아봤었던 다른 인증 툴들은 그대로 사용하기 까다로워 보였다. 내가 구현해야 하는 상황에는 몇가지 제약사항이 있었다.  \n  \n1. 로그인을 시도할 때 기존에 제공되는 auth_user 테이블이 아닌 <U>별도의 user 테이블을 사용하고 있다.</U>\n  \n2. 기존에 제공되는 user 모델을 사용하지 않기 때문에 <U>reatframework 에서 기존에 제공하는 인증방식을 그대로 사용할 수 없었다.</U>\n  \n3. 이미 테이블이 존재하고 <U>django 프로젝트에서 migration 을 할 수 없는 상황이다.</U> 기존에 생성되어 있는 테이블들의 구성을 변경할 수는 있지만 그 과정과 절차가 까다롭고 (회사의 사정에 의해), 외래키를 사용하지 않았기 때문에 모델과 테이블간의 100% 싱크가 맞지 않는 상황이었다.\n  \n4. 위와 같은 이유로 찾아봤었던 [MamaCAS](https://github.com/jbittel/django-mama-cas, \"MamaCas\") 같은 외부 인증툴을 사용할 수 없었다. (migration을 할 수 없었기에 인증을 위해 별도의 테이블을 생성하기 까다로운 상황이었다.)\n  \n3개의 프로젝트들이 출시가 얼마 남지 않은 상황이고, 인증을 위해서 별도의 커다란 작업이 있는 것은 별로 좋은 선택이 아니였다. 물론 외부의 다른 툴들을 이용할 수도 있었지만, 단순 인증을 위해 외부툴을 사용하기엔 부담스러운 부분이 있었고, 볼륨을 크게 잡고 싶지 않았다. \n  \n여러 방법을 찾아보면서 몇가지 아이디어가 나왔었다.\n  \n1. [redis](https://redis.io/, \"redis\") 를 이용해서 인증 정보를 저장하는 방식\n  \n2. [jwt](https://jwt.io/, \"jwt\")를 이용해서 javascript 내부에서 localStorage 에 인증 정보를 저장하는 방식\n  \n3. cookie에 저장하는 방식\n  \n나는 일단 1번의 redis는 제외하기로 했다. 이미 각각의 프로젝트에서 redis를 사용하고 있었고, 인증을 위해 별도의 redis를 띄우는게 번거롭다고 생각했다. 그리고 2번의 localStorage 방식은 javascript에서 ajax통신을 각 페이지별로 날려 유효한 인증을 판단하는 방식이었는데, django 단에서 각 request마다 헤더에 인증 정보를 넣기가 까다로웠다. (하지만 jwt로 토큰을 암호화 하는건 괜찮은 방법이라 생각했다.) 3번의 cookie 방식은 별도의 작업 없이 구현이 가능했지만 3개의 사이트가 같은 메인 도메인 하에 있어야 가능했었다. 어차피 모든 사이트가 회사 내부에서 사용할 목적으로 만들어 지고 있는 프로젝트 였고 같은 메인 도메인만 사용하면 되었기 때문에 나는 3번째의 방법을 사용하기로 했다. \n  \n서론이 길었지만.. 그리하여 jwt와 cookie를 이용해서 sso를 구현해 보기로 했다.\n  \n여러 사이트가 있고 각각 로그인(유저 인증)이 필요하고 기능 마다 해당 유저가 접근할 수 있는(허가) 기능이 필요하다. \n  \n(single sign on 을 하다보니 authentication 과 permission 처리가 필요했다..)\n  \n여러 개의 사이트가 공유하는 유저 정보가 있고, 이 정보로 로그인을 하기 때문에 모든 사이트에서 한번의 로그인을 하면 되는 기능이 필요했다.추가적으로 각 사이트 별로는 각자의 허가 정보가 있으므로 이 정보는 공유하지 않고 각자 구현한다. (템플릿만 제공)\n  \n한마디로 요약하면 쿠키에 암호화된 토큰 정보를 도메인이 같은 사이트들끼리 로그인 정보를 공유를 해서 사용하는 방법이다. \n  \n## 예상 시나리오\n  \nalpha.mysite.com, beta.mysite.com, charlie.mysite.com 3개의 사이트가 있다.  \nbeta 에서 로그인을 하고 charlie 사이트에 접속할 경우 이미 로그인이 되어 있다.  \n3개의 사이트는 각자 permission 이 따로 존재한다.  \nalpha 에서 로그아웃을 할 경우, 나머지 사이트에서도 모두 로그아웃이 된다.  \n로그인 정보가 만료되었을 경우에도 로그아웃 처리된다.  \n  \n## 시나리오 순서 별 설명\n\n1. 로그인 시 : <U>jwt token</U> 을 발급해서 request cookie에 저장한다. (이 때, <U>cookie</U> 의 domain은 main domain 값을 넣어준다.<mysite.com>)  \n2. 인증이 필요한 페이지에 접속할 경우  \nrest framework 의 <U>authentication</U> class 에서 cookie 에 저장되어 있는 token 값의 유효성을 검사한다.  \nrest framework 의 <U>permission</U> class 에서 해당 유저가 기능에 접근 허가 여부를 판단한다.  \n3. 로그아웃 시 : cookie 의 token 값을 지워준다.  \n4. 추가 정보  \n\t* 인증에 실패한 경우 : cookie 값을 삭제하고 login 페이지로 보낸다.  \n\t* 기능 접근 허가가 거부된 경우 : block page 를 표시한다.  \n\t* 토큰이 만료된 경우 : cookie 값을 삭제하고 login 페이지로 보낸다.    \n5. 제약사항  \n\t* 메인 도메인이 동일해야한다.  \n\t* permission 정보는 공유하지 않기 때문에 각자 사이트에서 구현해야 한다.  \n\n## 환경 설정\n\n```\npython 3.4.3\ndjango 1.8.4\ndjangorestframework 3.3.0\n```\n  \n하나씩 시작해보자.  \n  \n### 패키지 추가하기\n\n```\n$ pip install djangorestframework-jwt\n```\n\n### 로그인 하기\n\n#### 토큰 생성하기\n\n유저 정보가 맞을 경우 이 정보를 토대로 jwt token을 생성해준다.  \njwt_util.py   \n \n```\nfrom calendar import timegm\nfrom datetime import datetime\n \nimport jwt\nfrom rest_framework_jwt.settings import api_settings\n \nfrom user.models.CustomUser import CustomUser\n \n \ndef obtain_token(user: CustomUser):\n    jwt_payload_handler = api_settings.JWT_PAYLOAD_HANDLER\n    jwt_encode_handler = api_settings.JWT_ENCODE_HANDLER\n \n    payload = jwt_payload_handler(user)\n \n    # Include original issued at time for a brand new token,\n    # to allow token refresh\n    if api_settings.JWT_ALLOW_REFRESH:\n        payload['orig_iat'] = timegm(\n            datetime.utcnow().utctimetuple()\n        )\n \n    return jwt_encode_handler(payload)\n```\n\njwt 변수들에 대한 자세한 설정은 Rest Framework JWT 에서 확인 할 수 있다. 그리고 default 로 설정된 변수들을 재선언 하고 싶다면 setting 에 해주면 된다.  \n\nsettings.py  \n\n``` \nJWT_AUTH = {\n    'JWT_EXPIRATION_DELTA': datetime.timedelta(hours=24),\n}\n```\n\n#### 쿠키에 저장하기\n\n사용자가 입력한 아이디와 암호가 맞을 경우 이 정보를 cookie 에 저장을 한다. 저장할 때 domain option 을 main domain(mysite.com) 로 설정해준다. domain 설정을 해주지 않을 경우 다른 사이트에서 쿠키정보를 공유할 수 없다.   \n  \n  \nview.py\n  \n``` \nclass LoginView(View):\n \n    def get(self, request):\n        return TemplateResponse(request, 'account/login.html')\n \n    def post(self, request):\n        username = request.POST.get('username')\n        password = request.POST.get('password')\n \n        try:\n            admin = CustomUser.objects.get(username=username)\n            # 유저 암호 검사하기.\n            if security.matches_password(password, admin.password):\n                # obtain jwt token\n                token = obtain_token(admin)\n \n                # set cookie\n                response = HttpResponseRedirect(reverse('root'))\n                response.set_cookie(key='token', value=token, domain=settings.COOKIE_DOMAIN)\n                return response\n            else:\n                context = {\n                    'error': '비밀번호가 일치하지 않습니다.'\n                }\n        except TAdmin.DoesNotExist:\n            context = {\n                'error': '존재하지 않는 ID입니다.'\n            }\n \n        return TemplateResponse(request, 'account/login.html', context)\n}\n```\n  \n공통으로 사용할 메인 도메인 이름은 각 사이트 마다 통일 해줘야 한다.  \n\nsettings.py  \n\n``` \nCOOKIE_DOMAIN = 'mysite.com'\n```\n\n쿠키에 토큰 값을 저장 했으므로 이제 각 사이트에 로그인 되었다고 할 수 있는 첫번 째 단계는 달성했다.  \n\n#### 페이지 인증정보 확인하기\n로그인이 되어 있어야 접근할 수 있는 페이지의 경우 로그인 정보를 확인한 후에 정보를 로드한다. RestFramework 에서 제공하는 APIView 를 사용해서 인증 정보를 확인한다.  \n\nview.py\n\n```\nclass RootView(APIView):\n    authentication_classes = (CustomAuthentication, )\n    def get(self, request):\n        \"\"\"\n        :param request:\n        :return:\n        \"\"\"\n        redirect_url = \"/home\"\n        return HttpResponseRedirect(redirect_url)\n\n}\n```\n\n 여기서 authentication class 를 명시적으로 선언해주었는데, 모든 APIView(인증과 허가가 필요한 페이지의 경우) 에 적용될 수 있도록 settings 에 선언해줄 수 있다.   \n\n(인증 실패나 허가 요청 실패시 처리해줄 수 있는 핸들러도 미리 추가해놓자.)  \n\nsettings.py  \n\n``` \nREST_FRAMEWORK = {\n    'DEFAULT_AUTHENTICATION_CLASSES': (\n        'common.utils.authentication.CustomAuthentication',\n    ),\n    'EXCEPTION_HANDLER': 'common.utils.custom_exception_handler.custom_exception_handler'\n}\n```\n\n인증 확인은 쿠키에 저장되어 있는 토큰 정보로 확인한다. 토큰으로 정상적인 유저를 가져올 수 있다면 유효한 유저라고 판단한다.  \n\nauthentication.py  \n\n```\nfrom rest_framework import authentication\n \nfrom common.utils.jwt_util import obtain_user\n \n \nclass CustomAuthentication(authentication.BaseAuthentication):\n    def authenticate(self, request):\n        \"\"\"\n        쿠키에 저장되어 있는 token 값으로 유저를 가져옵니다. 가져오는 상황에서 예외가 발생할 수 있으며 정상적으로 가져온 경우에는 인증된 유저라고 판단합니다.\n        :param request:\n        :return:\n        \"\"\"\n        token = request.COOKIES.get('token', None)\n        user = obtain_user(token)\n        return (user, None)\n```\n\n쿠키에 저장되어 있는 토큰을 decode 하여 유효한 정보인지를 판단한다.  \n\njwt_util.py  \n  \n``` \ndef obtain_user(token: str):\n    \"\"\"\n    payload = {'username': 'adm001', 'email': 'test@mysite.com', 'user_id': 1, 'exp': 1462187582}\n    :param token:\n    :return:\n    \"\"\"\n    jwt_decode_handler = api_settings.JWT_DECODE_HANDLER\n    jwt_get_username_from_payload = api_settings.JWT_PAYLOAD_GET_USERNAME_HANDLER\n \n    if not token or len(token) == 0:  # case1: 토큰을 분실 했을 경우\n        raise serializers.ValidationError('Invalid token header. Non credentials provided.')\n        # raise exceptions.AuthenticationFailed({'error': 'Invalid token header. No credentials provided.'})\n \n    try:\n        payload = jwt_decode_handler(token)\n \n    except jwt.ExpiredSignature:  # case2: 토큰이 만료되었을 경우\n        raise serializers.ValidationError('Signature has expired.')\n        # raise exceptions.AuthenticationFailed({'error': 'Signature has expired.'})\n    except jwt.DecodeError:  # case3: 디코드 실패\n        raise serializers.ValidationError('Error decoding signature.')\n        # raise exceptions.AuthenticationFailed({'error': 'Error decoding signature.'})\n \n    username = jwt_get_username_from_payload(payload)\n \n    if not username:  # case4: payload 가 잘못되어 username을 가져올 수 없는 경우\n        raise serializers.ValidationError('Invalid payload.')\n        # raise exceptions.AuthenticationFailed({'error': 'Invalid payload.'})\n \n    try:\n        user = CustomUser.objects.get(username=username)\n    except CustomUser.DoesNotExist:  # case5: 해당 유저가 존재하지 않는 경우\n        raise serializers.ValidationError(\"User doesn't exists.\")\n        # raise exceptions.AuthenticationFailed({'error': \"User doesn't exists.\"})\n \n    return user\n```\n    \n여러 이유로 인증에 실패할 경우엔 인증 실패 예외가 발생하게 되는데 이는 따로 핸들러로 처리해주어야 한다. (에러 정보는 response.data 에 담겨온다.)  \n(여기서는 인증 실패 예외가 발생할 경우 쿠키에 저장되어 있는 토큰값을 지워버리고 로그인 페이지로 보내버린다.)  \n\ncustom_exception_handler.py\n\n```\nfrom django.conf import settings\nfrom django.core.urlresolvers import reverse\nfrom django.http import HttpResponseRedirect\nfrom rest_framework import status\nfrom rest_framework.views import exception_handler\n \n \ndef custom_exception_handler(exc, context):\n    # 발생한 exception을 가져온다.\n    response = exception_handler(exc, context)\n \n    if response is not None:\n        # response_data = response.data['detail']\n        # print('response : ', response.__dict__)\n \n        # 예외가 발생할 경우엔 token쿠키를 지워준다\n        response.delete_cookie('token', domain=settings.COOKIE_DOMAIN)\n \n        return HttpResponseRedirect(reverse('login'))\n    else:\n        return None\n```\n\n#### 페이지 접근 허가 정보 확인하기\n접근하고자 하는 페이지가 각 유저별로 인증 정보가 필요하다면 유저의 인증 정보를 확인할 수 있어야 한다.  \n\npermission.py  \n\n```\nfrom rest_framework.permissions import BasePermission\n \n \nclass CustomPermission(BasePermission):\n    def has_permission(self, request, view):\n        # TODO: do something\n        print('CustomPermission user : ', request.user)\n        return True\n```\n\n(현재는 어떤 허가 정보도 판단하지 않지만 이 부분에서 유저 정보를 가지고 해당 페이지에 대한 허가 정보를 판단해서 boolean 값으로 반환해준다. True일 경우 허가된 경우고 False일 경우엔 허가되지 않는 유저이다.)  \n  \nAPIView 에서 허가 정보도 명시적으로 선언해서 확인할 수 있다.  \n\nview.py  \n\n```\nclass RootView(APIView):\n    authentication_classes = (CustomAuthentication, )\n    permission_classes = (CustomPermission, )\n    def get(self, request):\n        \"\"\"\n        :param request:\n        :return:\n        \"\"\"\n        redirect_url = \"/home\"\n        return HttpResponseRedirect(redirect_url)\n```\n\n마찬가지로 모든 APIView 에서 허가 정보를 확인해야 한다면 settings 에 설정해줄 수 있다. 좀 전에 인증 정보를 작성한 부분에 추가해주자.  \n  \nsettings.py\n\n```\nREST_FRAMEWORK = {\n    'DEFAULT_AUTHENTICATION_CLASSES': (\n        'common.utils.authentication.CustomAuthentication',\n    ),\n    'DEFAULT_PERMISSION_CLASSES': (\n        'common.utils.permission.CustomPermission',\n    ),\n    'EXCEPTION_HANDLER': 'common.utils.custom_exception_handler.custom_exception_handler'\n}\n```\n\n허가 요청에 대한 부분이 추가되었으므로 예외 처리 핸들러에서 이 부분에 대한 처리도 추가해줘야 한다. 요청이 실패할 경우 403 에러가 발생하는데 이 부분에 대한 처리를 해준다.  \n  \ncustom_exception_handler.py  \n\n```\nfrom django.conf import settings\nfrom django.core.urlresolvers import reverse\nfrom django.http import HttpResponseRedirect\nfrom rest_framework import status\nfrom rest_framework.views import exception_handler\n \n \ndef custom_exception_handler(exc, context):\n    # 발생한 exception을 가져온다.\n    response = exception_handler(exc, context)\n \n    if response is not None:\n        # response_data = response.data['detail']\n        # print('response : ', response.__dict__)\n \n        # permission 이 안되는 경우엔 block page 로 넘겨준다.\n        if response.status_code == status.HTTP_403_FORBIDDEN:\n            return HttpResponseRedirect(reverse('block'))\n \n        # 예외가 발생할 경우엔 token쿠키를 지워준다\n        response.delete_cookie('token', domain=settings.COOKIE_DOMAIN)\n \n        return HttpResponseRedirect(reverse('login'))\n    else:\n        return None\n```\n\n인증 실패인 경우에는 쿠키에서 토큰 정보를 삭제하고   \n로그인 페이지로 보내버리고,   \n허가 요청 거부일 경우에는 block 페이지로 보내버렸는데,   \n이 부분은 각 사이트의 상황에 맞게 처리해주면 된다.  \n  \n#### 로그아웃 하기\n로그아웃은 간단하다. 단지 쿠키에 저장되어 있는 토큰 값을 지워버리면 되기 때문이다.  \n\nview.py\n\n```\nclass LogoutView(View):\n \n    def get(self, request):\n        response = HttpResponseRedirect(reverse('login'))\n        response.delete_cookie('token', domain=settings.COOKIE_DOMAIN)\n        return response\n```\n\n#### 요약\n지금까지 추가된 파일들과 클래스를 정리하자면 다음과 같다.  \n\n```\ncommon/utils/custom_exception_handler.py\n    - custom_exception_handler\ncommon/utils/authentication.py\n    - CustomAuthentication\ncommon/utils/permission.py\n    - CustomerPermission\ncommon/utils/jwt_util.py\n    - obtain_token\n    - obtain_user\n```\n\n여기까지 따라왔다면 sso를 완성 할 수 있다. 하나의 사이트에서 동작하는지 여부를 검사하고 싶다면 hosts 에 도메인을 추가해서 테스트 해보자.  \n\n```\n$ sudo vim /etc/hosts\n```\n\n/etc/hosts  \n\n```\n127.0.0.1   alpha.mysite.com\n127.0.0.1   beta.mysite.com\n```\n\n위와 같이 추가하고 테스트를 해볼 수 있다.  \n\n## 결론\n\n유저의 로그인 검증 후 유저 정보를 jwt 를 이용해서 토큰을 생성한 후, 이 정보는 메인 도메인으로 쿠키에 저장을 한다. 인증이 필요한 페이지의 경우 cookie 에 저장되어 있는 토큰으로 인증된 유저인지 여부를 판단한다. 이 때, 이 토큰 값이 유효하지 않을 경우엔 강제로 로그아웃 처리를 한다. jwt 토큰의 만료 시간을 주어 일정 시간이 지나면 로그인이 풀리도록 했다. 메인 도메인 하위의 3개의 사이트중 하나의 사이트에서만 로그인을 하면 나머지 두개의 사이트에서도 로그인이 되어 있다(같은 쿠키의 토큰을 사용하기 때문)\n\n\n### 추신\n\n나름 간단하게 기능을 구현하고자 했는데 로그인 정보를 저장하고 그 토큰을 처리하기 위해 여러 처리가 붙었다. 그리고 토큰 값을 만들고 검증하고 이를 인증하는 코드들을 직접 쓰다보니 조금은 번거로운 작업들이 포함되어 있는 건 사실이다.. 때로는 오픈소스를 별다른 이해 없이 기능을 사용하기 위해 가져다 쓰는 것 보다 내부 로직을 이해하고 내가 필요한 부분들만 가져다 쓰는 작업을 하면 재미있기도 하고 후에 문제가 생기거나 기능 변경이 생겼을 때 대처가 빠르다. 물론 이런 방식이 정답을 아닐지는 몰라도 덕분에 재미있는 작업을 했다는 점에 만족한다.\n\n\n","slug":"django-sso","published":1,"updated":"2017-06-10T08:25:49.000Z","_id":"cj3r0l3hg00039fhhgpag16j3","comments":1,"layout":"post","photos":[],"link":"","content":"<p>회사에서 필요에 의해 <a href=\"https://ko.wikipedia.org/wiki/%ED%86%B5%ED%95%A9_%EC%9D%B8%EC%A6%9D,\" title=\"Single Sign On\" target=\"_blank\" rel=\"external\">Single Sign On</a>을 구현해야 할 일이 있었다. 3개의 독립된 사이트가 있었고, 각자 로그인을 따로 해야 한다는 점이 사용자 입장에서는 번거로운 일이 될 수 있다는 이유에서 였다.</p>\n<p>3개의 사이트는 하나의 유저테이블을 바라보고 있었기 때문에 충분히 합당한 이유였다. 하지만 django에서 제공하는 기본 유저 테이블을 사용하지 않기 때문에 찾아봤었던 다른 인증 툴들은 그대로 사용하기 까다로워 보였다. 내가 구현해야 하는 상황에는 몇가지 제약사항이 있었다.</p>\n<ol>\n<li>\n<p>로그인을 시도할 때 기존에 제공되는 auth_user 테이블이 아닌 <u>별도의 user 테이블을 사용하고 있다.</u></p>\n</li>\n<li>\n<p>기존에 제공되는 user 모델을 사용하지 않기 때문에 <u>reatframework 에서 기존에 제공하는 인증방식을 그대로 사용할 수 없었다.</u></p>\n</li>\n<li>\n<p>이미 테이블이 존재하고 <u>django 프로젝트에서 migration 을 할 수 없는 상황이다.</u> 기존에 생성되어 있는 테이블들의 구성을 변경할 수는 있지만 그 과정과 절차가 까다롭고 (회사의 사정에 의해), 외래키를 사용하지 않았기 때문에 모델과 테이블간의 100% 싱크가 맞지 않는 상황이었다.</p>\n</li>\n<li>\n<p>위와 같은 이유로 찾아봤었던 <a href=\"https://github.com/jbittel/django-mama-cas,\" title=\"MamaCas\" target=\"_blank\" rel=\"external\">MamaCAS</a> 같은 외부 인증툴을 사용할 수 없었다. (migration을 할 수 없었기에 인증을 위해 별도의 테이블을 생성하기 까다로운 상황이었다.)</p>\n</li>\n</ol>\n<p>3개의 프로젝트들이 출시가 얼마 남지 않은 상황이고, 인증을 위해서 별도의 커다란 작업이 있는 것은 별로 좋은 선택이 아니였다. 물론 외부의 다른 툴들을 이용할 수도 있었지만, 단순 인증을 위해 외부툴을 사용하기엔 부담스러운 부분이 있었고, 볼륨을 크게 잡고 싶지 않았다.</p>\n<p>여러 방법을 찾아보면서 몇가지 아이디어가 나왔었다.</p>\n<ol>\n<li>\n<p><a href=\"https://redis.io/,\" title=\"redis\" target=\"_blank\" rel=\"external\">redis</a> 를 이용해서 인증 정보를 저장하는 방식</p>\n</li>\n<li>\n<p><a href=\"https://jwt.io/,\" title=\"jwt\" target=\"_blank\" rel=\"external\">jwt</a>를 이용해서 javascript 내부에서 localStorage 에 인증 정보를 저장하는 방식</p>\n</li>\n<li>\n<p>cookie에 저장하는 방식</p>\n</li>\n</ol>\n<p>나는 일단 1번의 redis는 제외하기로 했다. 이미 각각의 프로젝트에서 redis를 사용하고 있었고, 인증을 위해 별도의 redis를 띄우는게 번거롭다고 생각했다. 그리고 2번의 localStorage 방식은 javascript에서 ajax통신을 각 페이지별로 날려 유효한 인증을 판단하는 방식이었는데, django 단에서 각 request마다 헤더에 인증 정보를 넣기가 까다로웠다. (하지만 jwt로 토큰을 암호화 하는건 괜찮은 방법이라 생각했다.) 3번의 cookie 방식은 별도의 작업 없이 구현이 가능했지만 3개의 사이트가 같은 메인 도메인 하에 있어야 가능했었다. 어차피 모든 사이트가 회사 내부에서 사용할 목적으로 만들어 지고 있는 프로젝트 였고 같은 메인 도메인만 사용하면 되었기 때문에 나는 3번째의 방법을 사용하기로 했다.</p>\n<p>서론이 길었지만… 그리하여 jwt와 cookie를 이용해서 sso를 구현해 보기로 했다.</p>\n<p>여러 사이트가 있고 각각 로그인(유저 인증)이 필요하고 기능 마다 해당 유저가 접근할 수 있는(허가) 기능이 필요하다.</p>\n<p>(single sign on 을 하다보니 authentication 과 permission 처리가 필요했다…)</p>\n<p>여러 개의 사이트가 공유하는 유저 정보가 있고, 이 정보로 로그인을 하기 때문에 모든 사이트에서 한번의 로그인을 하면 되는 기능이 필요했다.추가적으로 각 사이트 별로는 각자의 허가 정보가 있으므로 이 정보는 공유하지 않고 각자 구현한다. (템플릿만 제공)</p>\n<p>한마디로 요약하면 쿠키에 암호화된 토큰 정보를 도메인이 같은 사이트들끼리 로그인 정보를 공유를 해서 사용하는 방법이다.</p>\n<h2 id=\"예상-시나리오\">예상 시나리오</h2>\n<p><a href=\"http://alpha.mysite.com\" target=\"_blank\" rel=\"external\">alpha.mysite.com</a>, <a href=\"http://beta.mysite.com\" target=\"_blank\" rel=\"external\">beta.mysite.com</a>, <a href=\"http://charlie.mysite.com\" target=\"_blank\" rel=\"external\">charlie.mysite.com</a> 3개의 사이트가 있다.<br>\nbeta 에서 로그인을 하고 charlie 사이트에 접속할 경우 이미 로그인이 되어 있다.<br>\n3개의 사이트는 각자 permission 이 따로 존재한다.<br>\nalpha 에서 로그아웃을 할 경우, 나머지 사이트에서도 모두 로그아웃이 된다.<br>\n로그인 정보가 만료되었을 경우에도 로그아웃 처리된다.</p>\n<h2 id=\"시나리오-순서-별-설명\">시나리오 순서 별 설명</h2>\n<ol>\n<li>로그인 시 : <u>jwt token</u> 을 발급해서 request cookie에 저장한다. (이 때, <u>cookie</u> 의 domain은 main domain 값을 넣어준다.&lt;<a href=\"http://mysite.com\" target=\"_blank\" rel=\"external\">mysite.com</a>&gt;)</li>\n<li>인증이 필요한 페이지에 접속할 경우<br>\nrest framework 의 <u>authentication</u> class 에서 cookie 에 저장되어 있는 token 값의 유효성을 검사한다.<br>\nrest framework 의 <u>permission</u> class 에서 해당 유저가 기능에 접근 허가 여부를 판단한다.</li>\n<li>로그아웃 시 : cookie 의 token 값을 지워준다.</li>\n<li>추가 정보\n<ul>\n<li>인증에 실패한 경우 : cookie 값을 삭제하고 login 페이지로 보낸다.</li>\n<li>기능 접근 허가가 거부된 경우 : block page 를 표시한다.</li>\n<li>토큰이 만료된 경우 : cookie 값을 삭제하고 login 페이지로 보낸다.</li>\n</ul>\n</li>\n<li>제약사항\n<ul>\n<li>메인 도메인이 동일해야한다.</li>\n<li>permission 정보는 공유하지 않기 때문에 각자 사이트에서 구현해야 한다.</li>\n</ul>\n</li>\n</ol>\n<h2 id=\"환경-설정\">환경 설정</h2>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"selector-tag\">python</span> 3<span class=\"selector-class\">.4</span><span class=\"selector-class\">.3</span></div><div class=\"line\"><span class=\"selector-tag\">django</span> 1<span class=\"selector-class\">.8</span><span class=\"selector-class\">.4</span></div><div class=\"line\"><span class=\"selector-tag\">djangorestframework</span> 3<span class=\"selector-class\">.3</span><span class=\"selector-class\">.0</span></div></pre></td></tr></table></figure>\n<p>하나씩 시작해보자.</p>\n<h3 id=\"패키지-추가하기\">패키지 추가하기</h3>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> pip install djangorestframework-jwt</span></div></pre></td></tr></table></figure>\n<h3 id=\"로그인-하기\">로그인 하기</h3>\n<h4 id=\"토큰-생성하기\">토큰 생성하기</h4>\n<p>유저 정보가 맞을 경우 이 정보를 토대로 jwt token을 생성해준다.<br>\njwt_util.py</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">from</span> calendar <span class=\"keyword\">import</span> timegm</div><div class=\"line\"><span class=\"keyword\">from</span> datetime <span class=\"keyword\">import</span> datetime</div><div class=\"line\"> </div><div class=\"line\"><span class=\"keyword\">import</span> jwt</div><div class=\"line\"><span class=\"keyword\">from</span> rest_framework_jwt.settings <span class=\"keyword\">import</span> api_settings</div><div class=\"line\"> </div><div class=\"line\"><span class=\"keyword\">from</span> user.models.CustomUser <span class=\"keyword\">import</span> CustomUser</div><div class=\"line\"> </div><div class=\"line\"> </div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">obtain_token</span><span class=\"params\">(user: CustomUser)</span>:</span></div><div class=\"line\">    jwt_payload_handler = api_settings.JWT_PAYLOAD_HANDLER</div><div class=\"line\">    jwt_encode_handler = api_settings.JWT_ENCODE_HANDLER</div><div class=\"line\"> </div><div class=\"line\">    payload = jwt_payload_handler(user)</div><div class=\"line\"> </div><div class=\"line\">    <span class=\"comment\"># Include original issued at time for a brand new token,</span></div><div class=\"line\">    <span class=\"comment\"># to allow token refresh</span></div><div class=\"line\">    <span class=\"keyword\">if</span> api_settings.JWT_ALLOW_REFRESH:</div><div class=\"line\">        payload[<span class=\"string\">'orig_iat'</span>] = timegm(</div><div class=\"line\">            datetime.utcnow().utctimetuple()</div><div class=\"line\">        )</div><div class=\"line\"> </div><div class=\"line\">    <span class=\"keyword\">return</span> jwt_encode_handler(payload)</div></pre></td></tr></table></figure>\n<p>jwt 변수들에 대한 자세한 설정은 Rest Framework JWT 에서 확인 할 수 있다. 그리고 default 로 설정된 변수들을 재선언 하고 싶다면 setting 에 해주면 된다.</p>\n<p><a href=\"http://settings.py\" target=\"_blank\" rel=\"external\">settings.py</a></p>\n<figure class=\"highlight gcode\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">JWT_AUTH = &#123;</div><div class=\"line\">    <span class=\"string\">'JWT_EXPIRATION_DELTA'</span>: datetime.timedelta<span class=\"comment\">(hours=24)</span>,</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h4 id=\"쿠키에-저장하기\">쿠키에 저장하기</h4>\n<p>사용자가 입력한 아이디와 암호가 맞을 경우 이 정보를 cookie 에 저장을 한다. 저장할 때 domain option 을 main domain(<a href=\"http://mysite.com\" target=\"_blank\" rel=\"external\">mysite.com</a>) 로 설정해준다. domain 설정을 해주지 않을 경우 다른 사이트에서 쿠키정보를 공유할 수 없다.</p>\n<p><a href=\"http://view.py\" target=\"_blank\" rel=\"external\">view.py</a></p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">LoginView</span><span class=\"params\">(View)</span>:</span></div><div class=\"line\"> </div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">get</span><span class=\"params\">(self, request)</span>:</span></div><div class=\"line\">        <span class=\"keyword\">return</span> TemplateResponse(request, <span class=\"string\">'account/login.html'</span>)</div><div class=\"line\"> </div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">post</span><span class=\"params\">(self, request)</span>:</span></div><div class=\"line\">        username = request.POST.get(<span class=\"string\">'username'</span>)</div><div class=\"line\">        password = request.POST.get(<span class=\"string\">'password'</span>)</div><div class=\"line\"> </div><div class=\"line\">        <span class=\"keyword\">try</span>:</div><div class=\"line\">            admin = CustomUser.objects.get(username=username)</div><div class=\"line\">            <span class=\"comment\"># 유저 암호 검사하기.</span></div><div class=\"line\">            <span class=\"keyword\">if</span> security.matches_password(password, admin.password):</div><div class=\"line\">                <span class=\"comment\"># obtain jwt token</span></div><div class=\"line\">                token = obtain_token(admin)</div><div class=\"line\"> </div><div class=\"line\">                <span class=\"comment\"># set cookie</span></div><div class=\"line\">                response = HttpResponseRedirect(reverse(<span class=\"string\">'root'</span>))</div><div class=\"line\">                response.set_cookie(key=<span class=\"string\">'token'</span>, value=token, domain=settings.COOKIE_DOMAIN)</div><div class=\"line\">                <span class=\"keyword\">return</span> response</div><div class=\"line\">            <span class=\"keyword\">else</span>:</div><div class=\"line\">                context = &#123;</div><div class=\"line\">                    <span class=\"string\">'error'</span>: <span class=\"string\">'비밀번호가 일치하지 않습니다.'</span></div><div class=\"line\">                &#125;</div><div class=\"line\">        <span class=\"keyword\">except</span> TAdmin.DoesNotExist:</div><div class=\"line\">            context = &#123;</div><div class=\"line\">                <span class=\"string\">'error'</span>: <span class=\"string\">'존재하지 않는 ID입니다.'</span></div><div class=\"line\">            &#125;</div><div class=\"line\"> </div><div class=\"line\">        <span class=\"keyword\">return</span> TemplateResponse(request, <span class=\"string\">'account/login.html'</span>, context)</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>공통으로 사용할 메인 도메인 이름은 각 사이트 마다 통일 해줘야 한다.</p>\n<p><a href=\"http://settings.py\" target=\"_blank\" rel=\"external\">settings.py</a></p>\n<figure class=\"highlight ini\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"attr\">COOKIE_DOMAIN</span> = <span class=\"string\">'mysite.com'</span></div></pre></td></tr></table></figure>\n<p>쿠키에 토큰 값을 저장 했으므로 이제 각 사이트에 로그인 되었다고 할 수 있는 첫번 째 단계는 달성했다.</p>\n<h4 id=\"페이지-인증정보-확인하기\">페이지 인증정보 확인하기</h4>\n<p>로그인이 되어 있어야 접근할 수 있는 페이지의 경우 로그인 정보를 확인한 후에 정보를 로드한다. RestFramework 에서 제공하는 APIView 를 사용해서 인증 정보를 확인한다.</p>\n<p><a href=\"http://view.py\" target=\"_blank\" rel=\"external\">view.py</a></p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">RootView</span><span class=\"params\">(APIView)</span>:</span></div><div class=\"line\">    authentication_classes = (CustomAuthentication, )</div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">get</span><span class=\"params\">(self, request)</span>:</span></div><div class=\"line\">        <span class=\"string\">\"\"\"</span></div><div class=\"line\">        :param request:</div><div class=\"line\">        :return:</div><div class=\"line\">        \"\"\"</div><div class=\"line\">        redirect_url = <span class=\"string\">\"/home\"</span></div><div class=\"line\">        <span class=\"keyword\">return</span> HttpResponseRedirect(redirect_url)</div><div class=\"line\"></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>여기서 authentication class 를 명시적으로 선언해주었는데, 모든 APIView(인증과 허가가 필요한 페이지의 경우) 에 적용될 수 있도록 settings 에 선언해줄 수 있다.</p>\n<p>(인증 실패나 허가 요청 실패시 처리해줄 수 있는 핸들러도 미리 추가해놓자.)</p>\n<p><a href=\"http://settings.py\" target=\"_blank\" rel=\"external\">settings.py</a></p>\n<figure class=\"highlight roboconf\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">REST_FRAMEWORK = &#123;</div><div class=\"line\">    '<span class=\"attribute\">DEFAULT_AUTHENTICATION_CLASSES'</span>: (</div><div class=\"line\">        'common<span class=\"variable\">.utils</span><span class=\"variable\">.authentication</span><span class=\"variable\">.CustomAuthentication</span>',</div><div class=\"line\">    ),</div><div class=\"line\">    'EXCEPTION_HANDLER': 'common<span class=\"variable\">.utils</span><span class=\"variable\">.custom_exception_handler</span><span class=\"variable\">.custom_exception_handler</span>'</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>인증 확인은 쿠키에 저장되어 있는 토큰 정보로 확인한다. 토큰으로 정상적인 유저를 가져올 수 있다면 유효한 유저라고 판단한다.</p>\n<p><a href=\"http://authentication.py\" target=\"_blank\" rel=\"external\">authentication.py</a></p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">from</span> rest_framework <span class=\"keyword\">import</span> authentication</div><div class=\"line\"> </div><div class=\"line\"><span class=\"keyword\">from</span> common.utils.jwt_util <span class=\"keyword\">import</span> obtain_user</div><div class=\"line\"> </div><div class=\"line\"> </div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">CustomAuthentication</span><span class=\"params\">(authentication.BaseAuthentication)</span>:</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">authenticate</span><span class=\"params\">(self, request)</span>:</span></div><div class=\"line\">        <span class=\"string\">\"\"\"</span></div><div class=\"line\">        쿠키에 저장되어 있는 token 값으로 유저를 가져옵니다. 가져오는 상황에서 예외가 발생할 수 있으며 정상적으로 가져온 경우에는 인증된 유저라고 판단합니다.</div><div class=\"line\">        :param request:</div><div class=\"line\">        :return:</div><div class=\"line\">        \"\"\"</div><div class=\"line\">        token = request.COOKIES.get(<span class=\"string\">'token'</span>, <span class=\"keyword\">None</span>)</div><div class=\"line\">        user = obtain_user(token)</div><div class=\"line\">        <span class=\"keyword\">return</span> (user, <span class=\"keyword\">None</span>)</div></pre></td></tr></table></figure>\n<p>쿠키에 저장되어 있는 토큰을 decode 하여 유효한 정보인지를 판단한다.</p>\n<p>jwt_util.py</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">obtain_user</span><span class=\"params\">(token: str)</span>:</span></div><div class=\"line\">    <span class=\"string\">\"\"\"</span></div><div class=\"line\">    payload = &#123;'username': 'adm001', 'email': 'test@mysite.com', 'user_id': 1, 'exp': 1462187582&#125;</div><div class=\"line\">    :param token:</div><div class=\"line\">    :return:</div><div class=\"line\">    \"\"\"</div><div class=\"line\">    jwt_decode_handler = api_settings.JWT_DECODE_HANDLER</div><div class=\"line\">    jwt_get_username_from_payload = api_settings.JWT_PAYLOAD_GET_USERNAME_HANDLER</div><div class=\"line\"> </div><div class=\"line\">    <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> token <span class=\"keyword\">or</span> len(token) == <span class=\"number\">0</span>:  <span class=\"comment\"># case1: 토큰을 분실 했을 경우</span></div><div class=\"line\">        <span class=\"keyword\">raise</span> serializers.ValidationError(<span class=\"string\">'Invalid token header. Non credentials provided.'</span>)</div><div class=\"line\">        <span class=\"comment\"># raise exceptions.AuthenticationFailed(&#123;'error': 'Invalid token header. No credentials provided.'&#125;)</span></div><div class=\"line\"> </div><div class=\"line\">    <span class=\"keyword\">try</span>:</div><div class=\"line\">        payload = jwt_decode_handler(token)</div><div class=\"line\"> </div><div class=\"line\">    <span class=\"keyword\">except</span> jwt.ExpiredSignature:  <span class=\"comment\"># case2: 토큰이 만료되었을 경우</span></div><div class=\"line\">        <span class=\"keyword\">raise</span> serializers.ValidationError(<span class=\"string\">'Signature has expired.'</span>)</div><div class=\"line\">        <span class=\"comment\"># raise exceptions.AuthenticationFailed(&#123;'error': 'Signature has expired.'&#125;)</span></div><div class=\"line\">    <span class=\"keyword\">except</span> jwt.DecodeError:  <span class=\"comment\"># case3: 디코드 실패</span></div><div class=\"line\">        <span class=\"keyword\">raise</span> serializers.ValidationError(<span class=\"string\">'Error decoding signature.'</span>)</div><div class=\"line\">        <span class=\"comment\"># raise exceptions.AuthenticationFailed(&#123;'error': 'Error decoding signature.'&#125;)</span></div><div class=\"line\"> </div><div class=\"line\">    username = jwt_get_username_from_payload(payload)</div><div class=\"line\"> </div><div class=\"line\">    <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> username:  <span class=\"comment\"># case4: payload 가 잘못되어 username을 가져올 수 없는 경우</span></div><div class=\"line\">        <span class=\"keyword\">raise</span> serializers.ValidationError(<span class=\"string\">'Invalid payload.'</span>)</div><div class=\"line\">        <span class=\"comment\"># raise exceptions.AuthenticationFailed(&#123;'error': 'Invalid payload.'&#125;)</span></div><div class=\"line\"> </div><div class=\"line\">    <span class=\"keyword\">try</span>:</div><div class=\"line\">        user = CustomUser.objects.get(username=username)</div><div class=\"line\">    <span class=\"keyword\">except</span> CustomUser.DoesNotExist:  <span class=\"comment\"># case5: 해당 유저가 존재하지 않는 경우</span></div><div class=\"line\">        <span class=\"keyword\">raise</span> serializers.ValidationError(<span class=\"string\">\"User doesn't exists.\"</span>)</div><div class=\"line\">        <span class=\"comment\"># raise exceptions.AuthenticationFailed(&#123;'error': \"User doesn't exists.\"&#125;)</span></div><div class=\"line\"> </div><div class=\"line\">    <span class=\"keyword\">return</span> user</div></pre></td></tr></table></figure>\n<p>여러 이유로 인증에 실패할 경우엔 인증 실패 예외가 발생하게 되는데 이는 따로 핸들러로 처리해주어야 한다. (에러 정보는 response.data 에 담겨온다.)<br>\n(여기서는 인증 실패 예외가 발생할 경우 쿠키에 저장되어 있는 토큰값을 지워버리고 로그인 페이지로 보내버린다.)</p>\n<p>custom_exception_handler.py</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">from</span> django.conf <span class=\"keyword\">import</span> settings</div><div class=\"line\"><span class=\"keyword\">from</span> django.core.urlresolvers <span class=\"keyword\">import</span> reverse</div><div class=\"line\"><span class=\"keyword\">from</span> django.http <span class=\"keyword\">import</span> HttpResponseRedirect</div><div class=\"line\"><span class=\"keyword\">from</span> rest_framework <span class=\"keyword\">import</span> status</div><div class=\"line\"><span class=\"keyword\">from</span> rest_framework.views <span class=\"keyword\">import</span> exception_handler</div><div class=\"line\"> </div><div class=\"line\"> </div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">custom_exception_handler</span><span class=\"params\">(exc, context)</span>:</span></div><div class=\"line\">    <span class=\"comment\"># 발생한 exception을 가져온다.</span></div><div class=\"line\">    response = exception_handler(exc, context)</div><div class=\"line\"> </div><div class=\"line\">    <span class=\"keyword\">if</span> response <span class=\"keyword\">is</span> <span class=\"keyword\">not</span> <span class=\"keyword\">None</span>:</div><div class=\"line\">        <span class=\"comment\"># response_data = response.data['detail']</span></div><div class=\"line\">        <span class=\"comment\"># print('response : ', response.__dict__)</span></div><div class=\"line\"> </div><div class=\"line\">        <span class=\"comment\"># 예외가 발생할 경우엔 token쿠키를 지워준다</span></div><div class=\"line\">        response.delete_cookie(<span class=\"string\">'token'</span>, domain=settings.COOKIE_DOMAIN)</div><div class=\"line\"> </div><div class=\"line\">        <span class=\"keyword\">return</span> HttpResponseRedirect(reverse(<span class=\"string\">'login'</span>))</div><div class=\"line\">    <span class=\"keyword\">else</span>:</div><div class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">None</span></div></pre></td></tr></table></figure>\n<h4 id=\"페이지-접근-허가-정보-확인하기\">페이지 접근 허가 정보 확인하기</h4>\n<p>접근하고자 하는 페이지가 각 유저별로 인증 정보가 필요하다면 유저의 인증 정보를 확인할 수 있어야 한다.</p>\n<p><a href=\"http://permission.py\" target=\"_blank\" rel=\"external\">permission.py</a></p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">from</span> rest_framework.permissions <span class=\"keyword\">import</span> BasePermission</div><div class=\"line\"> </div><div class=\"line\"> </div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">CustomPermission</span><span class=\"params\">(BasePermission)</span>:</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">has_permission</span><span class=\"params\">(self, request, view)</span>:</span></div><div class=\"line\">        <span class=\"comment\"># <span class=\"doctag\">TODO:</span> do something</span></div><div class=\"line\">        print(<span class=\"string\">'CustomPermission user : '</span>, request.user)</div><div class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">True</span></div></pre></td></tr></table></figure>\n<p>(현재는 어떤 허가 정보도 판단하지 않지만 이 부분에서 유저 정보를 가지고 해당 페이지에 대한 허가 정보를 판단해서 boolean 값으로 반환해준다. True일 경우 허가된 경우고 False일 경우엔 허가되지 않는 유저이다.)</p>\n<p>APIView 에서 허가 정보도 명시적으로 선언해서 확인할 수 있다.</p>\n<p><a href=\"http://view.py\" target=\"_blank\" rel=\"external\">view.py</a></p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">RootView</span><span class=\"params\">(APIView)</span>:</span></div><div class=\"line\">    authentication_classes = (CustomAuthentication, )</div><div class=\"line\">    permission_classes = (CustomPermission, )</div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">get</span><span class=\"params\">(self, request)</span>:</span></div><div class=\"line\">        <span class=\"string\">\"\"\"</span></div><div class=\"line\">        :param request:</div><div class=\"line\">        :return:</div><div class=\"line\">        \"\"\"</div><div class=\"line\">        redirect_url = <span class=\"string\">\"/home\"</span></div><div class=\"line\">        <span class=\"keyword\">return</span> HttpResponseRedirect(redirect_url)</div></pre></td></tr></table></figure>\n<p>마찬가지로 모든 APIView 에서 허가 정보를 확인해야 한다면 settings 에 설정해줄 수 있다. 좀 전에 인증 정보를 작성한 부분에 추가해주자.</p>\n<p><a href=\"http://settings.py\" target=\"_blank\" rel=\"external\">settings.py</a></p>\n<figure class=\"highlight roboconf\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">REST_FRAMEWORK = &#123;</div><div class=\"line\">    '<span class=\"attribute\">DEFAULT_AUTHENTICATION_CLASSES'</span>: (</div><div class=\"line\">        'common<span class=\"variable\">.utils</span><span class=\"variable\">.authentication</span><span class=\"variable\">.CustomAuthentication</span>',</div><div class=\"line\">    ),</div><div class=\"line\">    'DEFAULT_PERMISSION_CLASSES': (</div><div class=\"line\">        'common<span class=\"variable\">.utils</span><span class=\"variable\">.permission</span><span class=\"variable\">.CustomPermission</span>',</div><div class=\"line\">    ),</div><div class=\"line\">    'EXCEPTION_HANDLER': 'common<span class=\"variable\">.utils</span><span class=\"variable\">.custom_exception_handler</span><span class=\"variable\">.custom_exception_handler</span>'</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>허가 요청에 대한 부분이 추가되었으므로 예외 처리 핸들러에서 이 부분에 대한 처리도 추가해줘야 한다. 요청이 실패할 경우 403 에러가 발생하는데 이 부분에 대한 처리를 해준다.</p>\n<p>custom_exception_handler.py</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">from</span> django.conf <span class=\"keyword\">import</span> settings</div><div class=\"line\"><span class=\"keyword\">from</span> django.core.urlresolvers <span class=\"keyword\">import</span> reverse</div><div class=\"line\"><span class=\"keyword\">from</span> django.http <span class=\"keyword\">import</span> HttpResponseRedirect</div><div class=\"line\"><span class=\"keyword\">from</span> rest_framework <span class=\"keyword\">import</span> status</div><div class=\"line\"><span class=\"keyword\">from</span> rest_framework.views <span class=\"keyword\">import</span> exception_handler</div><div class=\"line\"> </div><div class=\"line\"> </div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">custom_exception_handler</span><span class=\"params\">(exc, context)</span>:</span></div><div class=\"line\">    <span class=\"comment\"># 발생한 exception을 가져온다.</span></div><div class=\"line\">    response = exception_handler(exc, context)</div><div class=\"line\"> </div><div class=\"line\">    <span class=\"keyword\">if</span> response <span class=\"keyword\">is</span> <span class=\"keyword\">not</span> <span class=\"keyword\">None</span>:</div><div class=\"line\">        <span class=\"comment\"># response_data = response.data['detail']</span></div><div class=\"line\">        <span class=\"comment\"># print('response : ', response.__dict__)</span></div><div class=\"line\"> </div><div class=\"line\">        <span class=\"comment\"># permission 이 안되는 경우엔 block page 로 넘겨준다.</span></div><div class=\"line\">        <span class=\"keyword\">if</span> response.status_code == status.HTTP_403_FORBIDDEN:</div><div class=\"line\">            <span class=\"keyword\">return</span> HttpResponseRedirect(reverse(<span class=\"string\">'block'</span>))</div><div class=\"line\"> </div><div class=\"line\">        <span class=\"comment\"># 예외가 발생할 경우엔 token쿠키를 지워준다</span></div><div class=\"line\">        response.delete_cookie(<span class=\"string\">'token'</span>, domain=settings.COOKIE_DOMAIN)</div><div class=\"line\"> </div><div class=\"line\">        <span class=\"keyword\">return</span> HttpResponseRedirect(reverse(<span class=\"string\">'login'</span>))</div><div class=\"line\">    <span class=\"keyword\">else</span>:</div><div class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">None</span></div></pre></td></tr></table></figure>\n<p>인증 실패인 경우에는 쿠키에서 토큰 정보를 삭제하고<br>\n로그인 페이지로 보내버리고,<br>\n허가 요청 거부일 경우에는 block 페이지로 보내버렸는데,<br>\n이 부분은 각 사이트의 상황에 맞게 처리해주면 된다.</p>\n<h4 id=\"로그아웃-하기\">로그아웃 하기</h4>\n<p>로그아웃은 간단하다. 단지 쿠키에 저장되어 있는 토큰 값을 지워버리면 되기 때문이다.</p>\n<p><a href=\"http://view.py\" target=\"_blank\" rel=\"external\">view.py</a></p>\n<figure class=\"highlight ruby\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">LogoutView</span>(<span class=\"title\">View</span>):</span></div><div class=\"line\"> </div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">get</span><span class=\"params\">(<span class=\"keyword\">self</span>, request)</span></span>:</div><div class=\"line\">        response = HttpResponseRedirect(reverse(<span class=\"string\">'login'</span>))</div><div class=\"line\">        response.delete_cookie(<span class=\"string\">'token'</span>, domain=settings.COOKIE_DOMAIN)</div><div class=\"line\">        <span class=\"keyword\">return</span> response</div></pre></td></tr></table></figure>\n<h4 id=\"요약\">요약</h4>\n<p>지금까지 추가된 파일들과 클래스를 정리하자면 다음과 같다.</p>\n<figure class=\"highlight haml\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">common/utils/custom_exception_handler.py</div><div class=\"line\">    -<span class=\"ruby\"> custom_exception_handler</span></div><div class=\"line\">common/utils/authentication.py</div><div class=\"line\">    -<span class=\"ruby\"> CustomAuthentication</span></div><div class=\"line\">common/utils/permission.py</div><div class=\"line\">    -<span class=\"ruby\"> CustomerPermission</span></div><div class=\"line\">common/utils/jwt_util.py</div><div class=\"line\">    -<span class=\"ruby\"> obtain_token</span></div><div class=\"line\">    -<span class=\"ruby\"> obtain_user</span></div></pre></td></tr></table></figure>\n<p>여기까지 따라왔다면 sso를 완성 할 수 있다. 하나의 사이트에서 동작하는지 여부를 검사하고 싶다면 hosts 에 도메인을 추가해서 테스트 해보자.</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> sudo vim /etc/hosts</span></div></pre></td></tr></table></figure>\n<p>/etc/hosts</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">127<span class=\"selector-class\">.0</span><span class=\"selector-class\">.0</span><span class=\"selector-class\">.1</span>   <span class=\"selector-tag\">alpha</span><span class=\"selector-class\">.mysite</span><span class=\"selector-class\">.com</span></div><div class=\"line\">127<span class=\"selector-class\">.0</span><span class=\"selector-class\">.0</span><span class=\"selector-class\">.1</span>   <span class=\"selector-tag\">beta</span><span class=\"selector-class\">.mysite</span><span class=\"selector-class\">.com</span></div></pre></td></tr></table></figure>\n<p>위와 같이 추가하고 테스트를 해볼 수 있다.</p>\n<h2 id=\"결론\">결론</h2>\n<p>유저의 로그인 검증 후 유저 정보를 jwt 를 이용해서 토큰을 생성한 후, 이 정보는 메인 도메인으로 쿠키에 저장을 한다. 인증이 필요한 페이지의 경우 cookie 에 저장되어 있는 토큰으로 인증된 유저인지 여부를 판단한다. 이 때, 이 토큰 값이 유효하지 않을 경우엔 강제로 로그아웃 처리를 한다. jwt 토큰의 만료 시간을 주어 일정 시간이 지나면 로그인이 풀리도록 했다. 메인 도메인 하위의 3개의 사이트중 하나의 사이트에서만 로그인을 하면 나머지 두개의 사이트에서도 로그인이 되어 있다(같은 쿠키의 토큰을 사용하기 때문)</p>\n<h3 id=\"추신\">추신</h3>\n<p>나름 간단하게 기능을 구현하고자 했는데 로그인 정보를 저장하고 그 토큰을 처리하기 위해 여러 처리가 붙었다. 그리고 토큰 값을 만들고 검증하고 이를 인증하는 코드들을 직접 쓰다보니 조금은 번거로운 작업들이 포함되어 있는 건 사실이다… 때로는 오픈소스를 별다른 이해 없이 기능을 사용하기 위해 가져다 쓰는 것 보다 내부 로직을 이해하고 내가 필요한 부분들만 가져다 쓰는 작업을 하면 재미있기도 하고 후에 문제가 생기거나 기능 변경이 생겼을 때 대처가 빠르다. 물론 이런 방식이 정답을 아닐지는 몰라도 덕분에 재미있는 작업을 했다는 점에 만족한다.</p>\n","site":{"data":{}},"excerpt":"","more":"<p>회사에서 필요에 의해 <a href=\"https://ko.wikipedia.org/wiki/%ED%86%B5%ED%95%A9_%EC%9D%B8%EC%A6%9D,\" title=\"Single Sign On\" target=\"_blank\" rel=\"external\">Single Sign On</a>을 구현해야 할 일이 있었다. 3개의 독립된 사이트가 있었고, 각자 로그인을 따로 해야 한다는 점이 사용자 입장에서는 번거로운 일이 될 수 있다는 이유에서 였다.</p>\n<p>3개의 사이트는 하나의 유저테이블을 바라보고 있었기 때문에 충분히 합당한 이유였다. 하지만 django에서 제공하는 기본 유저 테이블을 사용하지 않기 때문에 찾아봤었던 다른 인증 툴들은 그대로 사용하기 까다로워 보였다. 내가 구현해야 하는 상황에는 몇가지 제약사항이 있었다.</p>\n<ol>\n<li>\n<p>로그인을 시도할 때 기존에 제공되는 auth_user 테이블이 아닌 <u>별도의 user 테이블을 사용하고 있다.</u></p>\n</li>\n<li>\n<p>기존에 제공되는 user 모델을 사용하지 않기 때문에 <u>reatframework 에서 기존에 제공하는 인증방식을 그대로 사용할 수 없었다.</u></p>\n</li>\n<li>\n<p>이미 테이블이 존재하고 <u>django 프로젝트에서 migration 을 할 수 없는 상황이다.</u> 기존에 생성되어 있는 테이블들의 구성을 변경할 수는 있지만 그 과정과 절차가 까다롭고 (회사의 사정에 의해), 외래키를 사용하지 않았기 때문에 모델과 테이블간의 100% 싱크가 맞지 않는 상황이었다.</p>\n</li>\n<li>\n<p>위와 같은 이유로 찾아봤었던 <a href=\"https://github.com/jbittel/django-mama-cas,\" title=\"MamaCas\" target=\"_blank\" rel=\"external\">MamaCAS</a> 같은 외부 인증툴을 사용할 수 없었다. (migration을 할 수 없었기에 인증을 위해 별도의 테이블을 생성하기 까다로운 상황이었다.)</p>\n</li>\n</ol>\n<p>3개의 프로젝트들이 출시가 얼마 남지 않은 상황이고, 인증을 위해서 별도의 커다란 작업이 있는 것은 별로 좋은 선택이 아니였다. 물론 외부의 다른 툴들을 이용할 수도 있었지만, 단순 인증을 위해 외부툴을 사용하기엔 부담스러운 부분이 있었고, 볼륨을 크게 잡고 싶지 않았다.</p>\n<p>여러 방법을 찾아보면서 몇가지 아이디어가 나왔었다.</p>\n<ol>\n<li>\n<p><a href=\"https://redis.io/,\" title=\"redis\" target=\"_blank\" rel=\"external\">redis</a> 를 이용해서 인증 정보를 저장하는 방식</p>\n</li>\n<li>\n<p><a href=\"https://jwt.io/,\" title=\"jwt\" target=\"_blank\" rel=\"external\">jwt</a>를 이용해서 javascript 내부에서 localStorage 에 인증 정보를 저장하는 방식</p>\n</li>\n<li>\n<p>cookie에 저장하는 방식</p>\n</li>\n</ol>\n<p>나는 일단 1번의 redis는 제외하기로 했다. 이미 각각의 프로젝트에서 redis를 사용하고 있었고, 인증을 위해 별도의 redis를 띄우는게 번거롭다고 생각했다. 그리고 2번의 localStorage 방식은 javascript에서 ajax통신을 각 페이지별로 날려 유효한 인증을 판단하는 방식이었는데, django 단에서 각 request마다 헤더에 인증 정보를 넣기가 까다로웠다. (하지만 jwt로 토큰을 암호화 하는건 괜찮은 방법이라 생각했다.) 3번의 cookie 방식은 별도의 작업 없이 구현이 가능했지만 3개의 사이트가 같은 메인 도메인 하에 있어야 가능했었다. 어차피 모든 사이트가 회사 내부에서 사용할 목적으로 만들어 지고 있는 프로젝트 였고 같은 메인 도메인만 사용하면 되었기 때문에 나는 3번째의 방법을 사용하기로 했다.</p>\n<p>서론이 길었지만… 그리하여 jwt와 cookie를 이용해서 sso를 구현해 보기로 했다.</p>\n<p>여러 사이트가 있고 각각 로그인(유저 인증)이 필요하고 기능 마다 해당 유저가 접근할 수 있는(허가) 기능이 필요하다.</p>\n<p>(single sign on 을 하다보니 authentication 과 permission 처리가 필요했다…)</p>\n<p>여러 개의 사이트가 공유하는 유저 정보가 있고, 이 정보로 로그인을 하기 때문에 모든 사이트에서 한번의 로그인을 하면 되는 기능이 필요했다.추가적으로 각 사이트 별로는 각자의 허가 정보가 있으므로 이 정보는 공유하지 않고 각자 구현한다. (템플릿만 제공)</p>\n<p>한마디로 요약하면 쿠키에 암호화된 토큰 정보를 도메인이 같은 사이트들끼리 로그인 정보를 공유를 해서 사용하는 방법이다.</p>\n<h2>예상 시나리오</h2>\n<p><a href=\"http://alpha.mysite.com\" target=\"_blank\" rel=\"external\">alpha.mysite.com</a>, <a href=\"http://beta.mysite.com\" target=\"_blank\" rel=\"external\">beta.mysite.com</a>, <a href=\"http://charlie.mysite.com\" target=\"_blank\" rel=\"external\">charlie.mysite.com</a> 3개의 사이트가 있다.<br>\nbeta 에서 로그인을 하고 charlie 사이트에 접속할 경우 이미 로그인이 되어 있다.<br>\n3개의 사이트는 각자 permission 이 따로 존재한다.<br>\nalpha 에서 로그아웃을 할 경우, 나머지 사이트에서도 모두 로그아웃이 된다.<br>\n로그인 정보가 만료되었을 경우에도 로그아웃 처리된다.</p>\n<h2>시나리오 순서 별 설명</h2>\n<ol>\n<li>로그인 시 : <u>jwt token</u> 을 발급해서 request cookie에 저장한다. (이 때, <u>cookie</u> 의 domain은 main domain 값을 넣어준다.&lt;<a href=\"http://mysite.com\" target=\"_blank\" rel=\"external\">mysite.com</a>&gt;)</li>\n<li>인증이 필요한 페이지에 접속할 경우<br>\nrest framework 의 <u>authentication</u> class 에서 cookie 에 저장되어 있는 token 값의 유효성을 검사한다.<br>\nrest framework 의 <u>permission</u> class 에서 해당 유저가 기능에 접근 허가 여부를 판단한다.</li>\n<li>로그아웃 시 : cookie 의 token 값을 지워준다.</li>\n<li>추가 정보\n<ul>\n<li>인증에 실패한 경우 : cookie 값을 삭제하고 login 페이지로 보낸다.</li>\n<li>기능 접근 허가가 거부된 경우 : block page 를 표시한다.</li>\n<li>토큰이 만료된 경우 : cookie 값을 삭제하고 login 페이지로 보낸다.</li>\n</ul>\n</li>\n<li>제약사항\n<ul>\n<li>메인 도메인이 동일해야한다.</li>\n<li>permission 정보는 공유하지 않기 때문에 각자 사이트에서 구현해야 한다.</li>\n</ul>\n</li>\n</ol>\n<h2>환경 설정</h2>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"selector-tag\">python</span> 3<span class=\"selector-class\">.4</span><span class=\"selector-class\">.3</span></div><div class=\"line\"><span class=\"selector-tag\">django</span> 1<span class=\"selector-class\">.8</span><span class=\"selector-class\">.4</span></div><div class=\"line\"><span class=\"selector-tag\">djangorestframework</span> 3<span class=\"selector-class\">.3</span><span class=\"selector-class\">.0</span></div></pre></td></tr></table></figure>\n<p>하나씩 시작해보자.</p>\n<h3>패키지 추가하기</h3>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> pip install djangorestframework-jwt</span></div></pre></td></tr></table></figure>\n<h3>로그인 하기</h3>\n<h4>토큰 생성하기</h4>\n<p>유저 정보가 맞을 경우 이 정보를 토대로 jwt token을 생성해준다.<br>\njwt_util.py</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">from</span> calendar <span class=\"keyword\">import</span> timegm</div><div class=\"line\"><span class=\"keyword\">from</span> datetime <span class=\"keyword\">import</span> datetime</div><div class=\"line\"> </div><div class=\"line\"><span class=\"keyword\">import</span> jwt</div><div class=\"line\"><span class=\"keyword\">from</span> rest_framework_jwt.settings <span class=\"keyword\">import</span> api_settings</div><div class=\"line\"> </div><div class=\"line\"><span class=\"keyword\">from</span> user.models.CustomUser <span class=\"keyword\">import</span> CustomUser</div><div class=\"line\"> </div><div class=\"line\"> </div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">obtain_token</span><span class=\"params\">(user: CustomUser)</span>:</span></div><div class=\"line\">    jwt_payload_handler = api_settings.JWT_PAYLOAD_HANDLER</div><div class=\"line\">    jwt_encode_handler = api_settings.JWT_ENCODE_HANDLER</div><div class=\"line\"> </div><div class=\"line\">    payload = jwt_payload_handler(user)</div><div class=\"line\"> </div><div class=\"line\">    <span class=\"comment\"># Include original issued at time for a brand new token,</span></div><div class=\"line\">    <span class=\"comment\"># to allow token refresh</span></div><div class=\"line\">    <span class=\"keyword\">if</span> api_settings.JWT_ALLOW_REFRESH:</div><div class=\"line\">        payload[<span class=\"string\">'orig_iat'</span>] = timegm(</div><div class=\"line\">            datetime.utcnow().utctimetuple()</div><div class=\"line\">        )</div><div class=\"line\"> </div><div class=\"line\">    <span class=\"keyword\">return</span> jwt_encode_handler(payload)</div></pre></td></tr></table></figure>\n<p>jwt 변수들에 대한 자세한 설정은 Rest Framework JWT 에서 확인 할 수 있다. 그리고 default 로 설정된 변수들을 재선언 하고 싶다면 setting 에 해주면 된다.</p>\n<p><a href=\"http://settings.py\" target=\"_blank\" rel=\"external\">settings.py</a></p>\n<figure class=\"highlight gcode\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">JWT_AUTH = &#123;</div><div class=\"line\">    <span class=\"string\">'JWT_EXPIRATION_DELTA'</span>: datetime.timedelta<span class=\"comment\">(hours=24)</span>,</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h4>쿠키에 저장하기</h4>\n<p>사용자가 입력한 아이디와 암호가 맞을 경우 이 정보를 cookie 에 저장을 한다. 저장할 때 domain option 을 main domain(<a href=\"http://mysite.com\" target=\"_blank\" rel=\"external\">mysite.com</a>) 로 설정해준다. domain 설정을 해주지 않을 경우 다른 사이트에서 쿠키정보를 공유할 수 없다.</p>\n<p><a href=\"http://view.py\" target=\"_blank\" rel=\"external\">view.py</a></p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">LoginView</span><span class=\"params\">(View)</span>:</span></div><div class=\"line\"> </div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">get</span><span class=\"params\">(self, request)</span>:</span></div><div class=\"line\">        <span class=\"keyword\">return</span> TemplateResponse(request, <span class=\"string\">'account/login.html'</span>)</div><div class=\"line\"> </div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">post</span><span class=\"params\">(self, request)</span>:</span></div><div class=\"line\">        username = request.POST.get(<span class=\"string\">'username'</span>)</div><div class=\"line\">        password = request.POST.get(<span class=\"string\">'password'</span>)</div><div class=\"line\"> </div><div class=\"line\">        <span class=\"keyword\">try</span>:</div><div class=\"line\">            admin = CustomUser.objects.get(username=username)</div><div class=\"line\">            <span class=\"comment\"># 유저 암호 검사하기.</span></div><div class=\"line\">            <span class=\"keyword\">if</span> security.matches_password(password, admin.password):</div><div class=\"line\">                <span class=\"comment\"># obtain jwt token</span></div><div class=\"line\">                token = obtain_token(admin)</div><div class=\"line\"> </div><div class=\"line\">                <span class=\"comment\"># set cookie</span></div><div class=\"line\">                response = HttpResponseRedirect(reverse(<span class=\"string\">'root'</span>))</div><div class=\"line\">                response.set_cookie(key=<span class=\"string\">'token'</span>, value=token, domain=settings.COOKIE_DOMAIN)</div><div class=\"line\">                <span class=\"keyword\">return</span> response</div><div class=\"line\">            <span class=\"keyword\">else</span>:</div><div class=\"line\">                context = &#123;</div><div class=\"line\">                    <span class=\"string\">'error'</span>: <span class=\"string\">'비밀번호가 일치하지 않습니다.'</span></div><div class=\"line\">                &#125;</div><div class=\"line\">        <span class=\"keyword\">except</span> TAdmin.DoesNotExist:</div><div class=\"line\">            context = &#123;</div><div class=\"line\">                <span class=\"string\">'error'</span>: <span class=\"string\">'존재하지 않는 ID입니다.'</span></div><div class=\"line\">            &#125;</div><div class=\"line\"> </div><div class=\"line\">        <span class=\"keyword\">return</span> TemplateResponse(request, <span class=\"string\">'account/login.html'</span>, context)</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>공통으로 사용할 메인 도메인 이름은 각 사이트 마다 통일 해줘야 한다.</p>\n<p><a href=\"http://settings.py\" target=\"_blank\" rel=\"external\">settings.py</a></p>\n<figure class=\"highlight ini\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"attr\">COOKIE_DOMAIN</span> = <span class=\"string\">'mysite.com'</span></div></pre></td></tr></table></figure>\n<p>쿠키에 토큰 값을 저장 했으므로 이제 각 사이트에 로그인 되었다고 할 수 있는 첫번 째 단계는 달성했다.</p>\n<h4>페이지 인증정보 확인하기</h4>\n<p>로그인이 되어 있어야 접근할 수 있는 페이지의 경우 로그인 정보를 확인한 후에 정보를 로드한다. RestFramework 에서 제공하는 APIView 를 사용해서 인증 정보를 확인한다.</p>\n<p><a href=\"http://view.py\" target=\"_blank\" rel=\"external\">view.py</a></p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">RootView</span><span class=\"params\">(APIView)</span>:</span></div><div class=\"line\">    authentication_classes = (CustomAuthentication, )</div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">get</span><span class=\"params\">(self, request)</span>:</span></div><div class=\"line\">        <span class=\"string\">\"\"\"</span></div><div class=\"line\">        :param request:</div><div class=\"line\">        :return:</div><div class=\"line\">        \"\"\"</div><div class=\"line\">        redirect_url = <span class=\"string\">\"/home\"</span></div><div class=\"line\">        <span class=\"keyword\">return</span> HttpResponseRedirect(redirect_url)</div><div class=\"line\"></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>여기서 authentication class 를 명시적으로 선언해주었는데, 모든 APIView(인증과 허가가 필요한 페이지의 경우) 에 적용될 수 있도록 settings 에 선언해줄 수 있다.</p>\n<p>(인증 실패나 허가 요청 실패시 처리해줄 수 있는 핸들러도 미리 추가해놓자.)</p>\n<p><a href=\"http://settings.py\" target=\"_blank\" rel=\"external\">settings.py</a></p>\n<figure class=\"highlight roboconf\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">REST_FRAMEWORK = &#123;</div><div class=\"line\">    '<span class=\"attribute\">DEFAULT_AUTHENTICATION_CLASSES'</span>: (</div><div class=\"line\">        'common<span class=\"variable\">.utils</span><span class=\"variable\">.authentication</span><span class=\"variable\">.CustomAuthentication</span>',</div><div class=\"line\">    ),</div><div class=\"line\">    'EXCEPTION_HANDLER': 'common<span class=\"variable\">.utils</span><span class=\"variable\">.custom_exception_handler</span><span class=\"variable\">.custom_exception_handler</span>'</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>인증 확인은 쿠키에 저장되어 있는 토큰 정보로 확인한다. 토큰으로 정상적인 유저를 가져올 수 있다면 유효한 유저라고 판단한다.</p>\n<p><a href=\"http://authentication.py\" target=\"_blank\" rel=\"external\">authentication.py</a></p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">from</span> rest_framework <span class=\"keyword\">import</span> authentication</div><div class=\"line\"> </div><div class=\"line\"><span class=\"keyword\">from</span> common.utils.jwt_util <span class=\"keyword\">import</span> obtain_user</div><div class=\"line\"> </div><div class=\"line\"> </div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">CustomAuthentication</span><span class=\"params\">(authentication.BaseAuthentication)</span>:</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">authenticate</span><span class=\"params\">(self, request)</span>:</span></div><div class=\"line\">        <span class=\"string\">\"\"\"</span></div><div class=\"line\">        쿠키에 저장되어 있는 token 값으로 유저를 가져옵니다. 가져오는 상황에서 예외가 발생할 수 있으며 정상적으로 가져온 경우에는 인증된 유저라고 판단합니다.</div><div class=\"line\">        :param request:</div><div class=\"line\">        :return:</div><div class=\"line\">        \"\"\"</div><div class=\"line\">        token = request.COOKIES.get(<span class=\"string\">'token'</span>, <span class=\"keyword\">None</span>)</div><div class=\"line\">        user = obtain_user(token)</div><div class=\"line\">        <span class=\"keyword\">return</span> (user, <span class=\"keyword\">None</span>)</div></pre></td></tr></table></figure>\n<p>쿠키에 저장되어 있는 토큰을 decode 하여 유효한 정보인지를 판단한다.</p>\n<p>jwt_util.py</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">obtain_user</span><span class=\"params\">(token: str)</span>:</span></div><div class=\"line\">    <span class=\"string\">\"\"\"</span></div><div class=\"line\">    payload = &#123;'username': 'adm001', 'email': 'test@mysite.com', 'user_id': 1, 'exp': 1462187582&#125;</div><div class=\"line\">    :param token:</div><div class=\"line\">    :return:</div><div class=\"line\">    \"\"\"</div><div class=\"line\">    jwt_decode_handler = api_settings.JWT_DECODE_HANDLER</div><div class=\"line\">    jwt_get_username_from_payload = api_settings.JWT_PAYLOAD_GET_USERNAME_HANDLER</div><div class=\"line\"> </div><div class=\"line\">    <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> token <span class=\"keyword\">or</span> len(token) == <span class=\"number\">0</span>:  <span class=\"comment\"># case1: 토큰을 분실 했을 경우</span></div><div class=\"line\">        <span class=\"keyword\">raise</span> serializers.ValidationError(<span class=\"string\">'Invalid token header. Non credentials provided.'</span>)</div><div class=\"line\">        <span class=\"comment\"># raise exceptions.AuthenticationFailed(&#123;'error': 'Invalid token header. No credentials provided.'&#125;)</span></div><div class=\"line\"> </div><div class=\"line\">    <span class=\"keyword\">try</span>:</div><div class=\"line\">        payload = jwt_decode_handler(token)</div><div class=\"line\"> </div><div class=\"line\">    <span class=\"keyword\">except</span> jwt.ExpiredSignature:  <span class=\"comment\"># case2: 토큰이 만료되었을 경우</span></div><div class=\"line\">        <span class=\"keyword\">raise</span> serializers.ValidationError(<span class=\"string\">'Signature has expired.'</span>)</div><div class=\"line\">        <span class=\"comment\"># raise exceptions.AuthenticationFailed(&#123;'error': 'Signature has expired.'&#125;)</span></div><div class=\"line\">    <span class=\"keyword\">except</span> jwt.DecodeError:  <span class=\"comment\"># case3: 디코드 실패</span></div><div class=\"line\">        <span class=\"keyword\">raise</span> serializers.ValidationError(<span class=\"string\">'Error decoding signature.'</span>)</div><div class=\"line\">        <span class=\"comment\"># raise exceptions.AuthenticationFailed(&#123;'error': 'Error decoding signature.'&#125;)</span></div><div class=\"line\"> </div><div class=\"line\">    username = jwt_get_username_from_payload(payload)</div><div class=\"line\"> </div><div class=\"line\">    <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> username:  <span class=\"comment\"># case4: payload 가 잘못되어 username을 가져올 수 없는 경우</span></div><div class=\"line\">        <span class=\"keyword\">raise</span> serializers.ValidationError(<span class=\"string\">'Invalid payload.'</span>)</div><div class=\"line\">        <span class=\"comment\"># raise exceptions.AuthenticationFailed(&#123;'error': 'Invalid payload.'&#125;)</span></div><div class=\"line\"> </div><div class=\"line\">    <span class=\"keyword\">try</span>:</div><div class=\"line\">        user = CustomUser.objects.get(username=username)</div><div class=\"line\">    <span class=\"keyword\">except</span> CustomUser.DoesNotExist:  <span class=\"comment\"># case5: 해당 유저가 존재하지 않는 경우</span></div><div class=\"line\">        <span class=\"keyword\">raise</span> serializers.ValidationError(<span class=\"string\">\"User doesn't exists.\"</span>)</div><div class=\"line\">        <span class=\"comment\"># raise exceptions.AuthenticationFailed(&#123;'error': \"User doesn't exists.\"&#125;)</span></div><div class=\"line\"> </div><div class=\"line\">    <span class=\"keyword\">return</span> user</div></pre></td></tr></table></figure>\n<p>여러 이유로 인증에 실패할 경우엔 인증 실패 예외가 발생하게 되는데 이는 따로 핸들러로 처리해주어야 한다. (에러 정보는 response.data 에 담겨온다.)<br>\n(여기서는 인증 실패 예외가 발생할 경우 쿠키에 저장되어 있는 토큰값을 지워버리고 로그인 페이지로 보내버린다.)</p>\n<p>custom_exception_handler.py</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">from</span> django.conf <span class=\"keyword\">import</span> settings</div><div class=\"line\"><span class=\"keyword\">from</span> django.core.urlresolvers <span class=\"keyword\">import</span> reverse</div><div class=\"line\"><span class=\"keyword\">from</span> django.http <span class=\"keyword\">import</span> HttpResponseRedirect</div><div class=\"line\"><span class=\"keyword\">from</span> rest_framework <span class=\"keyword\">import</span> status</div><div class=\"line\"><span class=\"keyword\">from</span> rest_framework.views <span class=\"keyword\">import</span> exception_handler</div><div class=\"line\"> </div><div class=\"line\"> </div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">custom_exception_handler</span><span class=\"params\">(exc, context)</span>:</span></div><div class=\"line\">    <span class=\"comment\"># 발생한 exception을 가져온다.</span></div><div class=\"line\">    response = exception_handler(exc, context)</div><div class=\"line\"> </div><div class=\"line\">    <span class=\"keyword\">if</span> response <span class=\"keyword\">is</span> <span class=\"keyword\">not</span> <span class=\"keyword\">None</span>:</div><div class=\"line\">        <span class=\"comment\"># response_data = response.data['detail']</span></div><div class=\"line\">        <span class=\"comment\"># print('response : ', response.__dict__)</span></div><div class=\"line\"> </div><div class=\"line\">        <span class=\"comment\"># 예외가 발생할 경우엔 token쿠키를 지워준다</span></div><div class=\"line\">        response.delete_cookie(<span class=\"string\">'token'</span>, domain=settings.COOKIE_DOMAIN)</div><div class=\"line\"> </div><div class=\"line\">        <span class=\"keyword\">return</span> HttpResponseRedirect(reverse(<span class=\"string\">'login'</span>))</div><div class=\"line\">    <span class=\"keyword\">else</span>:</div><div class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">None</span></div></pre></td></tr></table></figure>\n<h4>페이지 접근 허가 정보 확인하기</h4>\n<p>접근하고자 하는 페이지가 각 유저별로 인증 정보가 필요하다면 유저의 인증 정보를 확인할 수 있어야 한다.</p>\n<p><a href=\"http://permission.py\" target=\"_blank\" rel=\"external\">permission.py</a></p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">from</span> rest_framework.permissions <span class=\"keyword\">import</span> BasePermission</div><div class=\"line\"> </div><div class=\"line\"> </div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">CustomPermission</span><span class=\"params\">(BasePermission)</span>:</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">has_permission</span><span class=\"params\">(self, request, view)</span>:</span></div><div class=\"line\">        <span class=\"comment\"># <span class=\"doctag\">TODO:</span> do something</span></div><div class=\"line\">        print(<span class=\"string\">'CustomPermission user : '</span>, request.user)</div><div class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">True</span></div></pre></td></tr></table></figure>\n<p>(현재는 어떤 허가 정보도 판단하지 않지만 이 부분에서 유저 정보를 가지고 해당 페이지에 대한 허가 정보를 판단해서 boolean 값으로 반환해준다. True일 경우 허가된 경우고 False일 경우엔 허가되지 않는 유저이다.)</p>\n<p>APIView 에서 허가 정보도 명시적으로 선언해서 확인할 수 있다.</p>\n<p><a href=\"http://view.py\" target=\"_blank\" rel=\"external\">view.py</a></p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">RootView</span><span class=\"params\">(APIView)</span>:</span></div><div class=\"line\">    authentication_classes = (CustomAuthentication, )</div><div class=\"line\">    permission_classes = (CustomPermission, )</div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">get</span><span class=\"params\">(self, request)</span>:</span></div><div class=\"line\">        <span class=\"string\">\"\"\"</span></div><div class=\"line\">        :param request:</div><div class=\"line\">        :return:</div><div class=\"line\">        \"\"\"</div><div class=\"line\">        redirect_url = <span class=\"string\">\"/home\"</span></div><div class=\"line\">        <span class=\"keyword\">return</span> HttpResponseRedirect(redirect_url)</div></pre></td></tr></table></figure>\n<p>마찬가지로 모든 APIView 에서 허가 정보를 확인해야 한다면 settings 에 설정해줄 수 있다. 좀 전에 인증 정보를 작성한 부분에 추가해주자.</p>\n<p><a href=\"http://settings.py\" target=\"_blank\" rel=\"external\">settings.py</a></p>\n<figure class=\"highlight roboconf\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">REST_FRAMEWORK = &#123;</div><div class=\"line\">    '<span class=\"attribute\">DEFAULT_AUTHENTICATION_CLASSES'</span>: (</div><div class=\"line\">        'common<span class=\"variable\">.utils</span><span class=\"variable\">.authentication</span><span class=\"variable\">.CustomAuthentication</span>',</div><div class=\"line\">    ),</div><div class=\"line\">    'DEFAULT_PERMISSION_CLASSES': (</div><div class=\"line\">        'common<span class=\"variable\">.utils</span><span class=\"variable\">.permission</span><span class=\"variable\">.CustomPermission</span>',</div><div class=\"line\">    ),</div><div class=\"line\">    'EXCEPTION_HANDLER': 'common<span class=\"variable\">.utils</span><span class=\"variable\">.custom_exception_handler</span><span class=\"variable\">.custom_exception_handler</span>'</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>허가 요청에 대한 부분이 추가되었으므로 예외 처리 핸들러에서 이 부분에 대한 처리도 추가해줘야 한다. 요청이 실패할 경우 403 에러가 발생하는데 이 부분에 대한 처리를 해준다.</p>\n<p>custom_exception_handler.py</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">from</span> django.conf <span class=\"keyword\">import</span> settings</div><div class=\"line\"><span class=\"keyword\">from</span> django.core.urlresolvers <span class=\"keyword\">import</span> reverse</div><div class=\"line\"><span class=\"keyword\">from</span> django.http <span class=\"keyword\">import</span> HttpResponseRedirect</div><div class=\"line\"><span class=\"keyword\">from</span> rest_framework <span class=\"keyword\">import</span> status</div><div class=\"line\"><span class=\"keyword\">from</span> rest_framework.views <span class=\"keyword\">import</span> exception_handler</div><div class=\"line\"> </div><div class=\"line\"> </div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">custom_exception_handler</span><span class=\"params\">(exc, context)</span>:</span></div><div class=\"line\">    <span class=\"comment\"># 발생한 exception을 가져온다.</span></div><div class=\"line\">    response = exception_handler(exc, context)</div><div class=\"line\"> </div><div class=\"line\">    <span class=\"keyword\">if</span> response <span class=\"keyword\">is</span> <span class=\"keyword\">not</span> <span class=\"keyword\">None</span>:</div><div class=\"line\">        <span class=\"comment\"># response_data = response.data['detail']</span></div><div class=\"line\">        <span class=\"comment\"># print('response : ', response.__dict__)</span></div><div class=\"line\"> </div><div class=\"line\">        <span class=\"comment\"># permission 이 안되는 경우엔 block page 로 넘겨준다.</span></div><div class=\"line\">        <span class=\"keyword\">if</span> response.status_code == status.HTTP_403_FORBIDDEN:</div><div class=\"line\">            <span class=\"keyword\">return</span> HttpResponseRedirect(reverse(<span class=\"string\">'block'</span>))</div><div class=\"line\"> </div><div class=\"line\">        <span class=\"comment\"># 예외가 발생할 경우엔 token쿠키를 지워준다</span></div><div class=\"line\">        response.delete_cookie(<span class=\"string\">'token'</span>, domain=settings.COOKIE_DOMAIN)</div><div class=\"line\"> </div><div class=\"line\">        <span class=\"keyword\">return</span> HttpResponseRedirect(reverse(<span class=\"string\">'login'</span>))</div><div class=\"line\">    <span class=\"keyword\">else</span>:</div><div class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">None</span></div></pre></td></tr></table></figure>\n<p>인증 실패인 경우에는 쿠키에서 토큰 정보를 삭제하고<br>\n로그인 페이지로 보내버리고,<br>\n허가 요청 거부일 경우에는 block 페이지로 보내버렸는데,<br>\n이 부분은 각 사이트의 상황에 맞게 처리해주면 된다.</p>\n<h4>로그아웃 하기</h4>\n<p>로그아웃은 간단하다. 단지 쿠키에 저장되어 있는 토큰 값을 지워버리면 되기 때문이다.</p>\n<p><a href=\"http://view.py\" target=\"_blank\" rel=\"external\">view.py</a></p>\n<figure class=\"highlight ruby\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">LogoutView</span>(<span class=\"title\">View</span>):</span></div><div class=\"line\"> </div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">get</span><span class=\"params\">(<span class=\"keyword\">self</span>, request)</span></span>:</div><div class=\"line\">        response = HttpResponseRedirect(reverse(<span class=\"string\">'login'</span>))</div><div class=\"line\">        response.delete_cookie(<span class=\"string\">'token'</span>, domain=settings.COOKIE_DOMAIN)</div><div class=\"line\">        <span class=\"keyword\">return</span> response</div></pre></td></tr></table></figure>\n<h4>요약</h4>\n<p>지금까지 추가된 파일들과 클래스를 정리하자면 다음과 같다.</p>\n<figure class=\"highlight haml\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">common/utils/custom_exception_handler.py</div><div class=\"line\">    -<span class=\"ruby\"> custom_exception_handler</span></div><div class=\"line\">common/utils/authentication.py</div><div class=\"line\">    -<span class=\"ruby\"> CustomAuthentication</span></div><div class=\"line\">common/utils/permission.py</div><div class=\"line\">    -<span class=\"ruby\"> CustomerPermission</span></div><div class=\"line\">common/utils/jwt_util.py</div><div class=\"line\">    -<span class=\"ruby\"> obtain_token</span></div><div class=\"line\">    -<span class=\"ruby\"> obtain_user</span></div></pre></td></tr></table></figure>\n<p>여기까지 따라왔다면 sso를 완성 할 수 있다. 하나의 사이트에서 동작하는지 여부를 검사하고 싶다면 hosts 에 도메인을 추가해서 테스트 해보자.</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> sudo vim /etc/hosts</span></div></pre></td></tr></table></figure>\n<p>/etc/hosts</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">127<span class=\"selector-class\">.0</span><span class=\"selector-class\">.0</span><span class=\"selector-class\">.1</span>   <span class=\"selector-tag\">alpha</span><span class=\"selector-class\">.mysite</span><span class=\"selector-class\">.com</span></div><div class=\"line\">127<span class=\"selector-class\">.0</span><span class=\"selector-class\">.0</span><span class=\"selector-class\">.1</span>   <span class=\"selector-tag\">beta</span><span class=\"selector-class\">.mysite</span><span class=\"selector-class\">.com</span></div></pre></td></tr></table></figure>\n<p>위와 같이 추가하고 테스트를 해볼 수 있다.</p>\n<h2>결론</h2>\n<p>유저의 로그인 검증 후 유저 정보를 jwt 를 이용해서 토큰을 생성한 후, 이 정보는 메인 도메인으로 쿠키에 저장을 한다. 인증이 필요한 페이지의 경우 cookie 에 저장되어 있는 토큰으로 인증된 유저인지 여부를 판단한다. 이 때, 이 토큰 값이 유효하지 않을 경우엔 강제로 로그아웃 처리를 한다. jwt 토큰의 만료 시간을 주어 일정 시간이 지나면 로그인이 풀리도록 했다. 메인 도메인 하위의 3개의 사이트중 하나의 사이트에서만 로그인을 하면 나머지 두개의 사이트에서도 로그인이 되어 있다(같은 쿠키의 토큰을 사용하기 때문)</p>\n<h3>추신</h3>\n<p>나름 간단하게 기능을 구현하고자 했는데 로그인 정보를 저장하고 그 토큰을 처리하기 위해 여러 처리가 붙었다. 그리고 토큰 값을 만들고 검증하고 이를 인증하는 코드들을 직접 쓰다보니 조금은 번거로운 작업들이 포함되어 있는 건 사실이다… 때로는 오픈소스를 별다른 이해 없이 기능을 사용하기 위해 가져다 쓰는 것 보다 내부 로직을 이해하고 내가 필요한 부분들만 가져다 쓰는 작업을 하면 재미있기도 하고 후에 문제가 생기거나 기능 변경이 생겼을 때 대처가 빠르다. 물론 이런 방식이 정답을 아닐지는 몰라도 덕분에 재미있는 작업을 했다는 점에 만족한다.</p>\n"},{"title":"Python에서 iOS, Android 스토어 인앱 결제 검증하기","catalog":true,"date":"2016-03-11T07:43:24.000Z","subtitle":null,"header-img":null,"_content":"Django framework를 이용해서 프로젝트를 만들면서 했던 여러가지 삽질들과 넘어야했던 많은 산들과 몰랐던 부분들에 대해서 내 나름 공부 겸 기록을 위해 남겨둬야 겠다는 생각이 들었다. 프로젝트로 한창 바빴던 시기에는 당장 앞에 놓여진 일들에 치여 이런 생각을 못하고 있다가 지금은 조금 여유가 되어 그 때 있었던 일들에 대한 나름의 경험을 기록해보고자 한다.\n\n그 중에 한가지가 인앱 아이템 결제하기 였다. 나는 예전에 cocos2d-x로 게임을 개발했던 시절엔 결제 프로세스를 클라이언트(단말기)사이드만 알고 있었고 서버사이드의 로직은 전혀 모르고 있었는데, 오히려 이번에 서버 로직을 구현하면서 그 때 그 시절의 경험이 많은 도움이 되었다. 앱 내에 아이템을 구매하고 구매한 아이템을 유저에게 잘 넣어주는 로직이야 구현방식도 다양하고 여러 기교들이 들어가 있는데 오늘은 그 중에서 나름 간단한(?) 파트인 두 플랫폼의 결제 영수증 검증 로직의 삽질 경험을 적어보고자 한다.\n\n이번에 대응했던 클라이언트는 google play store와 iOS app store 두개의 플랫폼이다. 차례차례 훑어보자.\n각 플랫폼별 스토어의 앱 등록과 각종 키발급 같은 내용은 다루지 않고 순수하게 영수증 검증만을 볼 것이다.\n\n1. google In-app billing\n구글 결제 영수증 검증의 경우 생각보다 단순해서 처음에는 이게 맞나? 싶었다. 일반적으로 생각하기에는 구글의 결제서버에 영수증 정보를 넘겨 유효한 영수증인지 여부를 판단해서 진행이 되는줄 알았는데(이렇게 하는 방법도 있다고 한다.), 훨씬 간단한 방법이 있었다. 암호화된 영수증 정보를 클라이언트로 부터 받아와서 local에서 검증하는 방식이다.\n\n일단 pip를 이용해서 Crypto 라이브러리를 설치하도록 하자.\n\n```\npip install pycrypto\n```\n \n\n다음은 영수증 검증 코드이다. signed_data 는 안드로이드 결제완료시 넘어온 암호화된 영수증 문자열이고 signature는 클라이언트와 약속된 특정 문자열이다. 안드로이드에서 결제를 요청할 당시 이 값을 함께 넘겨주면 signed_data 내부에 이 signature 값이 심어들어가게 되고, 복호화를 하면 이 값이 풀어져 나와 영수증 검증을 할 수 있다.\n\n```\nfrom base64 import b64decode\nfrom Crypto.Hash import SHA\nfrom Crypto.PublicKey import RSA\nfrom Crypto.Signature import PKCS1_v1_5\n\n# Your base64 encoded public key from Google Play.\nPUBLIC_KEY_BASE64 = 'YOUR_PUBLIC_KEY_BASE64'\n\ndef verify_for_google(signed_data, signature):\n    \"\"\"Returns whether the given data was signed with the private key.\"\"\"\n    key = RSA.importKey(_pem_format(PUBLIC_KEY_BASE64))\n    verifier = PKCS1_v1_5.new(key)\n    data = SHA.new(signed_data.encode('utf8'))\n    sig = b64decode(signature)\n\n    return verifier.verify(data, sig)\n\n\ndef _pem_format(key):\n    return '\\n'.join([\n        '-----BEGIN PUBLIC KEY-----',\n        '\\n'.join(_chunks(key, 64)),\n        '-----END PUBLIC KEY-----'\n    ])\n\n\ndef _chunks(s, n):\n    for start in range(0, len(s), n):\n        yield s[start:start+n]\n```\n\n\n먼저 스토어에서 발급받은 공개키가 필요하다. 이 키를 이용해 넘어온 데이터가 유효한지 여부를 판단할 수 있다.\n1. RSA 암호 방식으로 암호화가 되어 있기 때문에 PUBLIC KEY 를 이용해 key객체를 생성한다.\n2. PKCS(Public Key Cryptography Standard)를 이용해서 암호화된 영수증을 검증 할것이다. 1번에서 만들어진 key를 이용해 verifier 객체를 생성하자.\n3. SHA(Secure Hash Algorithm)으로 된 signed_data를 객체로 생성한다.\n4. signature 를 decode 한다.\n5. 2번에서 생성한 verifier를 통해 data 와 sig 의 유효성을 판단한다. 유효한 영수증은 True 그렇지 않으면 False 를 반환한다.\n이 부분에 대해서는 좀 더 공부가 필요해 보인다.. 현재는 암호화에 대한 꼭지들이 의미하는 바를 인지해야겠지만 이들이 어떤 작업을 하는지에 대한 공부도 반드시 필요할 것이다.\n코드 내용이 그리 간단하지는 않지만 비교적 빠르게 구글 영수증 검증을 할 수 있었다. 구글의 개발자 사이트를 들어가 이런 저런 글도 읽오보고 여러 포스팅을 찾아보면서 여러가지 자료를 봐왔었는데 stackoverflow 에서 찾은 글들을 추려 간단하게 메소드로 정리했다. 내가 여기서 삽질 했던 부분은 대체 signed_data 와 signature 가 무엇을 뜻하는지 알 수가 없었다는 점이였다. 대부분의 자료들에서는 저 둘이 무엇을 의미하는지 자세히 기술을 해놓지 않거나 아예 어떤 값을 의미하는지를 써놓지 않은 글들이 많았다. 나도 처음에는 이리저리 고민을 해보다가 일단 맨땅에 헤딩을 하고보자는 마음으로 여러 땅에 삽집을 하다가 찾은 결과물이다.\n\n\n2. iOS in-app purchase\n이번에는 iOS결제 영수증 검증을 해보도록 하자. apple은 구글과는 다르게 결제 서버에 영수증을 보내서 넘어온 값을 통해 영수증의 유효성을 판단한다. 직접 apple의 결제 api를 호출해서 검증을 해도 되지만 역시나 Python은 있을만하다고 생각하는 라이브러리는 이미 존재하거나 누군가가 만들어 놨다. 우리는 이 라이브러리를 만든분 께 감사를 드리며 코드를 받아가도록 하자.\n\n```\npip install itunes-iap\n```\n\nitunes-iap를 설치하면 의존성 라이브러리들이 이것저것 왕창 설치된다. 궁금하면 ($pip list 를 통해 확인해볼것)\n이번에는 iOS 영수증 검증 코드를 보도록 하자. 이 때 transaction_id 는 결제 당시 결과값으로 오는 구매 영수증 id이고, raw_data는 암호화된 영수증 문자열이다. \n\n```\nimport itunesiap\n\ndef _verify_for_ios(transaction_id: str, raw_data: str):\n    \"\"\"\n    seeAlso : https://developer.apple.com/library/ios/releasenotes/General/ValidateAppStoreReceipt/Chapters/ValidateRemotely.html\n    :param transaction_id: 결제 transaction_id\n    :param raw_data: base64-encoded data\n    :return: boolean\n    :raises: Otherwise raise a request exception (RuntimeError, itunesiap.exc.InvalidReceipt)\n    \"\"\"\n    try:\n        # for sandbox environment.\n        #     with itunesiap.env.sandbox:\n        #         response = itunesiap.verify(raw_data)\n\n        # for production environment. (default)\n        response = itunesiap.verify(raw_data)  # base64-encoded data\n\n        def _get_key(re):\n            \"\"\" 영수증리스트에서 비교 키를 반환합니다. \"\"\"\n            return re.purchase_date_ms\n\n        # 넘어온 in_app 영수증 리스트에서 구매 시각이 가장 마지막인 영수증을 가져와서 transaction_id를 비교한다.\n        # 오름 차순으로 정렬해서 구매시각이 가장 마지막 영수증을 가져옵니다.\n        receipts = sorted(response.receipt.in_app, key=_get_key)\n        last_receipt = receipts[len(receipts) - 1]\n        if last_receipt.transaction_id != transaction_id:\n            #  구매시각이 가장 마지막인 영수증의 transaction_id 가 일치 하지 않는다.\n            return False\n\n        return response.status == 0\n```\n\niOS 영수증 유효성 검증은 간단하다. itunesiap.verify 메소드를 통해 iOS에서 넘어온 데이터를 넣고 호출하면 복호화된 영수증 데이터가 나온다. 이 때 status 값이 0 이라면 유효한 영수증이라고 판단한다. 뭔가 apple다운 api라고 생각한다. 처음 iOS영수증 검증을 할 당시엔 verify 메소드만 호출하고 그 뒤에 넘어온 데이터의 status 값만 확인하고 유효성을 검증했다. \n여기서 나의 삽질이 시작되었다. \n\n1. 일단 주석에서 보는것과 같이 sandbox환경과 real환경일 때에 호출하는 api가 다르다. itunesiap의 환경을 설정을 해주는 방법은 여러가지가 있다. 각자 개발환경에서 영수증 유효성을 검사할 때엔 sandbox와 real환경을 잘 구분해서 api를 호출해주도록 하자. 아무리 유효한 영수증이라 할지라도 틀린 환경의 api를 호출하면 유효하지 않다고 판단하기 때문이다. \n\n2. 보통 verify 메소드를 호출하면 receipt 값 안에 하나의 영수증 정보만 가져온다. 하지만 특정 상황의 경우 receipt 데이터 안에 1개 이상의 영수증 정보가 딸려 오는 경우가 있다. 이 때에 한가지 데이터만이 유효한 영수증 값이다. 이 중에서 한가지 영수증만을 가지고 검증을 해야 하는데 여러 삽질 후에 깨달은 바는 receipt 안의 데이터들의 purchase_date_ms 값을 이용해 가장 마지막에 결제된 영수증 정보가 파라메터로 넘어온 transaction_id 와 동일하다는 점을 알게 되었다. 그래서 _get_key 메소드를 통해 receipt 리스트를 정렬하고, 그 중에 가장 마지막 영수증 정보를 뽑아 transaction_id 가 같은지 여부를 판단한다. \n\n자 이제 우리는 python을 이용해서 android, iOS의 영수증을 검증할 수 있게 되었다. 간단하지도 복잡하지도 않고, 몰랐을 때는 어려워 난해했지만 알고나니 더 난해한 비교적 간단하게 할 수 있는 파트였다. 이제 어디가서 이 두 플랫폼의 결제 영수증쯤은 아무렇지도 않게 검증 할 수 있다고 당당히 얘기하자.\n\n\n","source":"_posts/store-inapp-in-python.md","raw":"---\ntitle: \"Python에서 iOS, Android 스토어 인앱 결제 검증하기\"\ncatalog: true\ndate: 2016-03-11 16:43:24\nsubtitle:\nheader-img:\ntags:\n- python\n- ios\n- android\n- inapp\n---\nDjango framework를 이용해서 프로젝트를 만들면서 했던 여러가지 삽질들과 넘어야했던 많은 산들과 몰랐던 부분들에 대해서 내 나름 공부 겸 기록을 위해 남겨둬야 겠다는 생각이 들었다. 프로젝트로 한창 바빴던 시기에는 당장 앞에 놓여진 일들에 치여 이런 생각을 못하고 있다가 지금은 조금 여유가 되어 그 때 있었던 일들에 대한 나름의 경험을 기록해보고자 한다.\n\n그 중에 한가지가 인앱 아이템 결제하기 였다. 나는 예전에 cocos2d-x로 게임을 개발했던 시절엔 결제 프로세스를 클라이언트(단말기)사이드만 알고 있었고 서버사이드의 로직은 전혀 모르고 있었는데, 오히려 이번에 서버 로직을 구현하면서 그 때 그 시절의 경험이 많은 도움이 되었다. 앱 내에 아이템을 구매하고 구매한 아이템을 유저에게 잘 넣어주는 로직이야 구현방식도 다양하고 여러 기교들이 들어가 있는데 오늘은 그 중에서 나름 간단한(?) 파트인 두 플랫폼의 결제 영수증 검증 로직의 삽질 경험을 적어보고자 한다.\n\n이번에 대응했던 클라이언트는 google play store와 iOS app store 두개의 플랫폼이다. 차례차례 훑어보자.\n각 플랫폼별 스토어의 앱 등록과 각종 키발급 같은 내용은 다루지 않고 순수하게 영수증 검증만을 볼 것이다.\n\n1. google In-app billing\n구글 결제 영수증 검증의 경우 생각보다 단순해서 처음에는 이게 맞나? 싶었다. 일반적으로 생각하기에는 구글의 결제서버에 영수증 정보를 넘겨 유효한 영수증인지 여부를 판단해서 진행이 되는줄 알았는데(이렇게 하는 방법도 있다고 한다.), 훨씬 간단한 방법이 있었다. 암호화된 영수증 정보를 클라이언트로 부터 받아와서 local에서 검증하는 방식이다.\n\n일단 pip를 이용해서 Crypto 라이브러리를 설치하도록 하자.\n\n```\npip install pycrypto\n```\n \n\n다음은 영수증 검증 코드이다. signed_data 는 안드로이드 결제완료시 넘어온 암호화된 영수증 문자열이고 signature는 클라이언트와 약속된 특정 문자열이다. 안드로이드에서 결제를 요청할 당시 이 값을 함께 넘겨주면 signed_data 내부에 이 signature 값이 심어들어가게 되고, 복호화를 하면 이 값이 풀어져 나와 영수증 검증을 할 수 있다.\n\n```\nfrom base64 import b64decode\nfrom Crypto.Hash import SHA\nfrom Crypto.PublicKey import RSA\nfrom Crypto.Signature import PKCS1_v1_5\n\n# Your base64 encoded public key from Google Play.\nPUBLIC_KEY_BASE64 = 'YOUR_PUBLIC_KEY_BASE64'\n\ndef verify_for_google(signed_data, signature):\n    \"\"\"Returns whether the given data was signed with the private key.\"\"\"\n    key = RSA.importKey(_pem_format(PUBLIC_KEY_BASE64))\n    verifier = PKCS1_v1_5.new(key)\n    data = SHA.new(signed_data.encode('utf8'))\n    sig = b64decode(signature)\n\n    return verifier.verify(data, sig)\n\n\ndef _pem_format(key):\n    return '\\n'.join([\n        '-----BEGIN PUBLIC KEY-----',\n        '\\n'.join(_chunks(key, 64)),\n        '-----END PUBLIC KEY-----'\n    ])\n\n\ndef _chunks(s, n):\n    for start in range(0, len(s), n):\n        yield s[start:start+n]\n```\n\n\n먼저 스토어에서 발급받은 공개키가 필요하다. 이 키를 이용해 넘어온 데이터가 유효한지 여부를 판단할 수 있다.\n1. RSA 암호 방식으로 암호화가 되어 있기 때문에 PUBLIC KEY 를 이용해 key객체를 생성한다.\n2. PKCS(Public Key Cryptography Standard)를 이용해서 암호화된 영수증을 검증 할것이다. 1번에서 만들어진 key를 이용해 verifier 객체를 생성하자.\n3. SHA(Secure Hash Algorithm)으로 된 signed_data를 객체로 생성한다.\n4. signature 를 decode 한다.\n5. 2번에서 생성한 verifier를 통해 data 와 sig 의 유효성을 판단한다. 유효한 영수증은 True 그렇지 않으면 False 를 반환한다.\n이 부분에 대해서는 좀 더 공부가 필요해 보인다.. 현재는 암호화에 대한 꼭지들이 의미하는 바를 인지해야겠지만 이들이 어떤 작업을 하는지에 대한 공부도 반드시 필요할 것이다.\n코드 내용이 그리 간단하지는 않지만 비교적 빠르게 구글 영수증 검증을 할 수 있었다. 구글의 개발자 사이트를 들어가 이런 저런 글도 읽오보고 여러 포스팅을 찾아보면서 여러가지 자료를 봐왔었는데 stackoverflow 에서 찾은 글들을 추려 간단하게 메소드로 정리했다. 내가 여기서 삽질 했던 부분은 대체 signed_data 와 signature 가 무엇을 뜻하는지 알 수가 없었다는 점이였다. 대부분의 자료들에서는 저 둘이 무엇을 의미하는지 자세히 기술을 해놓지 않거나 아예 어떤 값을 의미하는지를 써놓지 않은 글들이 많았다. 나도 처음에는 이리저리 고민을 해보다가 일단 맨땅에 헤딩을 하고보자는 마음으로 여러 땅에 삽집을 하다가 찾은 결과물이다.\n\n\n2. iOS in-app purchase\n이번에는 iOS결제 영수증 검증을 해보도록 하자. apple은 구글과는 다르게 결제 서버에 영수증을 보내서 넘어온 값을 통해 영수증의 유효성을 판단한다. 직접 apple의 결제 api를 호출해서 검증을 해도 되지만 역시나 Python은 있을만하다고 생각하는 라이브러리는 이미 존재하거나 누군가가 만들어 놨다. 우리는 이 라이브러리를 만든분 께 감사를 드리며 코드를 받아가도록 하자.\n\n```\npip install itunes-iap\n```\n\nitunes-iap를 설치하면 의존성 라이브러리들이 이것저것 왕창 설치된다. 궁금하면 ($pip list 를 통해 확인해볼것)\n이번에는 iOS 영수증 검증 코드를 보도록 하자. 이 때 transaction_id 는 결제 당시 결과값으로 오는 구매 영수증 id이고, raw_data는 암호화된 영수증 문자열이다. \n\n```\nimport itunesiap\n\ndef _verify_for_ios(transaction_id: str, raw_data: str):\n    \"\"\"\n    seeAlso : https://developer.apple.com/library/ios/releasenotes/General/ValidateAppStoreReceipt/Chapters/ValidateRemotely.html\n    :param transaction_id: 결제 transaction_id\n    :param raw_data: base64-encoded data\n    :return: boolean\n    :raises: Otherwise raise a request exception (RuntimeError, itunesiap.exc.InvalidReceipt)\n    \"\"\"\n    try:\n        # for sandbox environment.\n        #     with itunesiap.env.sandbox:\n        #         response = itunesiap.verify(raw_data)\n\n        # for production environment. (default)\n        response = itunesiap.verify(raw_data)  # base64-encoded data\n\n        def _get_key(re):\n            \"\"\" 영수증리스트에서 비교 키를 반환합니다. \"\"\"\n            return re.purchase_date_ms\n\n        # 넘어온 in_app 영수증 리스트에서 구매 시각이 가장 마지막인 영수증을 가져와서 transaction_id를 비교한다.\n        # 오름 차순으로 정렬해서 구매시각이 가장 마지막 영수증을 가져옵니다.\n        receipts = sorted(response.receipt.in_app, key=_get_key)\n        last_receipt = receipts[len(receipts) - 1]\n        if last_receipt.transaction_id != transaction_id:\n            #  구매시각이 가장 마지막인 영수증의 transaction_id 가 일치 하지 않는다.\n            return False\n\n        return response.status == 0\n```\n\niOS 영수증 유효성 검증은 간단하다. itunesiap.verify 메소드를 통해 iOS에서 넘어온 데이터를 넣고 호출하면 복호화된 영수증 데이터가 나온다. 이 때 status 값이 0 이라면 유효한 영수증이라고 판단한다. 뭔가 apple다운 api라고 생각한다. 처음 iOS영수증 검증을 할 당시엔 verify 메소드만 호출하고 그 뒤에 넘어온 데이터의 status 값만 확인하고 유효성을 검증했다. \n여기서 나의 삽질이 시작되었다. \n\n1. 일단 주석에서 보는것과 같이 sandbox환경과 real환경일 때에 호출하는 api가 다르다. itunesiap의 환경을 설정을 해주는 방법은 여러가지가 있다. 각자 개발환경에서 영수증 유효성을 검사할 때엔 sandbox와 real환경을 잘 구분해서 api를 호출해주도록 하자. 아무리 유효한 영수증이라 할지라도 틀린 환경의 api를 호출하면 유효하지 않다고 판단하기 때문이다. \n\n2. 보통 verify 메소드를 호출하면 receipt 값 안에 하나의 영수증 정보만 가져온다. 하지만 특정 상황의 경우 receipt 데이터 안에 1개 이상의 영수증 정보가 딸려 오는 경우가 있다. 이 때에 한가지 데이터만이 유효한 영수증 값이다. 이 중에서 한가지 영수증만을 가지고 검증을 해야 하는데 여러 삽질 후에 깨달은 바는 receipt 안의 데이터들의 purchase_date_ms 값을 이용해 가장 마지막에 결제된 영수증 정보가 파라메터로 넘어온 transaction_id 와 동일하다는 점을 알게 되었다. 그래서 _get_key 메소드를 통해 receipt 리스트를 정렬하고, 그 중에 가장 마지막 영수증 정보를 뽑아 transaction_id 가 같은지 여부를 판단한다. \n\n자 이제 우리는 python을 이용해서 android, iOS의 영수증을 검증할 수 있게 되었다. 간단하지도 복잡하지도 않고, 몰랐을 때는 어려워 난해했지만 알고나니 더 난해한 비교적 간단하게 할 수 있는 파트였다. 이제 어디가서 이 두 플랫폼의 결제 영수증쯤은 아무렇지도 않게 검증 할 수 있다고 당당히 얘기하자.\n\n\n","slug":"store-inapp-in-python","published":1,"updated":"2017-06-09T07:45:49.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj3r0l3hq00069fhhlwgr5zrq","content":"<p>Django framework를 이용해서 프로젝트를 만들면서 했던 여러가지 삽질들과 넘어야했던 많은 산들과 몰랐던 부분들에 대해서 내 나름 공부 겸 기록을 위해 남겨둬야 겠다는 생각이 들었다. 프로젝트로 한창 바빴던 시기에는 당장 앞에 놓여진 일들에 치여 이런 생각을 못하고 있다가 지금은 조금 여유가 되어 그 때 있었던 일들에 대한 나름의 경험을 기록해보고자 한다.</p>\n<p>그 중에 한가지가 인앱 아이템 결제하기 였다. 나는 예전에 cocos2d-x로 게임을 개발했던 시절엔 결제 프로세스를 클라이언트(단말기)사이드만 알고 있었고 서버사이드의 로직은 전혀 모르고 있었는데, 오히려 이번에 서버 로직을 구현하면서 그 때 그 시절의 경험이 많은 도움이 되었다. 앱 내에 아이템을 구매하고 구매한 아이템을 유저에게 잘 넣어주는 로직이야 구현방식도 다양하고 여러 기교들이 들어가 있는데 오늘은 그 중에서 나름 간단한(?) 파트인 두 플랫폼의 결제 영수증 검증 로직의 삽질 경험을 적어보고자 한다.</p>\n<p>이번에 대응했던 클라이언트는 google play store와 iOS app store 두개의 플랫폼이다. 차례차례 훑어보자.<br>\n각 플랫폼별 스토어의 앱 등록과 각종 키발급 같은 내용은 다루지 않고 순수하게 영수증 검증만을 볼 것이다.</p>\n<ol>\n<li>google In-app billing<br>\n구글 결제 영수증 검증의 경우 생각보다 단순해서 처음에는 이게 맞나? 싶었다. 일반적으로 생각하기에는 구글의 결제서버에 영수증 정보를 넘겨 유효한 영수증인지 여부를 판단해서 진행이 되는줄 알았는데(이렇게 하는 방법도 있다고 한다.), 훨씬 간단한 방법이 있었다. 암호화된 영수증 정보를 클라이언트로 부터 받아와서 local에서 검증하는 방식이다.</li>\n</ol>\n<p>일단 pip를 이용해서 Crypto 라이브러리를 설치하도록 하자.</p>\n<figure class=\"highlight cmake\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">pip <span class=\"keyword\">install</span> pycrypto</div></pre></td></tr></table></figure>\n<p>다음은 영수증 검증 코드이다. signed_data 는 안드로이드 결제완료시 넘어온 암호화된 영수증 문자열이고 signature는 클라이언트와 약속된 특정 문자열이다. 안드로이드에서 결제를 요청할 당시 이 값을 함께 넘겨주면 signed_data 내부에 이 signature 값이 심어들어가게 되고, 복호화를 하면 이 값이 풀어져 나와 영수증 검증을 할 수 있다.</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">from</span> base64 <span class=\"keyword\">import</span> b64decode</div><div class=\"line\"><span class=\"keyword\">from</span> Crypto.Hash <span class=\"keyword\">import</span> SHA</div><div class=\"line\"><span class=\"keyword\">from</span> Crypto.PublicKey <span class=\"keyword\">import</span> RSA</div><div class=\"line\"><span class=\"keyword\">from</span> Crypto.Signature <span class=\"keyword\">import</span> PKCS1_v1_5</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\"># Your base64 encoded public key from Google Play.</span></div><div class=\"line\">PUBLIC_KEY_BASE64 = <span class=\"string\">'YOUR_PUBLIC_KEY_BASE64'</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">verify_for_google</span><span class=\"params\">(signed_data, signature)</span>:</span></div><div class=\"line\">    <span class=\"string\">\"\"\"Returns whether the given data was signed with the private key.\"\"\"</span></div><div class=\"line\">    key = RSA.importKey(_pem_format(PUBLIC_KEY_BASE64))</div><div class=\"line\">    verifier = PKCS1_v1_5.new(key)</div><div class=\"line\">    data = SHA.new(signed_data.encode(<span class=\"string\">'utf8'</span>))</div><div class=\"line\">    sig = b64decode(signature)</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">return</span> verifier.verify(data, sig)</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">_pem_format</span><span class=\"params\">(key)</span>:</span></div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">'\\n'</span>.join([</div><div class=\"line\">        <span class=\"string\">'-----BEGIN PUBLIC KEY-----'</span>,</div><div class=\"line\">        <span class=\"string\">'\\n'</span>.join(_chunks(key, <span class=\"number\">64</span>)),</div><div class=\"line\">        <span class=\"string\">'-----END PUBLIC KEY-----'</span></div><div class=\"line\">    ])</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">_chunks</span><span class=\"params\">(s, n)</span>:</span></div><div class=\"line\">    <span class=\"keyword\">for</span> start <span class=\"keyword\">in</span> range(<span class=\"number\">0</span>, len(s), n):</div><div class=\"line\">        <span class=\"keyword\">yield</span> s[start:start+n]</div></pre></td></tr></table></figure>\n<p>먼저 스토어에서 발급받은 공개키가 필요하다. 이 키를 이용해 넘어온 데이터가 유효한지 여부를 판단할 수 있다.</p>\n<ol>\n<li>RSA 암호 방식으로 암호화가 되어 있기 때문에 PUBLIC KEY 를 이용해 key객체를 생성한다.</li>\n<li>PKCS(Public Key Cryptography Standard)를 이용해서 암호화된 영수증을 검증 할것이다. 1번에서 만들어진 key를 이용해 verifier 객체를 생성하자.</li>\n<li>SHA(Secure Hash Algorithm)으로 된 signed_data를 객체로 생성한다.</li>\n<li>signature 를 decode 한다.</li>\n<li>2번에서 생성한 verifier를 통해 data 와 sig 의 유효성을 판단한다. 유효한 영수증은 True 그렇지 않으면 False 를 반환한다.<br>\n이 부분에 대해서는 좀 더 공부가 필요해 보인다… 현재는 암호화에 대한 꼭지들이 의미하는 바를 인지해야겠지만 이들이 어떤 작업을 하는지에 대한 공부도 반드시 필요할 것이다.<br>\n코드 내용이 그리 간단하지는 않지만 비교적 빠르게 구글 영수증 검증을 할 수 있었다. 구글의 개발자 사이트를 들어가 이런 저런 글도 읽오보고 여러 포스팅을 찾아보면서 여러가지 자료를 봐왔었는데 stackoverflow 에서 찾은 글들을 추려 간단하게 메소드로 정리했다. 내가 여기서 삽질 했던 부분은 대체 signed_data 와 signature 가 무엇을 뜻하는지 알 수가 없었다는 점이였다. 대부분의 자료들에서는 저 둘이 무엇을 의미하는지 자세히 기술을 해놓지 않거나 아예 어떤 값을 의미하는지를 써놓지 않은 글들이 많았다. 나도 처음에는 이리저리 고민을 해보다가 일단 맨땅에 헤딩을 하고보자는 마음으로 여러 땅에 삽집을 하다가 찾은 결과물이다.</li>\n</ol>\n<ol start=\"2\">\n<li>iOS in-app purchase<br>\n이번에는 iOS결제 영수증 검증을 해보도록 하자. apple은 구글과는 다르게 결제 서버에 영수증을 보내서 넘어온 값을 통해 영수증의 유효성을 판단한다. 직접 apple의 결제 api를 호출해서 검증을 해도 되지만 역시나 Python은 있을만하다고 생각하는 라이브러리는 이미 존재하거나 누군가가 만들어 놨다. 우리는 이 라이브러리를 만든분 께 감사를 드리며 코드를 받아가도록 하자.</li>\n</ol>\n<figure class=\"highlight cmake\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">pip <span class=\"keyword\">install</span> itunes-iap</div></pre></td></tr></table></figure>\n<p>itunes-iap를 설치하면 의존성 라이브러리들이 이것저것 왕창 설치된다. 궁금하면 ($pip list 를 통해 확인해볼것)<br>\n이번에는 iOS 영수증 검증 코드를 보도록 하자. 이 때 transaction_id 는 결제 당시 결과값으로 오는 구매 영수증 id이고, raw_data는 암호화된 영수증 문자열이다.</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">import</span> itunesiap</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">_verify_for_ios</span><span class=\"params\">(transaction_id: str, raw_data: str)</span>:</span></div><div class=\"line\">    <span class=\"string\">\"\"\"</span></div><div class=\"line\">    seeAlso : https://developer.apple.com/library/ios/releasenotes/General/ValidateAppStoreReceipt/Chapters/ValidateRemotely.html</div><div class=\"line\">    :param transaction_id: 결제 transaction_id</div><div class=\"line\">    :param raw_data: base64-encoded data</div><div class=\"line\">    :return: boolean</div><div class=\"line\">    :raises: Otherwise raise a request exception (RuntimeError, itunesiap.exc.InvalidReceipt)</div><div class=\"line\">    \"\"\"</div><div class=\"line\">    <span class=\"keyword\">try</span>:</div><div class=\"line\">        <span class=\"comment\"># for sandbox environment.</span></div><div class=\"line\">        <span class=\"comment\">#     with itunesiap.env.sandbox:</span></div><div class=\"line\">        <span class=\"comment\">#         response = itunesiap.verify(raw_data)</span></div><div class=\"line\"></div><div class=\"line\">        <span class=\"comment\"># for production environment. (default)</span></div><div class=\"line\">        response = itunesiap.verify(raw_data)  <span class=\"comment\"># base64-encoded data</span></div><div class=\"line\"></div><div class=\"line\">        <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">_get_key</span><span class=\"params\">(re)</span>:</span></div><div class=\"line\">            <span class=\"string\">\"\"\" 영수증리스트에서 비교 키를 반환합니다. \"\"\"</span></div><div class=\"line\">            <span class=\"keyword\">return</span> re.purchase_date_ms</div><div class=\"line\"></div><div class=\"line\">        <span class=\"comment\"># 넘어온 in_app 영수증 리스트에서 구매 시각이 가장 마지막인 영수증을 가져와서 transaction_id를 비교한다.</span></div><div class=\"line\">        <span class=\"comment\"># 오름 차순으로 정렬해서 구매시각이 가장 마지막 영수증을 가져옵니다.</span></div><div class=\"line\">        receipts = sorted(response.receipt.in_app, key=_get_key)</div><div class=\"line\">        last_receipt = receipts[len(receipts) - <span class=\"number\">1</span>]</div><div class=\"line\">        <span class=\"keyword\">if</span> last_receipt.transaction_id != transaction_id:</div><div class=\"line\">            <span class=\"comment\">#  구매시각이 가장 마지막인 영수증의 transaction_id 가 일치 하지 않는다.</span></div><div class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">False</span></div><div class=\"line\"></div><div class=\"line\">        <span class=\"keyword\">return</span> response.status == <span class=\"number\">0</span></div></pre></td></tr></table></figure>\n<p>iOS 영수증 유효성 검증은 간단하다. itunesiap.verify 메소드를 통해 iOS에서 넘어온 데이터를 넣고 호출하면 복호화된 영수증 데이터가 나온다. 이 때 status 값이 0 이라면 유효한 영수증이라고 판단한다. 뭔가 apple다운 api라고 생각한다. 처음 iOS영수증 검증을 할 당시엔 verify 메소드만 호출하고 그 뒤에 넘어온 데이터의 status 값만 확인하고 유효성을 검증했다.<br>\n여기서 나의 삽질이 시작되었다.</p>\n<ol>\n<li>\n<p>일단 주석에서 보는것과 같이 sandbox환경과 real환경일 때에 호출하는 api가 다르다. itunesiap의 환경을 설정을 해주는 방법은 여러가지가 있다. 각자 개발환경에서 영수증 유효성을 검사할 때엔 sandbox와 real환경을 잘 구분해서 api를 호출해주도록 하자. 아무리 유효한 영수증이라 할지라도 틀린 환경의 api를 호출하면 유효하지 않다고 판단하기 때문이다.</p>\n</li>\n<li>\n<p>보통 verify 메소드를 호출하면 receipt 값 안에 하나의 영수증 정보만 가져온다. 하지만 특정 상황의 경우 receipt 데이터 안에 1개 이상의 영수증 정보가 딸려 오는 경우가 있다. 이 때에 한가지 데이터만이 유효한 영수증 값이다. 이 중에서 한가지 영수증만을 가지고 검증을 해야 하는데 여러 삽질 후에 깨달은 바는 receipt 안의 데이터들의 purchase_date_ms 값을 이용해 가장 마지막에 결제된 영수증 정보가 파라메터로 넘어온 transaction_id 와 동일하다는 점을 알게 되었다. 그래서 _get_key 메소드를 통해 receipt 리스트를 정렬하고, 그 중에 가장 마지막 영수증 정보를 뽑아 transaction_id 가 같은지 여부를 판단한다.</p>\n</li>\n</ol>\n<p>자 이제 우리는 python을 이용해서 android, iOS의 영수증을 검증할 수 있게 되었다. 간단하지도 복잡하지도 않고, 몰랐을 때는 어려워 난해했지만 알고나니 더 난해한 비교적 간단하게 할 수 있는 파트였다. 이제 어디가서 이 두 플랫폼의 결제 영수증쯤은 아무렇지도 않게 검증 할 수 있다고 당당히 얘기하자.</p>\n","site":{"data":{}},"excerpt":"","more":"<p>Django framework를 이용해서 프로젝트를 만들면서 했던 여러가지 삽질들과 넘어야했던 많은 산들과 몰랐던 부분들에 대해서 내 나름 공부 겸 기록을 위해 남겨둬야 겠다는 생각이 들었다. 프로젝트로 한창 바빴던 시기에는 당장 앞에 놓여진 일들에 치여 이런 생각을 못하고 있다가 지금은 조금 여유가 되어 그 때 있었던 일들에 대한 나름의 경험을 기록해보고자 한다.</p>\n<p>그 중에 한가지가 인앱 아이템 결제하기 였다. 나는 예전에 cocos2d-x로 게임을 개발했던 시절엔 결제 프로세스를 클라이언트(단말기)사이드만 알고 있었고 서버사이드의 로직은 전혀 모르고 있었는데, 오히려 이번에 서버 로직을 구현하면서 그 때 그 시절의 경험이 많은 도움이 되었다. 앱 내에 아이템을 구매하고 구매한 아이템을 유저에게 잘 넣어주는 로직이야 구현방식도 다양하고 여러 기교들이 들어가 있는데 오늘은 그 중에서 나름 간단한(?) 파트인 두 플랫폼의 결제 영수증 검증 로직의 삽질 경험을 적어보고자 한다.</p>\n<p>이번에 대응했던 클라이언트는 google play store와 iOS app store 두개의 플랫폼이다. 차례차례 훑어보자.<br>\n각 플랫폼별 스토어의 앱 등록과 각종 키발급 같은 내용은 다루지 않고 순수하게 영수증 검증만을 볼 것이다.</p>\n<ol>\n<li>google In-app billing<br>\n구글 결제 영수증 검증의 경우 생각보다 단순해서 처음에는 이게 맞나? 싶었다. 일반적으로 생각하기에는 구글의 결제서버에 영수증 정보를 넘겨 유효한 영수증인지 여부를 판단해서 진행이 되는줄 알았는데(이렇게 하는 방법도 있다고 한다.), 훨씬 간단한 방법이 있었다. 암호화된 영수증 정보를 클라이언트로 부터 받아와서 local에서 검증하는 방식이다.</li>\n</ol>\n<p>일단 pip를 이용해서 Crypto 라이브러리를 설치하도록 하자.</p>\n<figure class=\"highlight cmake\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">pip <span class=\"keyword\">install</span> pycrypto</div></pre></td></tr></table></figure>\n<p>다음은 영수증 검증 코드이다. signed_data 는 안드로이드 결제완료시 넘어온 암호화된 영수증 문자열이고 signature는 클라이언트와 약속된 특정 문자열이다. 안드로이드에서 결제를 요청할 당시 이 값을 함께 넘겨주면 signed_data 내부에 이 signature 값이 심어들어가게 되고, 복호화를 하면 이 값이 풀어져 나와 영수증 검증을 할 수 있다.</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">from</span> base64 <span class=\"keyword\">import</span> b64decode</div><div class=\"line\"><span class=\"keyword\">from</span> Crypto.Hash <span class=\"keyword\">import</span> SHA</div><div class=\"line\"><span class=\"keyword\">from</span> Crypto.PublicKey <span class=\"keyword\">import</span> RSA</div><div class=\"line\"><span class=\"keyword\">from</span> Crypto.Signature <span class=\"keyword\">import</span> PKCS1_v1_5</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\"># Your base64 encoded public key from Google Play.</span></div><div class=\"line\">PUBLIC_KEY_BASE64 = <span class=\"string\">'YOUR_PUBLIC_KEY_BASE64'</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">verify_for_google</span><span class=\"params\">(signed_data, signature)</span>:</span></div><div class=\"line\">    <span class=\"string\">\"\"\"Returns whether the given data was signed with the private key.\"\"\"</span></div><div class=\"line\">    key = RSA.importKey(_pem_format(PUBLIC_KEY_BASE64))</div><div class=\"line\">    verifier = PKCS1_v1_5.new(key)</div><div class=\"line\">    data = SHA.new(signed_data.encode(<span class=\"string\">'utf8'</span>))</div><div class=\"line\">    sig = b64decode(signature)</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">return</span> verifier.verify(data, sig)</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">_pem_format</span><span class=\"params\">(key)</span>:</span></div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">'\\n'</span>.join([</div><div class=\"line\">        <span class=\"string\">'-----BEGIN PUBLIC KEY-----'</span>,</div><div class=\"line\">        <span class=\"string\">'\\n'</span>.join(_chunks(key, <span class=\"number\">64</span>)),</div><div class=\"line\">        <span class=\"string\">'-----END PUBLIC KEY-----'</span></div><div class=\"line\">    ])</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">_chunks</span><span class=\"params\">(s, n)</span>:</span></div><div class=\"line\">    <span class=\"keyword\">for</span> start <span class=\"keyword\">in</span> range(<span class=\"number\">0</span>, len(s), n):</div><div class=\"line\">        <span class=\"keyword\">yield</span> s[start:start+n]</div></pre></td></tr></table></figure>\n<p>먼저 스토어에서 발급받은 공개키가 필요하다. 이 키를 이용해 넘어온 데이터가 유효한지 여부를 판단할 수 있다.</p>\n<ol>\n<li>RSA 암호 방식으로 암호화가 되어 있기 때문에 PUBLIC KEY 를 이용해 key객체를 생성한다.</li>\n<li>PKCS(Public Key Cryptography Standard)를 이용해서 암호화된 영수증을 검증 할것이다. 1번에서 만들어진 key를 이용해 verifier 객체를 생성하자.</li>\n<li>SHA(Secure Hash Algorithm)으로 된 signed_data를 객체로 생성한다.</li>\n<li>signature 를 decode 한다.</li>\n<li>2번에서 생성한 verifier를 통해 data 와 sig 의 유효성을 판단한다. 유효한 영수증은 True 그렇지 않으면 False 를 반환한다.<br>\n이 부분에 대해서는 좀 더 공부가 필요해 보인다… 현재는 암호화에 대한 꼭지들이 의미하는 바를 인지해야겠지만 이들이 어떤 작업을 하는지에 대한 공부도 반드시 필요할 것이다.<br>\n코드 내용이 그리 간단하지는 않지만 비교적 빠르게 구글 영수증 검증을 할 수 있었다. 구글의 개발자 사이트를 들어가 이런 저런 글도 읽오보고 여러 포스팅을 찾아보면서 여러가지 자료를 봐왔었는데 stackoverflow 에서 찾은 글들을 추려 간단하게 메소드로 정리했다. 내가 여기서 삽질 했던 부분은 대체 signed_data 와 signature 가 무엇을 뜻하는지 알 수가 없었다는 점이였다. 대부분의 자료들에서는 저 둘이 무엇을 의미하는지 자세히 기술을 해놓지 않거나 아예 어떤 값을 의미하는지를 써놓지 않은 글들이 많았다. 나도 처음에는 이리저리 고민을 해보다가 일단 맨땅에 헤딩을 하고보자는 마음으로 여러 땅에 삽집을 하다가 찾은 결과물이다.</li>\n</ol>\n<ol start=\"2\">\n<li>iOS in-app purchase<br>\n이번에는 iOS결제 영수증 검증을 해보도록 하자. apple은 구글과는 다르게 결제 서버에 영수증을 보내서 넘어온 값을 통해 영수증의 유효성을 판단한다. 직접 apple의 결제 api를 호출해서 검증을 해도 되지만 역시나 Python은 있을만하다고 생각하는 라이브러리는 이미 존재하거나 누군가가 만들어 놨다. 우리는 이 라이브러리를 만든분 께 감사를 드리며 코드를 받아가도록 하자.</li>\n</ol>\n<figure class=\"highlight cmake\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">pip <span class=\"keyword\">install</span> itunes-iap</div></pre></td></tr></table></figure>\n<p>itunes-iap를 설치하면 의존성 라이브러리들이 이것저것 왕창 설치된다. 궁금하면 ($pip list 를 통해 확인해볼것)<br>\n이번에는 iOS 영수증 검증 코드를 보도록 하자. 이 때 transaction_id 는 결제 당시 결과값으로 오는 구매 영수증 id이고, raw_data는 암호화된 영수증 문자열이다.</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">import</span> itunesiap</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">_verify_for_ios</span><span class=\"params\">(transaction_id: str, raw_data: str)</span>:</span></div><div class=\"line\">    <span class=\"string\">\"\"\"</span></div><div class=\"line\">    seeAlso : https://developer.apple.com/library/ios/releasenotes/General/ValidateAppStoreReceipt/Chapters/ValidateRemotely.html</div><div class=\"line\">    :param transaction_id: 결제 transaction_id</div><div class=\"line\">    :param raw_data: base64-encoded data</div><div class=\"line\">    :return: boolean</div><div class=\"line\">    :raises: Otherwise raise a request exception (RuntimeError, itunesiap.exc.InvalidReceipt)</div><div class=\"line\">    \"\"\"</div><div class=\"line\">    <span class=\"keyword\">try</span>:</div><div class=\"line\">        <span class=\"comment\"># for sandbox environment.</span></div><div class=\"line\">        <span class=\"comment\">#     with itunesiap.env.sandbox:</span></div><div class=\"line\">        <span class=\"comment\">#         response = itunesiap.verify(raw_data)</span></div><div class=\"line\"></div><div class=\"line\">        <span class=\"comment\"># for production environment. (default)</span></div><div class=\"line\">        response = itunesiap.verify(raw_data)  <span class=\"comment\"># base64-encoded data</span></div><div class=\"line\"></div><div class=\"line\">        <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">_get_key</span><span class=\"params\">(re)</span>:</span></div><div class=\"line\">            <span class=\"string\">\"\"\" 영수증리스트에서 비교 키를 반환합니다. \"\"\"</span></div><div class=\"line\">            <span class=\"keyword\">return</span> re.purchase_date_ms</div><div class=\"line\"></div><div class=\"line\">        <span class=\"comment\"># 넘어온 in_app 영수증 리스트에서 구매 시각이 가장 마지막인 영수증을 가져와서 transaction_id를 비교한다.</span></div><div class=\"line\">        <span class=\"comment\"># 오름 차순으로 정렬해서 구매시각이 가장 마지막 영수증을 가져옵니다.</span></div><div class=\"line\">        receipts = sorted(response.receipt.in_app, key=_get_key)</div><div class=\"line\">        last_receipt = receipts[len(receipts) - <span class=\"number\">1</span>]</div><div class=\"line\">        <span class=\"keyword\">if</span> last_receipt.transaction_id != transaction_id:</div><div class=\"line\">            <span class=\"comment\">#  구매시각이 가장 마지막인 영수증의 transaction_id 가 일치 하지 않는다.</span></div><div class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">False</span></div><div class=\"line\"></div><div class=\"line\">        <span class=\"keyword\">return</span> response.status == <span class=\"number\">0</span></div></pre></td></tr></table></figure>\n<p>iOS 영수증 유효성 검증은 간단하다. itunesiap.verify 메소드를 통해 iOS에서 넘어온 데이터를 넣고 호출하면 복호화된 영수증 데이터가 나온다. 이 때 status 값이 0 이라면 유효한 영수증이라고 판단한다. 뭔가 apple다운 api라고 생각한다. 처음 iOS영수증 검증을 할 당시엔 verify 메소드만 호출하고 그 뒤에 넘어온 데이터의 status 값만 확인하고 유효성을 검증했다.<br>\n여기서 나의 삽질이 시작되었다.</p>\n<ol>\n<li>\n<p>일단 주석에서 보는것과 같이 sandbox환경과 real환경일 때에 호출하는 api가 다르다. itunesiap의 환경을 설정을 해주는 방법은 여러가지가 있다. 각자 개발환경에서 영수증 유효성을 검사할 때엔 sandbox와 real환경을 잘 구분해서 api를 호출해주도록 하자. 아무리 유효한 영수증이라 할지라도 틀린 환경의 api를 호출하면 유효하지 않다고 판단하기 때문이다.</p>\n</li>\n<li>\n<p>보통 verify 메소드를 호출하면 receipt 값 안에 하나의 영수증 정보만 가져온다. 하지만 특정 상황의 경우 receipt 데이터 안에 1개 이상의 영수증 정보가 딸려 오는 경우가 있다. 이 때에 한가지 데이터만이 유효한 영수증 값이다. 이 중에서 한가지 영수증만을 가지고 검증을 해야 하는데 여러 삽질 후에 깨달은 바는 receipt 안의 데이터들의 purchase_date_ms 값을 이용해 가장 마지막에 결제된 영수증 정보가 파라메터로 넘어온 transaction_id 와 동일하다는 점을 알게 되었다. 그래서 _get_key 메소드를 통해 receipt 리스트를 정렬하고, 그 중에 가장 마지막 영수증 정보를 뽑아 transaction_id 가 같은지 여부를 판단한다.</p>\n</li>\n</ol>\n<p>자 이제 우리는 python을 이용해서 android, iOS의 영수증을 검증할 수 있게 되었다. 간단하지도 복잡하지도 않고, 몰랐을 때는 어려워 난해했지만 알고나니 더 난해한 비교적 간단하게 할 수 있는 파트였다. 이제 어디가서 이 두 플랫폼의 결제 영수증쯤은 아무렇지도 않게 검증 할 수 있다고 당당히 얘기하자.</p>\n"}],"PostAsset":[],"PostCategory":[],"PostTag":[{"post_id":"cj3r0l3h900019fhhq4vnfsz3","tag_id":"cj3r0l3ho00059fhhn96gyfho","_id":"cj3r0l3hw00099fhhapwk4b03"},{"post_id":"cj3r0l3h900019fhhq4vnfsz3","tag_id":"cj3r0l3ht00079fhhzyyjcgjv","_id":"cj3r0l3hw000a9fhhpusodk86"},{"post_id":"cj3r0l3hg00039fhhgpag16j3","tag_id":"cj3r0l3ho00059fhhn96gyfho","_id":"cj3r0l3hx000d9fhhttx0sp43"},{"post_id":"cj3r0l3hg00039fhhgpag16j3","tag_id":"cj3r0l3hw000b9fhhkf470aia","_id":"cj3r0l3hy000e9fhh3n3lekf3"},{"post_id":"cj3r0l3hq00069fhhlwgr5zrq","tag_id":"cj3r0l3hx000c9fhh7u466mxd","_id":"cj3r0l3hy000i9fhhd5uluvup"},{"post_id":"cj3r0l3hq00069fhhlwgr5zrq","tag_id":"cj3r0l3hy000f9fhhxvyca4pw","_id":"cj3r0l3hy000j9fhhhzymuna6"},{"post_id":"cj3r0l3hq00069fhhlwgr5zrq","tag_id":"cj3r0l3hy000g9fhhzupbvikp","_id":"cj3r0l3hy000k9fhhysqc0lys"},{"post_id":"cj3r0l3hq00069fhhlwgr5zrq","tag_id":"cj3r0l3hy000h9fhhoo81c9q9","_id":"cj3r0l3hy000l9fhhrg0ingcy"}],"Tag":[{"name":"django","_id":"cj3r0l3ho00059fhhn96gyfho"},{"name":"ajax","_id":"cj3r0l3ht00079fhhzyyjcgjv"},{"name":"sso","_id":"cj3r0l3hw000b9fhhkf470aia"},{"name":"python","_id":"cj3r0l3hx000c9fhh7u466mxd"},{"name":"ios","_id":"cj3r0l3hy000f9fhhxvyca4pw"},{"name":"android","_id":"cj3r0l3hy000g9fhhzupbvikp"},{"name":"inapp","_id":"cj3r0l3hy000h9fhhoo81c9q9"}]}}